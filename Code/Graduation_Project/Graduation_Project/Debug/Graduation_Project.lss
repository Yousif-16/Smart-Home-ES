
Graduation_Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000306e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000007ae  00800060  0000306e  00003102  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000024  0080080e  0080080e  000038b0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000038b0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000038e0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000004e8  00000000  00000000  0000391c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000079d2  00000000  00000000  00003e04  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000168c  00000000  00000000  0000b7d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000038f9  00000000  00000000  0000ce62  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000c44  00000000  00000000  0001075c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e7c  00000000  00000000  000113a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000399c  00000000  00000000  0001221c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000478  00000000  00000000  00015bb8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 f1 08 	jmp	0x11e2	; 0x11e2 <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 36 15 	jmp	0x2a6c	; 0x2a6c <__vector_4>
      14:	0c 94 f3 14 	jmp	0x29e6	; 0x29e6 <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 30 14 	jmp	0x2860	; 0x2860 <__vector_10>
      2c:	0c 94 e3 13 	jmp	0x27c6	; 0x27c6 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 d7 15 	jmp	0x2bae	; 0x2bae <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 fd 15 	jmp	0x2bfa	; 0x2bfa <__vector_15>
      40:	0c 94 6f 00 	jmp	0xde	; 0xde <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	18 e0       	ldi	r17, 0x08	; 8
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e6       	ldi	r30, 0x6E	; 110
      68:	f0 e3       	ldi	r31, 0x30	; 48
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ae 30       	cpi	r26, 0x0E	; 14
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	28 e0       	ldi	r18, 0x08	; 8
      78:	ae e0       	ldi	r26, 0x0E	; 14
      7a:	b8 e0       	ldi	r27, 0x08	; 8
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 33       	cpi	r26, 0x32	; 50
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <main>
      8a:	0c 94 35 18 	jmp	0x306a	; 0x306a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <ADC_Init>:
 return Value;
 }

 void ADC_Disable(void)
 {
 Clear_Bit(ADCSRA, 7);
      92:	87 b1       	in	r24, 0x07	; 7
      94:	8f 73       	andi	r24, 0x3F	; 63
      96:	80 64       	ori	r24, 0x40	; 64
      98:	87 b9       	out	0x07, r24	; 7
      9a:	87 b1       	in	r24, 0x07	; 7
      9c:	8f 7d       	andi	r24, 0xDF	; 223
      9e:	87 b9       	out	0x07, r24	; 7
      a0:	86 b1       	in	r24, 0x06	; 6
      a2:	80 62       	ori	r24, 0x20	; 32
      a4:	86 b9       	out	0x06, r24	; 6
      a6:	80 b7       	in	r24, 0x30	; 48
      a8:	8f 71       	andi	r24, 0x1F	; 31
      aa:	80 bf       	out	0x30, r24	; 48
      ac:	86 b1       	in	r24, 0x06	; 6
      ae:	87 60       	ori	r24, 0x07	; 7
      b0:	86 b9       	out	0x06, r24	; 6
      b2:	8f b7       	in	r24, 0x3f	; 63
      b4:	80 68       	ori	r24, 0x80	; 128
      b6:	8f bf       	out	0x3f, r24	; 63
      b8:	86 b1       	in	r24, 0x06	; 6
      ba:	88 60       	ori	r24, 0x08	; 8
      bc:	86 b9       	out	0x06, r24	; 6
      be:	86 b1       	in	r24, 0x06	; 6
      c0:	80 68       	ori	r24, 0x80	; 128
      c2:	86 b9       	out	0x06, r24	; 6
      c4:	08 95       	ret

000000c6 <ADC_Read>:
      c6:	97 b1       	in	r25, 0x07	; 7
      c8:	90 7e       	andi	r25, 0xE0	; 224
      ca:	89 2b       	or	r24, r25
      cc:	87 b9       	out	0x07, r24	; 7
      ce:	86 b1       	in	r24, 0x06	; 6
      d0:	80 64       	ori	r24, 0x40	; 64
      d2:	86 b9       	out	0x06, r24	; 6
      d4:	34 9b       	sbis	0x06, 4	; 6
      d6:	fe cf       	rjmp	.-4      	; 0xd4 <ADC_Read+0xe>
      d8:	84 b1       	in	r24, 0x04	; 4
      da:	95 b1       	in	r25, 0x05	; 5
      dc:	08 95       	ret

000000de <__vector_16>:
 }

 ISR(ADC_vect)
 {
      de:	1f 92       	push	r1
      e0:	0f 92       	push	r0
      e2:	0f b6       	in	r0, 0x3f	; 63
      e4:	0f 92       	push	r0
      e6:	11 24       	eor	r1, r1
      e8:	2f 93       	push	r18
      ea:	3f 93       	push	r19
      ec:	4f 93       	push	r20
      ee:	5f 93       	push	r21
      f0:	6f 93       	push	r22
      f2:	7f 93       	push	r23
      f4:	8f 93       	push	r24
      f6:	9f 93       	push	r25
      f8:	af 93       	push	r26
      fa:	bf 93       	push	r27
      fc:	ef 93       	push	r30
      fe:	ff 93       	push	r31
 // Write the ADC handler here
 Temp = ADC_Read(PIN_7);
     100:	87 e0       	ldi	r24, 0x07	; 7
     102:	0e 94 63 00 	call	0xc6	; 0xc6 <ADC_Read>
     106:	90 93 0f 08 	sts	0x080F, r25	; 0x80080f <__data_end+0x1>
     10a:	80 93 0e 08 	sts	0x080E, r24	; 0x80080e <__data_end>
 if(Temp >= 57)
     10e:	c9 97       	sbiw	r24, 0x39	; 57
     110:	28 f0       	brcs	.+10     	; 0x11c <__vector_16+0x3e>
 DC_Motor1_START(100,Anti_Clock_Wise);
     112:	61 e0       	ldi	r22, 0x01	; 1
     114:	84 e6       	ldi	r24, 0x64	; 100
     116:	90 e0       	ldi	r25, 0x00	; 0
     118:	0e 94 3b 01 	call	0x276	; 0x276 <DC_Motor1_START>
 if(Temp <= 43)
     11c:	80 91 0e 08 	lds	r24, 0x080E	; 0x80080e <__data_end>
     120:	90 91 0f 08 	lds	r25, 0x080F	; 0x80080f <__data_end+0x1>
     124:	8c 97       	sbiw	r24, 0x2c	; 44
     126:	10 f4       	brcc	.+4      	; 0x12c <__vector_16+0x4e>
 DC_Motor1_STOP();
     128:	0e 94 62 01 	call	0x2c4	; 0x2c4 <DC_Motor1_STOP>
 if(i)
     12c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     130:	88 23       	and	r24, r24
     132:	61 f0       	breq	.+24     	; 0x14c <__vector_16+0x6e>
 {
	Timer2_Init();
     134:	0e 94 97 14 	call	0x292e	; 0x292e <Timer2_Init>
	Timer2_Start();
     138:	0e 94 ef 14 	call	0x29de	; 0x29de <Timer2_Start>
	Timer2_SetDelay(100);
     13c:	64 e6       	ldi	r22, 0x64	; 100
     13e:	70 e0       	ldi	r23, 0x00	; 0
     140:	80 e0       	ldi	r24, 0x00	; 0
     142:	90 e0       	ldi	r25, 0x00	; 0
     144:	0e 94 a4 14 	call	0x2948	; 0x2948 <Timer2_SetDelay>
	i = 0; 
     148:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
 }
 }
     14c:	ff 91       	pop	r31
     14e:	ef 91       	pop	r30
     150:	bf 91       	pop	r27
     152:	af 91       	pop	r26
     154:	9f 91       	pop	r25
     156:	8f 91       	pop	r24
     158:	7f 91       	pop	r23
     15a:	6f 91       	pop	r22
     15c:	5f 91       	pop	r21
     15e:	4f 91       	pop	r20
     160:	3f 91       	pop	r19
     162:	2f 91       	pop	r18
     164:	0f 90       	pop	r0
     166:	0f be       	out	0x3f, r0	; 63
     168:	0f 90       	pop	r0
     16a:	1f 90       	pop	r1
     16c:	18 95       	reti

0000016e <ALARM_ON>:

void ALARM_ON(void)

{
	
	LED0_Toggle();
     16e:	0e 94 8c 0b 	call	0x1718	; 0x1718 <LED0_Toggle>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     172:	2f e3       	ldi	r18, 0x3F	; 63
     174:	8d e0       	ldi	r24, 0x0D	; 13
     176:	93 e0       	ldi	r25, 0x03	; 3
     178:	21 50       	subi	r18, 0x01	; 1
     17a:	80 40       	sbci	r24, 0x00	; 0
     17c:	90 40       	sbci	r25, 0x00	; 0
     17e:	e1 f7       	brne	.-8      	; 0x178 <ALARM_ON+0xa>
     180:	00 c0       	rjmp	.+0      	; 0x182 <ALARM_ON+0x14>
     182:	00 00       	nop
	_delay_ms(D);
	LED2_Toggle();
     184:	0e 94 c4 0b 	call	0x1788	; 0x1788 <LED2_Toggle>
     188:	2f e3       	ldi	r18, 0x3F	; 63
     18a:	8d e0       	ldi	r24, 0x0D	; 13
     18c:	93 e0       	ldi	r25, 0x03	; 3
     18e:	21 50       	subi	r18, 0x01	; 1
     190:	80 40       	sbci	r24, 0x00	; 0
     192:	90 40       	sbci	r25, 0x00	; 0
     194:	e1 f7       	brne	.-8      	; 0x18e <ALARM_ON+0x20>
     196:	00 c0       	rjmp	.+0      	; 0x198 <ALARM_ON+0x2a>
     198:	00 00       	nop
	_delay_ms(D);
	LED4_Toggle();
     19a:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <LED4_Toggle>
	Buzzer_Toggle();
     19e:	0e 94 1f 01 	call	0x23e	; 0x23e <Buzzer_Toggle>
     1a2:	2f e3       	ldi	r18, 0x3F	; 63
     1a4:	8d e0       	ldi	r24, 0x0D	; 13
     1a6:	93 e0       	ldi	r25, 0x03	; 3
     1a8:	21 50       	subi	r18, 0x01	; 1
     1aa:	80 40       	sbci	r24, 0x00	; 0
     1ac:	90 40       	sbci	r25, 0x00	; 0
     1ae:	e1 f7       	brne	.-8      	; 0x1a8 <ALARM_ON+0x3a>
     1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <ALARM_ON+0x44>
     1b2:	00 00       	nop
	_delay_ms(D);
	
	LED0_OFF();
     1b4:	0e 94 86 0b 	call	0x170c	; 0x170c <LED0_OFF>
	LED2_OFF();
     1b8:	0e 94 be 0b 	call	0x177c	; 0x177c <LED2_OFF>
	LED4_OFF();
     1bc:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <LED4_OFF>
	Buzzer_OFF();
     1c0:	0e 94 19 01 	call	0x232	; 0x232 <Buzzer_OFF>
	
	LED1_Toggle();
     1c4:	0e 94 a8 0b 	call	0x1750	; 0x1750 <LED1_Toggle>
     1c8:	2f e3       	ldi	r18, 0x3F	; 63
     1ca:	8d e0       	ldi	r24, 0x0D	; 13
     1cc:	93 e0       	ldi	r25, 0x03	; 3
     1ce:	21 50       	subi	r18, 0x01	; 1
     1d0:	80 40       	sbci	r24, 0x00	; 0
     1d2:	90 40       	sbci	r25, 0x00	; 0
     1d4:	e1 f7       	brne	.-8      	; 0x1ce <ALARM_ON+0x60>
     1d6:	00 c0       	rjmp	.+0      	; 0x1d8 <ALARM_ON+0x6a>
     1d8:	00 00       	nop
	_delay_ms(D);
	LED3_Toggle();
     1da:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <LED3_Toggle>
	Buzzer_Toggle();
     1de:	0e 94 1f 01 	call	0x23e	; 0x23e <Buzzer_Toggle>
     1e2:	2f e3       	ldi	r18, 0x3F	; 63
     1e4:	8d e0       	ldi	r24, 0x0D	; 13
     1e6:	93 e0       	ldi	r25, 0x03	; 3
     1e8:	21 50       	subi	r18, 0x01	; 1
     1ea:	80 40       	sbci	r24, 0x00	; 0
     1ec:	90 40       	sbci	r25, 0x00	; 0
     1ee:	e1 f7       	brne	.-8      	; 0x1e8 <ALARM_ON+0x7a>
     1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <ALARM_ON+0x84>
     1f2:	00 00       	nop
	_delay_ms(D);
	
	LED1_OFF();
     1f4:	0e 94 a2 0b 	call	0x1744	; 0x1744 <LED1_OFF>
	LED3_OFF();
     1f8:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <LED3_OFF>
	Buzzer_OFF();
     1fc:	0e 94 19 01 	call	0x232	; 0x232 <Buzzer_OFF>
     200:	08 95       	ret

00000202 <Init_Button>:


Uint8 Init_Button (Uint8 Port_num,Uint8 Pin_num)
{
	Uint8 ret_val=Success_Button;
	if(Port_num>3||Pin_num>7)
     202:	84 30       	cpi	r24, 0x04	; 4
     204:	38 f4       	brcc	.+14     	; 0x214 <Init_Button+0x12>
     206:	68 30       	cpi	r22, 0x08	; 8
     208:	38 f4       	brcc	.+14     	; 0x218 <Init_Button+0x16>
	{
		ret_val=Error_Button;
	}
	else
	{
		DIO_SetPin_Value(Port_num, Pin_num,PIN_IN);
     20a:	40 e0       	ldi	r20, 0x00	; 0
     20c:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
#include "Button.h"


Uint8 Init_Button (Uint8 Port_num,Uint8 Pin_num)
{
	Uint8 ret_val=Success_Button;
     210:	80 e0       	ldi	r24, 0x00	; 0
     212:	08 95       	ret
	if(Port_num>3||Pin_num>7)
	{
		ret_val=Error_Button;
     214:	81 e0       	ldi	r24, 0x01	; 1
     216:	08 95       	ret
     218:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		DIO_SetPin_Value(Port_num, Pin_num,PIN_IN);
	}
	return ret_val;
}
     21a:	08 95       	ret

0000021c <Buzzer_Init>:
	DIO_SetPin_Value(Buzzer_Port, Buzzer_Pin, PIN_OFF);
}

void Buzzer_ON(void)
{
	DIO_SetPin_Value(Buzzer_Port, Buzzer_Pin, PIN_ON);
     21c:	41 e0       	ldi	r20, 0x01	; 1
     21e:	67 e0       	ldi	r22, 0x07	; 7
     220:	82 e0       	ldi	r24, 0x02	; 2
     222:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
     226:	41 e0       	ldi	r20, 0x01	; 1
     228:	67 e0       	ldi	r22, 0x07	; 7
     22a:	82 e0       	ldi	r24, 0x02	; 2
     22c:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
     230:	08 95       	ret

00000232 <Buzzer_OFF>:
}
void Buzzer_OFF(void)
{
	DIO_SetPin_Value(Buzzer_Port, Buzzer_Pin, PIN_OFF);
     232:	41 e0       	ldi	r20, 0x01	; 1
     234:	67 e0       	ldi	r22, 0x07	; 7
     236:	82 e0       	ldi	r24, 0x02	; 2
     238:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
     23c:	08 95       	ret

0000023e <Buzzer_Toggle>:
}

void Buzzer_Toggle(void)
{
	DIO_TogglePin_Value(Buzzer_Port, Buzzer_Pin);
     23e:	67 e0       	ldi	r22, 0x07	; 7
     240:	82 e0       	ldi	r24, 0x02	; 2
     242:	0e 94 7d 02 	call	0x4fa	; 0x4fa <DIO_TogglePin_Value>
     246:	08 95       	ret

00000248 <DC_Motor1_INIT>:

/*DC_Motor1 Functions implementation*/
void DC_Motor1_INIT(void)
{
	/*DC motor pins direction*/
	DIO_SetPin_Dir(M1_PORT, M1_DIR_PIN1, PIN_OUT);
     248:	41 e0       	ldi	r20, 0x01	; 1
     24a:	66 e0       	ldi	r22, 0x06	; 6
     24c:	83 e0       	ldi	r24, 0x03	; 3
     24e:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
	DIO_SetPin_Dir(M1_PORT, M1_DIR_PIN2, PIN_OUT);
     252:	41 e0       	ldi	r20, 0x01	; 1
     254:	67 e0       	ldi	r22, 0x07	; 7
     256:	83 e0       	ldi	r24, 0x03	; 3
     258:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
	
	/*DC motor pins value*/
	DIO_SetPin_Value(M1_PORT, M1_DIR_PIN1, PIN_OFF);
     25c:	41 e0       	ldi	r20, 0x01	; 1
     25e:	66 e0       	ldi	r22, 0x06	; 6
     260:	83 e0       	ldi	r24, 0x03	; 3
     262:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
	DIO_SetPin_Value(M1_PORT, M1_DIR_PIN2, PIN_OFF);	
     266:	41 e0       	ldi	r20, 0x01	; 1
     268:	67 e0       	ldi	r22, 0x07	; 7
     26a:	83 e0       	ldi	r24, 0x03	; 3
     26c:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
	
	/*generate clock for the timer*/
	Timer0_Start();
     270:	0e 94 da 13 	call	0x27b4	; 0x27b4 <Timer0_Start>
     274:	08 95       	ret

00000276 <DC_Motor1_START>:
}

void DC_Motor1_START(Uint16 duty_cycle, DC_Motor_Dir dir)
{
     276:	cf 93       	push	r28
     278:	df 93       	push	r29
     27a:	ec 01       	movw	r28, r24
	switch(dir)
     27c:	66 23       	and	r22, r22
     27e:	19 f0       	breq	.+6      	; 0x286 <DC_Motor1_START+0x10>
     280:	61 30       	cpi	r22, 0x01	; 1
     282:	61 f0       	breq	.+24     	; 0x29c <DC_Motor1_START+0x26>
     284:	15 c0       	rjmp	.+42     	; 0x2b0 <DC_Motor1_START+0x3a>
	{
		case  Clock_Wise:
		DIO_SetPin_Value(M1_PORT, M1_DIR_PIN1, PIN_ON);
     286:	40 e0       	ldi	r20, 0x00	; 0
     288:	66 e0       	ldi	r22, 0x06	; 6
     28a:	83 e0       	ldi	r24, 0x03	; 3
     28c:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
		DIO_SetPin_Value(M1_PORT, M1_DIR_PIN2, PIN_OFF);
     290:	41 e0       	ldi	r20, 0x01	; 1
     292:	67 e0       	ldi	r22, 0x07	; 7
     294:	83 e0       	ldi	r24, 0x03	; 3
     296:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
		break;
     29a:	0a c0       	rjmp	.+20     	; 0x2b0 <DC_Motor1_START+0x3a>
		case Anti_Clock_Wise:
		DIO_SetPin_Value(M1_PORT, M1_DIR_PIN1, PIN_OFF);
     29c:	41 e0       	ldi	r20, 0x01	; 1
     29e:	66 e0       	ldi	r22, 0x06	; 6
     2a0:	83 e0       	ldi	r24, 0x03	; 3
     2a2:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
		DIO_SetPin_Value(M1_PORT, M1_DIR_PIN2, PIN_ON);
     2a6:	40 e0       	ldi	r20, 0x00	; 0
     2a8:	67 e0       	ldi	r22, 0x07	; 7
     2aa:	83 e0       	ldi	r24, 0x03	; 3
     2ac:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
		break;
		default:
		break;
	}	
	PWM0_Gen(duty_cycle);
     2b0:	be 01       	movw	r22, r28
     2b2:	80 e0       	ldi	r24, 0x00	; 0
     2b4:	90 e0       	ldi	r25, 0x00	; 0
     2b6:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <__floatunsisf>
     2ba:	0e 94 a0 13 	call	0x2740	; 0x2740 <PWM0_Gen>
}
     2be:	df 91       	pop	r29
     2c0:	cf 91       	pop	r28
     2c2:	08 95       	ret

000002c4 <DC_Motor1_STOP>:

void DC_Motor1_STOP(void)
{
	DIO_SetPin_Value(M1_PORT, M1_DIR_PIN1, PIN_OFF);
     2c4:	41 e0       	ldi	r20, 0x01	; 1
     2c6:	66 e0       	ldi	r22, 0x06	; 6
     2c8:	83 e0       	ldi	r24, 0x03	; 3
     2ca:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
	DIO_SetPin_Value(M1_PORT, M1_DIR_PIN2, PIN_OFF);	
     2ce:	41 e0       	ldi	r20, 0x01	; 1
     2d0:	67 e0       	ldi	r22, 0x07	; 7
     2d2:	83 e0       	ldi	r24, 0x03	; 3
     2d4:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
     2d8:	08 95       	ret

000002da <DIO_SetPin_Dir>:
     2da:	44 23       	and	r20, r20
     2dc:	19 f0       	breq	.+6      	; 0x2e4 <DIO_SetPin_Dir+0xa>
     2de:	41 30       	cpi	r20, 0x01	; 1
     2e0:	c9 f1       	breq	.+114    	; 0x354 <DIO_SetPin_Dir+0x7a>
     2e2:	08 95       	ret
     2e4:	81 30       	cpi	r24, 0x01	; 1
     2e6:	91 f0       	breq	.+36     	; 0x30c <DIO_SetPin_Dir+0x32>
     2e8:	28 f0       	brcs	.+10     	; 0x2f4 <DIO_SetPin_Dir+0x1a>
     2ea:	82 30       	cpi	r24, 0x02	; 2
     2ec:	d9 f0       	breq	.+54     	; 0x324 <DIO_SetPin_Dir+0x4a>
     2ee:	83 30       	cpi	r24, 0x03	; 3
     2f0:	29 f1       	breq	.+74     	; 0x33c <DIO_SetPin_Dir+0x62>
     2f2:	08 95       	ret
     2f4:	2a b3       	in	r18, 0x1a	; 26
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	02 c0       	rjmp	.+4      	; 0x300 <DIO_SetPin_Dir+0x26>
     2fc:	88 0f       	add	r24, r24
     2fe:	99 1f       	adc	r25, r25
     300:	6a 95       	dec	r22
     302:	e2 f7       	brpl	.-8      	; 0x2fc <DIO_SetPin_Dir+0x22>
     304:	80 95       	com	r24
     306:	82 23       	and	r24, r18
     308:	8a bb       	out	0x1a, r24	; 26
     30a:	08 95       	ret
     30c:	27 b3       	in	r18, 0x17	; 23
     30e:	81 e0       	ldi	r24, 0x01	; 1
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	02 c0       	rjmp	.+4      	; 0x318 <DIO_SetPin_Dir+0x3e>
     314:	88 0f       	add	r24, r24
     316:	99 1f       	adc	r25, r25
     318:	6a 95       	dec	r22
     31a:	e2 f7       	brpl	.-8      	; 0x314 <DIO_SetPin_Dir+0x3a>
     31c:	80 95       	com	r24
     31e:	82 23       	and	r24, r18
     320:	87 bb       	out	0x17, r24	; 23
     322:	08 95       	ret
     324:	24 b3       	in	r18, 0x14	; 20
     326:	81 e0       	ldi	r24, 0x01	; 1
     328:	90 e0       	ldi	r25, 0x00	; 0
     32a:	02 c0       	rjmp	.+4      	; 0x330 <DIO_SetPin_Dir+0x56>
     32c:	88 0f       	add	r24, r24
     32e:	99 1f       	adc	r25, r25
     330:	6a 95       	dec	r22
     332:	e2 f7       	brpl	.-8      	; 0x32c <DIO_SetPin_Dir+0x52>
     334:	80 95       	com	r24
     336:	82 23       	and	r24, r18
     338:	84 bb       	out	0x14, r24	; 20
     33a:	08 95       	ret
     33c:	21 b3       	in	r18, 0x11	; 17
     33e:	81 e0       	ldi	r24, 0x01	; 1
     340:	90 e0       	ldi	r25, 0x00	; 0
     342:	02 c0       	rjmp	.+4      	; 0x348 <DIO_SetPin_Dir+0x6e>
     344:	88 0f       	add	r24, r24
     346:	99 1f       	adc	r25, r25
     348:	6a 95       	dec	r22
     34a:	e2 f7       	brpl	.-8      	; 0x344 <DIO_SetPin_Dir+0x6a>
     34c:	80 95       	com	r24
     34e:	82 23       	and	r24, r18
     350:	81 bb       	out	0x11, r24	; 17
     352:	08 95       	ret
     354:	81 30       	cpi	r24, 0x01	; 1
     356:	89 f0       	breq	.+34     	; 0x37a <DIO_SetPin_Dir+0xa0>
     358:	28 f0       	brcs	.+10     	; 0x364 <DIO_SetPin_Dir+0x8a>
     35a:	82 30       	cpi	r24, 0x02	; 2
     35c:	c9 f0       	breq	.+50     	; 0x390 <DIO_SetPin_Dir+0xb6>
     35e:	83 30       	cpi	r24, 0x03	; 3
     360:	11 f1       	breq	.+68     	; 0x3a6 <DIO_SetPin_Dir+0xcc>
     362:	08 95       	ret
     364:	2a b3       	in	r18, 0x1a	; 26
     366:	81 e0       	ldi	r24, 0x01	; 1
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	02 c0       	rjmp	.+4      	; 0x370 <DIO_SetPin_Dir+0x96>
     36c:	88 0f       	add	r24, r24
     36e:	99 1f       	adc	r25, r25
     370:	6a 95       	dec	r22
     372:	e2 f7       	brpl	.-8      	; 0x36c <DIO_SetPin_Dir+0x92>
     374:	82 2b       	or	r24, r18
     376:	8a bb       	out	0x1a, r24	; 26
     378:	08 95       	ret
     37a:	27 b3       	in	r18, 0x17	; 23
     37c:	81 e0       	ldi	r24, 0x01	; 1
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	02 c0       	rjmp	.+4      	; 0x386 <DIO_SetPin_Dir+0xac>
     382:	88 0f       	add	r24, r24
     384:	99 1f       	adc	r25, r25
     386:	6a 95       	dec	r22
     388:	e2 f7       	brpl	.-8      	; 0x382 <DIO_SetPin_Dir+0xa8>
     38a:	82 2b       	or	r24, r18
     38c:	87 bb       	out	0x17, r24	; 23
     38e:	08 95       	ret
     390:	24 b3       	in	r18, 0x14	; 20
     392:	81 e0       	ldi	r24, 0x01	; 1
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	02 c0       	rjmp	.+4      	; 0x39c <DIO_SetPin_Dir+0xc2>
     398:	88 0f       	add	r24, r24
     39a:	99 1f       	adc	r25, r25
     39c:	6a 95       	dec	r22
     39e:	e2 f7       	brpl	.-8      	; 0x398 <DIO_SetPin_Dir+0xbe>
     3a0:	82 2b       	or	r24, r18
     3a2:	84 bb       	out	0x14, r24	; 20
     3a4:	08 95       	ret
     3a6:	21 b3       	in	r18, 0x11	; 17
     3a8:	81 e0       	ldi	r24, 0x01	; 1
     3aa:	90 e0       	ldi	r25, 0x00	; 0
     3ac:	02 c0       	rjmp	.+4      	; 0x3b2 <DIO_SetPin_Dir+0xd8>
     3ae:	88 0f       	add	r24, r24
     3b0:	99 1f       	adc	r25, r25
     3b2:	6a 95       	dec	r22
     3b4:	e2 f7       	brpl	.-8      	; 0x3ae <DIO_SetPin_Dir+0xd4>
     3b6:	82 2b       	or	r24, r18
     3b8:	81 bb       	out	0x11, r24	; 17
     3ba:	08 95       	ret

000003bc <DIO_SetPin_Value>:
     3bc:	44 23       	and	r20, r20
     3be:	d9 f1       	breq	.+118    	; 0x436 <__EEPROM_REGION_LENGTH__+0x36>
     3c0:	41 30       	cpi	r20, 0x01	; 1
     3c2:	09 f0       	breq	.+2      	; 0x3c6 <DIO_SetPin_Value+0xa>
     3c4:	6b c0       	rjmp	.+214    	; 0x49c <__EEPROM_REGION_LENGTH__+0x9c>
     3c6:	81 30       	cpi	r24, 0x01	; 1
     3c8:	91 f0       	breq	.+36     	; 0x3ee <DIO_SetPin_Value+0x32>
     3ca:	28 f0       	brcs	.+10     	; 0x3d6 <DIO_SetPin_Value+0x1a>
     3cc:	82 30       	cpi	r24, 0x02	; 2
     3ce:	d9 f0       	breq	.+54     	; 0x406 <__EEPROM_REGION_LENGTH__+0x6>
     3d0:	83 30       	cpi	r24, 0x03	; 3
     3d2:	29 f1       	breq	.+74     	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
     3d4:	08 95       	ret
     3d6:	2b b3       	in	r18, 0x1b	; 27
     3d8:	81 e0       	ldi	r24, 0x01	; 1
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	02 c0       	rjmp	.+4      	; 0x3e2 <DIO_SetPin_Value+0x26>
     3de:	88 0f       	add	r24, r24
     3e0:	99 1f       	adc	r25, r25
     3e2:	6a 95       	dec	r22
     3e4:	e2 f7       	brpl	.-8      	; 0x3de <DIO_SetPin_Value+0x22>
     3e6:	80 95       	com	r24
     3e8:	82 23       	and	r24, r18
     3ea:	8b bb       	out	0x1b, r24	; 27
     3ec:	08 95       	ret
     3ee:	28 b3       	in	r18, 0x18	; 24
     3f0:	81 e0       	ldi	r24, 0x01	; 1
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	02 c0       	rjmp	.+4      	; 0x3fa <DIO_SetPin_Value+0x3e>
     3f6:	88 0f       	add	r24, r24
     3f8:	99 1f       	adc	r25, r25
     3fa:	6a 95       	dec	r22
     3fc:	e2 f7       	brpl	.-8      	; 0x3f6 <DIO_SetPin_Value+0x3a>
     3fe:	80 95       	com	r24
     400:	82 23       	and	r24, r18
     402:	88 bb       	out	0x18, r24	; 24
     404:	08 95       	ret
     406:	25 b3       	in	r18, 0x15	; 21
     408:	81 e0       	ldi	r24, 0x01	; 1
     40a:	90 e0       	ldi	r25, 0x00	; 0
     40c:	02 c0       	rjmp	.+4      	; 0x412 <__EEPROM_REGION_LENGTH__+0x12>
     40e:	88 0f       	add	r24, r24
     410:	99 1f       	adc	r25, r25
     412:	6a 95       	dec	r22
     414:	e2 f7       	brpl	.-8      	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
     416:	80 95       	com	r24
     418:	82 23       	and	r24, r18
     41a:	85 bb       	out	0x15, r24	; 21
     41c:	08 95       	ret
     41e:	22 b3       	in	r18, 0x12	; 18
     420:	81 e0       	ldi	r24, 0x01	; 1
     422:	90 e0       	ldi	r25, 0x00	; 0
     424:	02 c0       	rjmp	.+4      	; 0x42a <__EEPROM_REGION_LENGTH__+0x2a>
     426:	88 0f       	add	r24, r24
     428:	99 1f       	adc	r25, r25
     42a:	6a 95       	dec	r22
     42c:	e2 f7       	brpl	.-8      	; 0x426 <__EEPROM_REGION_LENGTH__+0x26>
     42e:	80 95       	com	r24
     430:	82 23       	and	r24, r18
     432:	82 bb       	out	0x12, r24	; 18
     434:	08 95       	ret
     436:	81 30       	cpi	r24, 0x01	; 1
     438:	89 f0       	breq	.+34     	; 0x45c <__EEPROM_REGION_LENGTH__+0x5c>
     43a:	28 f0       	brcs	.+10     	; 0x446 <__EEPROM_REGION_LENGTH__+0x46>
     43c:	82 30       	cpi	r24, 0x02	; 2
     43e:	c9 f0       	breq	.+50     	; 0x472 <__EEPROM_REGION_LENGTH__+0x72>
     440:	83 30       	cpi	r24, 0x03	; 3
     442:	11 f1       	breq	.+68     	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
     444:	08 95       	ret
     446:	2b b3       	in	r18, 0x1b	; 27
     448:	81 e0       	ldi	r24, 0x01	; 1
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	02 c0       	rjmp	.+4      	; 0x452 <__EEPROM_REGION_LENGTH__+0x52>
     44e:	88 0f       	add	r24, r24
     450:	99 1f       	adc	r25, r25
     452:	6a 95       	dec	r22
     454:	e2 f7       	brpl	.-8      	; 0x44e <__EEPROM_REGION_LENGTH__+0x4e>
     456:	82 2b       	or	r24, r18
     458:	8b bb       	out	0x1b, r24	; 27
     45a:	08 95       	ret
     45c:	28 b3       	in	r18, 0x18	; 24
     45e:	81 e0       	ldi	r24, 0x01	; 1
     460:	90 e0       	ldi	r25, 0x00	; 0
     462:	02 c0       	rjmp	.+4      	; 0x468 <__EEPROM_REGION_LENGTH__+0x68>
     464:	88 0f       	add	r24, r24
     466:	99 1f       	adc	r25, r25
     468:	6a 95       	dec	r22
     46a:	e2 f7       	brpl	.-8      	; 0x464 <__EEPROM_REGION_LENGTH__+0x64>
     46c:	82 2b       	or	r24, r18
     46e:	88 bb       	out	0x18, r24	; 24
     470:	08 95       	ret
     472:	25 b3       	in	r18, 0x15	; 21
     474:	81 e0       	ldi	r24, 0x01	; 1
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	02 c0       	rjmp	.+4      	; 0x47e <__EEPROM_REGION_LENGTH__+0x7e>
     47a:	88 0f       	add	r24, r24
     47c:	99 1f       	adc	r25, r25
     47e:	6a 95       	dec	r22
     480:	e2 f7       	brpl	.-8      	; 0x47a <__EEPROM_REGION_LENGTH__+0x7a>
     482:	82 2b       	or	r24, r18
     484:	85 bb       	out	0x15, r24	; 21
     486:	08 95       	ret
     488:	22 b3       	in	r18, 0x12	; 18
     48a:	81 e0       	ldi	r24, 0x01	; 1
     48c:	90 e0       	ldi	r25, 0x00	; 0
     48e:	02 c0       	rjmp	.+4      	; 0x494 <__EEPROM_REGION_LENGTH__+0x94>
     490:	88 0f       	add	r24, r24
     492:	99 1f       	adc	r25, r25
     494:	6a 95       	dec	r22
     496:	e2 f7       	brpl	.-8      	; 0x490 <__EEPROM_REGION_LENGTH__+0x90>
     498:	82 2b       	or	r24, r18
     49a:	82 bb       	out	0x12, r24	; 18
     49c:	08 95       	ret

0000049e <DIO_GetPin_Value>:
     49e:	81 30       	cpi	r24, 0x01	; 1
     4a0:	79 f0       	breq	.+30     	; 0x4c0 <DIO_GetPin_Value+0x22>
     4a2:	28 f0       	brcs	.+10     	; 0x4ae <DIO_GetPin_Value+0x10>
     4a4:	82 30       	cpi	r24, 0x02	; 2
     4a6:	a9 f0       	breq	.+42     	; 0x4d2 <DIO_GetPin_Value+0x34>
     4a8:	83 30       	cpi	r24, 0x03	; 3
     4aa:	e1 f0       	breq	.+56     	; 0x4e4 <DIO_GetPin_Value+0x46>
     4ac:	24 c0       	rjmp	.+72     	; 0x4f6 <DIO_GetPin_Value+0x58>
     4ae:	89 b3       	in	r24, 0x19	; 25
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <DIO_GetPin_Value+0x1a>
     4b4:	95 95       	asr	r25
     4b6:	87 95       	ror	r24
     4b8:	6a 95       	dec	r22
     4ba:	e2 f7       	brpl	.-8      	; 0x4b4 <DIO_GetPin_Value+0x16>
     4bc:	81 70       	andi	r24, 0x01	; 1
     4be:	08 95       	ret
     4c0:	86 b3       	in	r24, 0x16	; 22
     4c2:	90 e0       	ldi	r25, 0x00	; 0
     4c4:	02 c0       	rjmp	.+4      	; 0x4ca <DIO_GetPin_Value+0x2c>
     4c6:	95 95       	asr	r25
     4c8:	87 95       	ror	r24
     4ca:	6a 95       	dec	r22
     4cc:	e2 f7       	brpl	.-8      	; 0x4c6 <DIO_GetPin_Value+0x28>
     4ce:	81 70       	andi	r24, 0x01	; 1
     4d0:	08 95       	ret
     4d2:	83 b3       	in	r24, 0x13	; 19
     4d4:	90 e0       	ldi	r25, 0x00	; 0
     4d6:	02 c0       	rjmp	.+4      	; 0x4dc <DIO_GetPin_Value+0x3e>
     4d8:	95 95       	asr	r25
     4da:	87 95       	ror	r24
     4dc:	6a 95       	dec	r22
     4de:	e2 f7       	brpl	.-8      	; 0x4d8 <DIO_GetPin_Value+0x3a>
     4e0:	81 70       	andi	r24, 0x01	; 1
     4e2:	08 95       	ret
     4e4:	80 b3       	in	r24, 0x10	; 16
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	02 c0       	rjmp	.+4      	; 0x4ee <DIO_GetPin_Value+0x50>
     4ea:	95 95       	asr	r25
     4ec:	87 95       	ror	r24
     4ee:	6a 95       	dec	r22
     4f0:	e2 f7       	brpl	.-8      	; 0x4ea <DIO_GetPin_Value+0x4c>
     4f2:	81 70       	andi	r24, 0x01	; 1
     4f4:	08 95       	ret
     4f6:	80 e0       	ldi	r24, 0x00	; 0
     4f8:	08 95       	ret

000004fa <DIO_TogglePin_Value>:
     4fa:	81 30       	cpi	r24, 0x01	; 1
     4fc:	89 f0       	breq	.+34     	; 0x520 <DIO_TogglePin_Value+0x26>
     4fe:	28 f0       	brcs	.+10     	; 0x50a <DIO_TogglePin_Value+0x10>
     500:	82 30       	cpi	r24, 0x02	; 2
     502:	c9 f0       	breq	.+50     	; 0x536 <DIO_TogglePin_Value+0x3c>
     504:	83 30       	cpi	r24, 0x03	; 3
     506:	11 f1       	breq	.+68     	; 0x54c <DIO_TogglePin_Value+0x52>
     508:	08 95       	ret
     50a:	2b b3       	in	r18, 0x1b	; 27
     50c:	81 e0       	ldi	r24, 0x01	; 1
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	02 c0       	rjmp	.+4      	; 0x516 <DIO_TogglePin_Value+0x1c>
     512:	88 0f       	add	r24, r24
     514:	99 1f       	adc	r25, r25
     516:	6a 95       	dec	r22
     518:	e2 f7       	brpl	.-8      	; 0x512 <DIO_TogglePin_Value+0x18>
     51a:	82 27       	eor	r24, r18
     51c:	8b bb       	out	0x1b, r24	; 27
     51e:	08 95       	ret
     520:	28 b3       	in	r18, 0x18	; 24
     522:	81 e0       	ldi	r24, 0x01	; 1
     524:	90 e0       	ldi	r25, 0x00	; 0
     526:	02 c0       	rjmp	.+4      	; 0x52c <DIO_TogglePin_Value+0x32>
     528:	88 0f       	add	r24, r24
     52a:	99 1f       	adc	r25, r25
     52c:	6a 95       	dec	r22
     52e:	e2 f7       	brpl	.-8      	; 0x528 <DIO_TogglePin_Value+0x2e>
     530:	82 27       	eor	r24, r18
     532:	88 bb       	out	0x18, r24	; 24
     534:	08 95       	ret
     536:	25 b3       	in	r18, 0x15	; 21
     538:	81 e0       	ldi	r24, 0x01	; 1
     53a:	90 e0       	ldi	r25, 0x00	; 0
     53c:	02 c0       	rjmp	.+4      	; 0x542 <DIO_TogglePin_Value+0x48>
     53e:	88 0f       	add	r24, r24
     540:	99 1f       	adc	r25, r25
     542:	6a 95       	dec	r22
     544:	e2 f7       	brpl	.-8      	; 0x53e <DIO_TogglePin_Value+0x44>
     546:	82 27       	eor	r24, r18
     548:	85 bb       	out	0x15, r24	; 21
     54a:	08 95       	ret
     54c:	22 b3       	in	r18, 0x12	; 18
     54e:	81 e0       	ldi	r24, 0x01	; 1
     550:	90 e0       	ldi	r25, 0x00	; 0
     552:	02 c0       	rjmp	.+4      	; 0x558 <DIO_TogglePin_Value+0x5e>
     554:	88 0f       	add	r24, r24
     556:	99 1f       	adc	r25, r25
     558:	6a 95       	dec	r22
     55a:	e2 f7       	brpl	.-8      	; 0x554 <DIO_TogglePin_Value+0x5a>
     55c:	82 27       	eor	r24, r18
     55e:	82 bb       	out	0x12, r24	; 18
     560:	08 95       	ret

00000562 <DIO_SetPin_Pullup>:
     562:	81 30       	cpi	r24, 0x01	; 1
     564:	89 f0       	breq	.+34     	; 0x588 <DIO_SetPin_Pullup+0x26>
     566:	28 f0       	brcs	.+10     	; 0x572 <DIO_SetPin_Pullup+0x10>
     568:	82 30       	cpi	r24, 0x02	; 2
     56a:	c9 f0       	breq	.+50     	; 0x59e <DIO_SetPin_Pullup+0x3c>
     56c:	83 30       	cpi	r24, 0x03	; 3
     56e:	11 f1       	breq	.+68     	; 0x5b4 <DIO_SetPin_Pullup+0x52>
     570:	08 95       	ret
     572:	2b b3       	in	r18, 0x1b	; 27
     574:	81 e0       	ldi	r24, 0x01	; 1
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	02 c0       	rjmp	.+4      	; 0x57e <DIO_SetPin_Pullup+0x1c>
     57a:	88 0f       	add	r24, r24
     57c:	99 1f       	adc	r25, r25
     57e:	6a 95       	dec	r22
     580:	e2 f7       	brpl	.-8      	; 0x57a <DIO_SetPin_Pullup+0x18>
     582:	82 2b       	or	r24, r18
     584:	8b bb       	out	0x1b, r24	; 27
     586:	08 95       	ret
     588:	28 b3       	in	r18, 0x18	; 24
     58a:	81 e0       	ldi	r24, 0x01	; 1
     58c:	90 e0       	ldi	r25, 0x00	; 0
     58e:	02 c0       	rjmp	.+4      	; 0x594 <DIO_SetPin_Pullup+0x32>
     590:	88 0f       	add	r24, r24
     592:	99 1f       	adc	r25, r25
     594:	6a 95       	dec	r22
     596:	e2 f7       	brpl	.-8      	; 0x590 <DIO_SetPin_Pullup+0x2e>
     598:	82 2b       	or	r24, r18
     59a:	88 bb       	out	0x18, r24	; 24
     59c:	08 95       	ret
     59e:	25 b3       	in	r18, 0x15	; 21
     5a0:	81 e0       	ldi	r24, 0x01	; 1
     5a2:	90 e0       	ldi	r25, 0x00	; 0
     5a4:	02 c0       	rjmp	.+4      	; 0x5aa <DIO_SetPin_Pullup+0x48>
     5a6:	88 0f       	add	r24, r24
     5a8:	99 1f       	adc	r25, r25
     5aa:	6a 95       	dec	r22
     5ac:	e2 f7       	brpl	.-8      	; 0x5a6 <DIO_SetPin_Pullup+0x44>
     5ae:	82 2b       	or	r24, r18
     5b0:	85 bb       	out	0x15, r24	; 21
     5b2:	08 95       	ret
     5b4:	22 b3       	in	r18, 0x12	; 18
     5b6:	81 e0       	ldi	r24, 0x01	; 1
     5b8:	90 e0       	ldi	r25, 0x00	; 0
     5ba:	02 c0       	rjmp	.+4      	; 0x5c0 <DIO_SetPin_Pullup+0x5e>
     5bc:	88 0f       	add	r24, r24
     5be:	99 1f       	adc	r25, r25
     5c0:	6a 95       	dec	r22
     5c2:	e2 f7       	brpl	.-8      	; 0x5bc <DIO_SetPin_Pullup+0x5a>
     5c4:	82 2b       	or	r24, r18
     5c6:	82 bb       	out	0x12, r24	; 18
     5c8:	08 95       	ret

000005ca <EEPROM_INIT>:
	//sending the data byte
	I2C_SendString(Data);
	//Sending stop condition
	I2C_SendStopCond();	
	_delay_ms(10);
}
     5ca:	0e 94 23 09 	call	0x1246	; 0x1246 <I2C_INIT>
     5ce:	08 95       	ret

000005d0 <EEPROM_WriteByte>:
     5d0:	1f 93       	push	r17
     5d2:	cf 93       	push	r28
     5d4:	df 93       	push	r29
     5d6:	16 2f       	mov	r17, r22
     5d8:	d4 2f       	mov	r29, r20
     5da:	88 30       	cpi	r24, 0x08	; 8
     5dc:	08 f0       	brcs	.+2      	; 0x5e0 <EEPROM_WriteByte+0x10>
     5de:	87 e0       	ldi	r24, 0x07	; 7
     5e0:	c8 2f       	mov	r28, r24
     5e2:	c0 65       	ori	r28, 0x50	; 80
     5e4:	0e 94 2b 09 	call	0x1256	; 0x1256 <I2C_SendStartCond>
     5e8:	8c 2f       	mov	r24, r28
     5ea:	0e 94 37 09 	call	0x126e	; 0x126e <I2C_SendSlaveAdd_WriteOP>
     5ee:	81 2f       	mov	r24, r17
     5f0:	0e 94 53 09 	call	0x12a6	; 0x12a6 <I2C_SendData>
     5f4:	8d 2f       	mov	r24, r29
     5f6:	0e 94 53 09 	call	0x12a6	; 0x12a6 <I2C_SendData>
     5fa:	0e 94 61 09 	call	0x12c2	; 0x12c2 <I2C_SendStopCond>
     5fe:	8f e3       	ldi	r24, 0x3F	; 63
     600:	9c e9       	ldi	r25, 0x9C	; 156
     602:	01 97       	sbiw	r24, 0x01	; 1
     604:	f1 f7       	brne	.-4      	; 0x602 <EEPROM_WriteByte+0x32>
     606:	00 c0       	rjmp	.+0      	; 0x608 <EEPROM_WriteByte+0x38>
     608:	00 00       	nop
     60a:	df 91       	pop	r29
     60c:	cf 91       	pop	r28
     60e:	1f 91       	pop	r17
     610:	08 95       	ret

00000612 <EEPROM_ReadByte>:


Uint8 EEPROM_ReadByte(Uint8 Device_Page, Uint8 Data_Add)
{
     612:	cf 93       	push	r28
     614:	df 93       	push	r29
     616:	d6 2f       	mov	r29, r22
	Uint8 Data = 0;
	if (Device_Page > 7)
     618:	88 30       	cpi	r24, 0x08	; 8
     61a:	08 f0       	brcs	.+2      	; 0x61e <EEPROM_ReadByte+0xc>
	Device_Page = 7;
     61c:	87 e0       	ldi	r24, 0x07	; 7
	//Device address calculation
	Uint8 Device_Add = 0X50 | Device_Page;
     61e:	c8 2f       	mov	r28, r24
     620:	c0 65       	ori	r28, 0x50	; 80
	//Sending start condition
	I2C_SendStartCond();
     622:	0e 94 2b 09 	call	0x1256	; 0x1256 <I2C_SendStartCond>
	//sending slave address with write operation
	I2C_SendSlaveAdd_WriteOP(Device_Add);
     626:	8c 2f       	mov	r24, r28
     628:	0e 94 37 09 	call	0x126e	; 0x126e <I2C_SendSlaveAdd_WriteOP>
	//sending data byte address
	I2C_SendData(Data_Add);
     62c:	8d 2f       	mov	r24, r29
     62e:	0e 94 53 09 	call	0x12a6	; 0x12a6 <I2C_SendData>
	
	//Sending repeated start condition
	I2C_SendRepStartCond();
     632:	0e 94 31 09 	call	0x1262	; 0x1262 <I2C_SendRepStartCond>
	//sending slave address with read operation
	I2C_SendSlaveAdd_ReadOP(Device_Add);	
     636:	8c 2f       	mov	r24, r28
     638:	0e 94 48 09 	call	0x1290	; 0x1290 <I2C_SendSlaveAdd_ReadOP>
	//Receiving the data byte
	Data = I2C_ReadData();
     63c:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <I2C_ReadData>
     640:	c8 2f       	mov	r28, r24
	//Sending stop condition
	I2C_SendStopCond();	
     642:	0e 94 61 09 	call	0x12c2	; 0x12c2 <I2C_SendStopCond>
	
	return Data;
}
     646:	8c 2f       	mov	r24, r28
     648:	df 91       	pop	r29
     64a:	cf 91       	pop	r28
     64c:	08 95       	ret

0000064e <INT0_Init>:
	
	/*INT0 Pin Direction*/
	DIO_SetPin_Dir(DIO_PORTB, PIN_2, PIN_IN);
	
	/*EXT INT0 Trigger*/
	MCUCR |= EXT_INT2_Trigger;
     64e:	8f b7       	in	r24, 0x3f	; 63
     650:	80 68       	ori	r24, 0x80	; 128
     652:	8f bf       	out	0x3f, r24	; 63
     654:	8b b7       	in	r24, 0x3b	; 59
     656:	80 64       	ori	r24, 0x40	; 64
     658:	8b bf       	out	0x3b, r24	; 59
     65a:	40 e0       	ldi	r20, 0x00	; 0
     65c:	62 e0       	ldi	r22, 0x02	; 2
     65e:	83 e0       	ldi	r24, 0x03	; 3
     660:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
     664:	85 b7       	in	r24, 0x35	; 53
     666:	83 60       	ori	r24, 0x03	; 3
     668:	85 bf       	out	0x35, r24	; 53
     66a:	08 95       	ret

0000066c <LCD_LogIN_system>:
   1- the user name and password found in the EEPROM it will make the user able to control the home
   2- the username is correct and the password is wrong so the LCD will Display Invalid and the number of trials left if it gets zero number of Trials
   alarm will start and the user must use reset button to get started 
   3-wrong user name case the LCD will display wrong username only and make the user to re enter the username and password again 
*/
{
     66c:	af 92       	push	r10
     66e:	bf 92       	push	r11
     670:	cf 92       	push	r12
     672:	df 92       	push	r13
     674:	ef 92       	push	r14
     676:	ff 92       	push	r15
     678:	0f 93       	push	r16
     67a:	1f 93       	push	r17
     67c:	cf 93       	push	r28
     67e:	df 93       	push	r29
     680:	cd b7       	in	r28, 0x3d	; 61
     682:	de b7       	in	r29, 0x3e	; 62
     684:	2c 97       	sbiw	r28, 0x0c	; 12
     686:	0f b6       	in	r0, 0x3f	; 63
     688:	f8 94       	cli
     68a:	de bf       	out	0x3e, r29	; 62
     68c:	0f be       	out	0x3f, r0	; 63
     68e:	cd bf       	out	0x3d, r28	; 61
/*Initialization*/
LCD_Init();
     690:	0e 94 27 0a 	call	0x144e	; 0x144e <LCD_Init>
Keypad_Init();
     694:	0e 94 67 09 	call	0x12ce	; 0x12ce <Keypad_Init>
EEPROM_INIT();
     698:	0e 94 e5 02 	call	0x5ca	; 0x5ca <EEPROM_INIT>
LED0_Init();
     69c:	0e 94 75 0b 	call	0x16ea	; 0x16ea <LED0_Init>
LED1_Init();
     6a0:	0e 94 91 0b 	call	0x1722	; 0x1722 <LED1_Init>
LED2_Init();
     6a4:	0e 94 ad 0b 	call	0x175a	; 0x175a <LED2_Init>
LED3_Init();
     6a8:	0e 94 c9 0b 	call	0x1792	; 0x1792 <LED3_Init>
LED4_Init();
     6ac:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <LED4_Init>
Timer0_Init();
     6b0:	0e 94 8a 13 	call	0x2714	; 0x2714 <Timer0_Init>
Servo_INIT();
     6b4:	0e 94 72 13 	call	0x26e4	; 0x26e4 <Servo_INIT>

/*Declaring variables*/
Uint8 Flag_Admin_Pass[4]={0};
     6b8:	19 82       	std	Y+1, r1	; 0x01
     6ba:	1a 82       	std	Y+2, r1	; 0x02
     6bc:	1b 82       	std	Y+3, r1	; 0x03
     6be:	1c 82       	std	Y+4, r1	; 0x04
Uint8 Flag_Guest_User[4]={0};
     6c0:	1d 82       	std	Y+5, r1	; 0x05
     6c2:	1e 82       	std	Y+6, r1	; 0x06
     6c4:	1f 82       	std	Y+7, r1	; 0x07
     6c6:	18 86       	std	Y+8, r1	; 0x08
Uint8 Flag_Guest_Pass[4]={0};
     6c8:	19 86       	std	Y+9, r1	; 0x09
     6ca:	1a 86       	std	Y+10, r1	; 0x0a
     6cc:	1b 86       	std	Y+11, r1	; 0x0b
     6ce:	1c 86       	std	Y+12, r1	; 0x0c
Uint8 check=0;

extern Uint8 Counter_User_Name;
extern Uint8 Counter_Password;

if((EEPROM_ReadByte(5,1)!=0XFF))
     6d0:	61 e0       	ldi	r22, 0x01	; 1
     6d2:	85 e0       	ldi	r24, 0x05	; 5
     6d4:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     6d8:	8f 3f       	cpi	r24, 0xFF	; 255
     6da:	41 f0       	breq	.+16     	; 0x6ec <LCD_LogIN_system+0x80>
{
	Counter_Password_Keypad= EEPROM_ReadByte(5,1);
     6dc:	61 e0       	ldi	r22, 0x01	; 1
     6de:	85 e0       	ldi	r24, 0x05	; 5
     6e0:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
	Counter_Password_Keypad++;
     6e4:	8f 5f       	subi	r24, 0xFF	; 255
     6e6:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <Counter_Password_Keypad>
     6ea:	02 c0       	rjmp	.+4      	; 0x6f0 <LCD_LogIN_system+0x84>
}
else
{
	Counter_Password_Keypad=0;
     6ec:	10 92 18 08 	sts	0x0818, r1	; 0x800818 <Counter_Password_Keypad>
}

if((EEPROM_ReadByte(5,0)!=0XFF))
     6f0:	60 e0       	ldi	r22, 0x00	; 0
     6f2:	85 e0       	ldi	r24, 0x05	; 5
     6f4:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     6f8:	8f 3f       	cpi	r24, 0xFF	; 255
     6fa:	71 f0       	breq	.+28     	; 0x718 <LCD_LogIN_system+0xac>
{
	Counter_User_Name_Keypad= EEPROM_ReadByte(5,0);
     6fc:	60 e0       	ldi	r22, 0x00	; 0
     6fe:	85 e0       	ldi	r24, 0x05	; 5
     700:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
	Counter_User_Name_Keypad++;
     704:	8f 5f       	subi	r24, 0xFF	; 255
     706:	80 93 19 08 	sts	0x0819, r24	; 0x800819 <Counter_User_Name_Keypad>
								
						}//End of switch case
						
						if (Deny_var==0)
						{
							 Flag=0;
     70a:	d1 2c       	mov	r13, r1
     70c:	f1 2c       	mov	r15, r1
     70e:	0f 2e       	mov	r0, r31
     710:	f3 e0       	ldi	r31, 0x03	; 3
     712:	ef 2e       	mov	r14, r31
     714:	f0 2d       	mov	r31, r0
     716:	51 c5       	rjmp	.+2722   	; 0x11ba <__stack+0x95b>
	Counter_User_Name_Keypad= EEPROM_ReadByte(5,0);
	Counter_User_Name_Keypad++;
}
else
{
	Counter_User_Name_Keypad=0;
     718:	10 92 19 08 	sts	0x0819, r1	; 0x800819 <Counter_User_Name_Keypad>
     71c:	f6 cf       	rjmp	.-20     	; 0x70a <LCD_LogIN_system+0x9e>
* it is a flag will be fired if there is an admin logged in in UART and refused to make an user to enter the system so it will begin again
*/
{
    Button_Flag=NULL_KEYPAD;
	Deny_var=1;
	LCD_Clear();
     71e:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
	LCD_Write_String("Welcome to");
     722:	8d e6       	ldi	r24, 0x6D	; 109
     724:	90 e0       	ldi	r25, 0x00	; 0
     726:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>

	LCD_Goto(1,0);
     72a:	60 e0       	ldi	r22, 0x00	; 0
     72c:	81 e0       	ldi	r24, 0x01	; 1
     72e:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
	LCD_Write_String("Home System");
     732:	88 e7       	ldi	r24, 0x78	; 120
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
     73a:	2f ef       	ldi	r18, 0xFF	; 255
     73c:	83 ed       	ldi	r24, 0xD3	; 211
     73e:	90 e3       	ldi	r25, 0x30	; 48
     740:	21 50       	subi	r18, 0x01	; 1
     742:	80 40       	sbci	r24, 0x00	; 0
     744:	90 40       	sbci	r25, 0x00	; 0
     746:	e1 f7       	brne	.-8      	; 0x740 <LCD_LogIN_system+0xd4>
     748:	00 c0       	rjmp	.+0      	; 0x74a <LCD_LogIN_system+0xde>
     74a:	00 00       	nop
	_delay_ms(1000);//Halt the system for the given time in (ms)
	LCD_Clear();
     74c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
	/*Setting Admin password if not set*/
	//read the state of the the passwords of the admin and guest if both are set or not set
	if(EEPROM_ReadByte(4,0)==255)
     750:	60 e0       	ldi	r22, 0x00	; 0
     752:	84 e0       	ldi	r24, 0x04	; 4
     754:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     758:	8f 3f       	cpi	r24, 0xFF	; 255
     75a:	09 f0       	breq	.+2      	; 0x75e <LCD_LogIN_system+0xf2>
     75c:	4d c0       	rjmp	.+154    	; 0x7f8 <LCD_LogIN_system+0x18c>
	{
		LCD_Write_String("Login For");
     75e:	84 e8       	ldi	r24, 0x84	; 132
     760:	90 e0       	ldi	r25, 0x00	; 0
     762:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
		LCD_Goto(1,0);
     766:	60 e0       	ldi	r22, 0x00	; 0
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
		LCD_Write_String("First time");
     76e:	8e e8       	ldi	r24, 0x8E	; 142
     770:	90 e0       	ldi	r25, 0x00	; 0
     772:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
     776:	2f ef       	ldi	r18, 0xFF	; 255
     778:	83 ed       	ldi	r24, 0xD3	; 211
     77a:	90 e3       	ldi	r25, 0x30	; 48
     77c:	21 50       	subi	r18, 0x01	; 1
     77e:	80 40       	sbci	r24, 0x00	; 0
     780:	90 40       	sbci	r25, 0x00	; 0
     782:	e1 f7       	brne	.-8      	; 0x77c <LCD_LogIN_system+0x110>
     784:	00 c0       	rjmp	.+0      	; 0x786 <LCD_LogIN_system+0x11a>
     786:	00 00       	nop
		_delay_ms(1000);
		LCD_Clear();
     788:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
		LCD_Write_String("Set Admin Pass");
     78c:	89 e9       	ldi	r24, 0x99	; 153
     78e:	90 e0       	ldi	r25, 0x00	; 0
     790:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
		LCD_Goto(1,0);
     794:	60 e0       	ldi	r22, 0x00	; 0
     796:	81 e0       	ldi	r24, 0x01	; 1
     798:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
		LCD_Write_String("Admin Pass:");
     79c:	88 ea       	ldi	r24, 0xA8	; 168
     79e:	90 e0       	ldi	r25, 0x00	; 0
     7a0:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
		/*Setting Admin pass*/
		Uint8 Password_Counter=0;
		Uint8 Pass[4]={0};
		for(Uint8 i=0; i<4;)
     7a4:	10 e0       	ldi	r17, 0x00	; 0
     7a6:	0f c0       	rjmp	.+30     	; 0x7c6 <LCD_LogIN_system+0x15a>
		{
			Button_Flag=Keypad_GetValue();
     7a8:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
			while(Button_Flag!=NULL_KEYPAD)
     7ac:	0a c0       	rjmp	.+20     	; 0x7c2 <LCD_LogIN_system+0x156>
			{
				Pass[i]=Button_Flag;
				EEPROM_WriteByte(4,i,Pass[i]);
     7ae:	48 2f       	mov	r20, r24
     7b0:	61 2f       	mov	r22, r17
     7b2:	84 e0       	ldi	r24, 0x04	; 4
     7b4:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
				i++;
     7b8:	1f 5f       	subi	r17, 0xFF	; 255
				LCD_Write_Char('*');
     7ba:	8a e2       	ldi	r24, 0x2A	; 42
     7bc:	0e 94 8c 0a 	call	0x1518	; 0x1518 <LCD_Write_Char>
				Button_Flag=NULL_KEYPAD;
     7c0:	80 e0       	ldi	r24, 0x00	; 0
		Uint8 Password_Counter=0;
		Uint8 Pass[4]={0};
		for(Uint8 i=0; i<4;)
		{
			Button_Flag=Keypad_GetValue();
			while(Button_Flag!=NULL_KEYPAD)
     7c2:	81 11       	cpse	r24, r1
     7c4:	f4 cf       	rjmp	.-24     	; 0x7ae <LCD_LogIN_system+0x142>
		LCD_Goto(1,0);
		LCD_Write_String("Admin Pass:");
		/*Setting Admin pass*/
		Uint8 Password_Counter=0;
		Uint8 Pass[4]={0};
		for(Uint8 i=0; i<4;)
     7c6:	14 30       	cpi	r17, 0x04	; 4
     7c8:	78 f3       	brcs	.-34     	; 0x7a8 <LCD_LogIN_system+0x13c>
				i++;
				LCD_Write_Char('*');
				Button_Flag=NULL_KEYPAD;
			}
		}
		LCD_Clear();
     7ca:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
		LCD_Write_String("Pass Saved");
     7ce:	84 eb       	ldi	r24, 0xB4	; 180
     7d0:	90 e0       	ldi	r25, 0x00	; 0
     7d2:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
		Login=1;
     7d6:	81 e0       	ldi	r24, 0x01	; 1
     7d8:	80 93 13 08 	sts	0x0813, r24	; 0x800813 <Login>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	89 e6       	ldi	r24, 0x69	; 105
     7e0:	98 e1       	ldi	r25, 0x18	; 24
     7e2:	21 50       	subi	r18, 0x01	; 1
     7e4:	80 40       	sbci	r24, 0x00	; 0
     7e6:	90 40       	sbci	r25, 0x00	; 0
     7e8:	e1 f7       	brne	.-8      	; 0x7e2 <LCD_LogIN_system+0x176>
     7ea:	00 c0       	rjmp	.+0      	; 0x7ec <LCD_LogIN_system+0x180>
     7ec:	00 00       	nop
		_delay_ms(500);
		LCD_Clear();
     7ee:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
/* Deny Var
* it is a flag will be fired if there is an admin logged in in UART and refused to make an user to enter the system so it will begin again
*/
{
    Button_Flag=NULL_KEYPAD;
	Deny_var=1;
     7f2:	dd 24       	eor	r13, r13
     7f4:	d3 94       	inc	r13
     7f6:	b9 c1       	rjmp	.+882    	; 0xb6a <__stack+0x30b>
	}

	else
	{
		
		if (Login==0)
     7f8:	80 91 13 08 	lds	r24, 0x0813	; 0x800813 <Login>
     7fc:	81 11       	cpse	r24, r1
     7fe:	b0 c1       	rjmp	.+864    	; 0xb60 <__stack+0x301>
		{
			
			LCD_Write_String("1. Admin");
     800:	8f eb       	ldi	r24, 0xBF	; 191
     802:	90 e0       	ldi	r25, 0x00	; 0
     804:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
			LCD_Goto(1,0);
     808:	60 e0       	ldi	r22, 0x00	; 0
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
			LCD_Write_String("2. Guest");
     810:	88 ec       	ldi	r24, 0xC8	; 200
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
while(!Deny_var) 
/* Deny Var
* it is a flag will be fired if there is an admin logged in in UART and refused to make an user to enter the system so it will begin again
*/
{
    Button_Flag=NULL_KEYPAD;
     818:	80 e0       	ldi	r24, 0x00	; 0
			
			LCD_Write_String("1. Admin");
			LCD_Goto(1,0);
			LCD_Write_String("2. Guest");
			
			while(Button_Flag==NULL_KEYPAD)
     81a:	03 c0       	rjmp	.+6      	; 0x822 <__DATA_REGION_LENGTH__+0x22>
			{
				Button_Flag =Keypad_GetValue();
     81c:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
				Flag =Button_Flag;
     820:	f8 2e       	mov	r15, r24
			
			LCD_Write_String("1. Admin");
			LCD_Goto(1,0);
			LCD_Write_String("2. Guest");
			
			while(Button_Flag==NULL_KEYPAD)
     822:	88 23       	and	r24, r24
     824:	d9 f3       	breq	.-10     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
			{
				Button_Flag =Keypad_GetValue();
				Flag =Button_Flag;
			}
			LCD_Clear();
     826:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
			
			
			
			
			switch(Flag)
     82a:	21 e3       	ldi	r18, 0x31	; 49
     82c:	f2 16       	cp	r15, r18
     82e:	29 f0       	breq	.+10     	; 0x83a <__DATA_REGION_LENGTH__+0x3a>
     830:	82 e3       	ldi	r24, 0x32	; 50
     832:	f8 16       	cp	r15, r24
     834:	09 f4       	brne	.+2      	; 0x838 <__DATA_REGION_LENGTH__+0x38>
     836:	7d c0       	rjmp	.+250    	; 0x932 <__stack+0xd3>
     838:	96 c1       	rjmp	.+812    	; 0xb66 <__stack+0x307>
			{
				case '1':
				{
					LCD_Clear();
     83a:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
					Uint8 counter_flag=3;
     83e:	03 e0       	ldi	r16, 0x03	; 3
					do{
						LCD_Write_String("admin pass:");
     840:	81 ed       	ldi	r24, 0xD1	; 209
     842:	90 e0       	ldi	r25, 0x00	; 0
     844:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
						
						for(Uint8 i=0;i<4;)
     848:	10 e0       	ldi	r17, 0x00	; 0
     84a:	11 c0       	rjmp	.+34     	; 0x86e <__stack+0xf>
						{
							Button_Flag=NULL_KEYPAD;
							Button_Flag=Keypad_GetValue();
     84c:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
							while(Button_Flag != NULL_KEYPAD)
     850:	0c c0       	rjmp	.+24     	; 0x86a <__stack+0xb>
							{
								Flag_Admin_Pass[i]=Button_Flag;
     852:	e1 e0       	ldi	r30, 0x01	; 1
     854:	f0 e0       	ldi	r31, 0x00	; 0
     856:	ec 0f       	add	r30, r28
     858:	fd 1f       	adc	r31, r29
     85a:	e1 0f       	add	r30, r17
     85c:	f1 1d       	adc	r31, r1
     85e:	80 83       	st	Z, r24
								LCD_Write_Char('*');
     860:	8a e2       	ldi	r24, 0x2A	; 42
     862:	0e 94 8c 0a 	call	0x1518	; 0x1518 <LCD_Write_Char>
								Button_Flag=NULL_KEYPAD;
								i++;
     866:	1f 5f       	subi	r17, 0xFF	; 255
							Button_Flag=Keypad_GetValue();
							while(Button_Flag != NULL_KEYPAD)
							{
								Flag_Admin_Pass[i]=Button_Flag;
								LCD_Write_Char('*');
								Button_Flag=NULL_KEYPAD;
     868:	80 e0       	ldi	r24, 0x00	; 0
						
						for(Uint8 i=0;i<4;)
						{
							Button_Flag=NULL_KEYPAD;
							Button_Flag=Keypad_GetValue();
							while(Button_Flag != NULL_KEYPAD)
     86a:	81 11       	cpse	r24, r1
     86c:	f2 cf       	rjmp	.-28     	; 0x852 <__DATA_REGION_LENGTH__+0x52>
					LCD_Clear();
					Uint8 counter_flag=3;
					do{
						LCD_Write_String("admin pass:");
						
						for(Uint8 i=0;i<4;)
     86e:	14 30       	cpi	r17, 0x04	; 4
     870:	68 f3       	brcs	.-38     	; 0x84c <__DATA_REGION_LENGTH__+0x4c>
								LCD_Write_Char('*');
								Button_Flag=NULL_KEYPAD;
								i++;
							}
						}
						LCD_Clear();
     872:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
						if (Flag_Admin_Pass[0]==EEPROM_ReadByte(4,0) && Flag_Admin_Pass[1]==EEPROM_ReadByte(4,1) && Flag_Admin_Pass[2]==EEPROM_ReadByte(4,2) && Flag_Admin_Pass[3]==EEPROM_ReadByte(4,3))
     876:	19 81       	ldd	r17, Y+1	; 0x01
     878:	60 e0       	ldi	r22, 0x00	; 0
     87a:	84 e0       	ldi	r24, 0x04	; 4
     87c:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     880:	18 13       	cpse	r17, r24
     882:	29 c0       	rjmp	.+82     	; 0x8d6 <__stack+0x77>
     884:	1a 81       	ldd	r17, Y+2	; 0x02
     886:	61 e0       	ldi	r22, 0x01	; 1
     888:	84 e0       	ldi	r24, 0x04	; 4
     88a:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     88e:	18 13       	cpse	r17, r24
     890:	22 c0       	rjmp	.+68     	; 0x8d6 <__stack+0x77>
     892:	1b 81       	ldd	r17, Y+3	; 0x03
     894:	62 e0       	ldi	r22, 0x02	; 2
     896:	84 e0       	ldi	r24, 0x04	; 4
     898:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     89c:	18 13       	cpse	r17, r24
     89e:	1b c0       	rjmp	.+54     	; 0x8d6 <__stack+0x77>
     8a0:	1c 81       	ldd	r17, Y+4	; 0x04
     8a2:	63 e0       	ldi	r22, 0x03	; 3
     8a4:	84 e0       	ldi	r24, 0x04	; 4
     8a6:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     8aa:	18 13       	cpse	r17, r24
     8ac:	14 c0       	rjmp	.+40     	; 0x8d6 <__stack+0x77>
						{
							LCD_Write_String("Logged In");
     8ae:	8d ed       	ldi	r24, 0xDD	; 221
     8b0:	90 e0       	ldi	r25, 0x00	; 0
     8b2:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
     8b6:	9f ef       	ldi	r25, 0xFF	; 255
     8b8:	23 ed       	ldi	r18, 0xD3	; 211
     8ba:	80 e3       	ldi	r24, 0x30	; 48
     8bc:	91 50       	subi	r25, 0x01	; 1
     8be:	20 40       	sbci	r18, 0x00	; 0
     8c0:	80 40       	sbci	r24, 0x00	; 0
     8c2:	e1 f7       	brne	.-8      	; 0x8bc <__stack+0x5d>
     8c4:	00 c0       	rjmp	.+0      	; 0x8c6 <__stack+0x67>
     8c6:	00 00       	nop
							_delay_ms(1000);
							Login=1;
     8c8:	81 e0       	ldi	r24, 0x01	; 1
     8ca:	80 93 13 08 	sts	0x0813, r24	; 0x800813 <Login>
							LCD_Clear();
     8ce:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
							counter_flag=0;
     8d2:	00 e0       	ldi	r16, 0x00	; 0
     8d4:	29 c0       	rjmp	.+82     	; 0x928 <__stack+0xc9>
						}
						else
						{
							counter_flag--;
     8d6:	01 50       	subi	r16, 0x01	; 1
							LCD_Clear();
     8d8:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
							LCD_Write_String("Invalid");
     8dc:	87 ee       	ldi	r24, 0xE7	; 231
     8de:	90 e0       	ldi	r25, 0x00	; 0
     8e0:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
							LCD_Goto(1,0);
     8e4:	60 e0       	ldi	r22, 0x00	; 0
     8e6:	81 e0       	ldi	r24, 0x01	; 1
     8e8:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
							LCD_Write_String("Trials");
     8ec:	8f ee       	ldi	r24, 0xEF	; 239
     8ee:	90 e0       	ldi	r25, 0x00	; 0
     8f0:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
							LCD_Goto(1,7);
     8f4:	67 e0       	ldi	r22, 0x07	; 7
     8f6:	81 e0       	ldi	r24, 0x01	; 1
     8f8:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
							LCD_Write_Integer(counter_flag);
     8fc:	60 2f       	mov	r22, r16
     8fe:	70 e0       	ldi	r23, 0x00	; 0
     900:	80 e0       	ldi	r24, 0x00	; 0
     902:	90 e0       	ldi	r25, 0x00	; 0
     904:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <LCD_Write_Integer>
     908:	9f ef       	ldi	r25, 0xFF	; 255
     90a:	2b e7       	ldi	r18, 0x7B	; 123
     90c:	82 e9       	ldi	r24, 0x92	; 146
     90e:	91 50       	subi	r25, 0x01	; 1
     910:	20 40       	sbci	r18, 0x00	; 0
     912:	80 40       	sbci	r24, 0x00	; 0
     914:	e1 f7       	brne	.-8      	; 0x90e <__stack+0xaf>
     916:	00 c0       	rjmp	.+0      	; 0x918 <__stack+0xb9>
     918:	00 00       	nop
							_delay_ms(3000);
							LCD_Clear();
     91a:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
							
							if (counter_flag==0)
     91e:	01 11       	cpse	r16, r1
     920:	03 c0       	rjmp	.+6      	; 0x928 <__stack+0xc9>
							{
								while(1)
								{
									ALARM_ON();
     922:	0e 94 b7 00 	call	0x16e	; 0x16e <ALARM_ON>
     926:	fd cf       	rjmp	.-6      	; 0x922 <__stack+0xc3>
								}
							}
						}
					}while(counter_flag);
     928:	01 11       	cpse	r16, r1
     92a:	8a cf       	rjmp	.-236    	; 0x840 <__DATA_REGION_LENGTH__+0x40>
/* Deny Var
* it is a flag will be fired if there is an admin logged in in UART and refused to make an user to enter the system so it will begin again
*/
{
    Button_Flag=NULL_KEYPAD;
	Deny_var=1;
     92c:	dd 24       	eor	r13, r13
     92e:	d3 94       	inc	r13
     930:	1c c1       	rjmp	.+568    	; 0xb6a <__stack+0x30b>
				
				case '2':
				{
					
					// Counter_User_Name_Keypad=8;
					if (Admin_login==1)
     932:	80 91 12 08 	lds	r24, 0x0812	; 0x800812 <Admin_login>
     936:	81 30       	cpi	r24, 0x01	; 1
     938:	09 f0       	breq	.+2      	; 0x93c <__stack+0xdd>
     93a:	44 c0       	rjmp	.+136    	; 0x9c4 <__stack+0x165>
					{
						LCD_Init();
     93c:	0e 94 27 0a 	call	0x144e	; 0x144e <LCD_Init>
						LCD_Write_String("wait for admin");
     940:	86 ef       	ldi	r24, 0xF6	; 246
     942:	90 e0       	ldi	r25, 0x00	; 0
     944:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
						LCD_Goto(1,0);
     948:	60 e0       	ldi	r22, 0x00	; 0
     94a:	81 e0       	ldi	r24, 0x01	; 1
     94c:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
						LCD_Write_String("premision");
     950:	85 e0       	ldi	r24, 0x05	; 5
     952:	91 e0       	ldi	r25, 0x01	; 1
     954:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
						UART_TX_Str("\r\n");
     958:	8e eb       	ldi	r24, 0xBE	; 190
     95a:	97 e0       	ldi	r25, 0x07	; 7
     95c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str("there is user want to access home system\r\n");
     960:	8f e0       	ldi	r24, 0x0F	; 15
     962:	91 e0       	ldi	r25, 0x01	; 1
     964:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str("do you want to let him\r\n");
     968:	8a e3       	ldi	r24, 0x3A	; 58
     96a:	91 e0       	ldi	r25, 0x01	; 1
     96c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str("1- Yes\r\n");
     970:	83 e5       	ldi	r24, 0x53	; 83
     972:	91 e0       	ldi	r25, 0x01	; 1
     974:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str("2- No\r\n");
     978:	8c e5       	ldi	r24, 0x5C	; 92
     97a:	91 e0       	ldi	r25, 0x01	; 1
     97c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						while (!Get_Bit(UCSRA,7));
     980:	5f 9b       	sbis	0x0b, 7	; 11
     982:	fe cf       	rjmp	.-4      	; 0x980 <__stack+0x121>
						Uint8 Var_check=UDR;
     984:	8c b1       	in	r24, 0x0c	; 12
						switch (Var_check)													
     986:	81 33       	cpi	r24, 0x31	; 49
     988:	19 f0       	breq	.+6      	; 0x990 <__stack+0x131>
     98a:	82 33       	cpi	r24, 0x32	; 50
     98c:	71 f0       	breq	.+28     	; 0x9aa <__stack+0x14b>
     98e:	14 c0       	rjmp	.+40     	; 0x9b8 <__stack+0x159>
						{
							case'1':
							{
								LCD_Clear();
     990:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
								LCD_Write_String("Admin Approved");
     994:	84 e6       	ldi	r24, 0x64	; 100
     996:	91 e0       	ldi	r25, 0x01	; 1
     998:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
								UART_TX_Str("the user Enter the system\r\n");
     99c:	83 e7       	ldi	r24, 0x73	; 115
     99e:	91 e0       	ldi	r25, 0x01	; 1
     9a0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
/* Deny Var
* it is a flag will be fired if there is an admin logged in in UART and refused to make an user to enter the system so it will begin again
*/
{
    Button_Flag=NULL_KEYPAD;
	Deny_var=1;
     9a4:	dd 24       	eor	r13, r13
     9a6:	d3 94       	inc	r13
							case'1':
							{
								LCD_Clear();
								LCD_Write_String("Admin Approved");
								UART_TX_Str("the user Enter the system\r\n");
								break;
     9a8:	09 c0       	rjmp	.+18     	; 0x9bc <__stack+0x15d>
							}//End of case 1
							case '2':
							{
								LCD_Clear();
     9aa:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
								LCD_Write_String("Admin Denied");
     9ae:	8f e8       	ldi	r24, 0x8F	; 143
     9b0:	91 e0       	ldi	r25, 0x01	; 1
     9b2:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
								Deny_var=0;
								
								break;
     9b6:	02 c0       	rjmp	.+4      	; 0x9bc <__stack+0x15d>
/* Deny Var
* it is a flag will be fired if there is an admin logged in in UART and refused to make an user to enter the system so it will begin again
*/
{
    Button_Flag=NULL_KEYPAD;
	Deny_var=1;
     9b8:	dd 24       	eor	r13, r13
     9ba:	d3 94       	inc	r13
								
							}//End of case 2
								
						}//End of switch case
						
						if (Deny_var==0)
     9bc:	dd 20       	and	r13, r13
     9be:	09 f4       	brne	.+2      	; 0x9c2 <__stack+0x163>
     9c0:	fb c3       	rjmp	.+2038   	; 0x11b8 <__stack+0x959>
     9c2:	02 c0       	rjmp	.+4      	; 0x9c8 <__stack+0x169>
/* Deny Var
* it is a flag will be fired if there is an admin logged in in UART and refused to make an user to enter the system so it will begin again
*/
{
    Button_Flag=NULL_KEYPAD;
	Deny_var=1;
     9c4:	dd 24       	eor	r13, r13
     9c6:	d3 94       	inc	r13
							continue;
						}
					}//End of if condition
					
				
					LCD_Clear();
     9c8:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
					LCD_Write_String("Username:");
     9cc:	8c e9       	ldi	r24, 0x9C	; 156
     9ce:	91 e0       	ldi	r25, 0x01	; 1
     9d0:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
					do{
						LCD_Clear();
     9d4:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
						LCD_Write_String("Username:");
     9d8:	8c e9       	ldi	r24, 0x9C	; 156
     9da:	91 e0       	ldi	r25, 0x01	; 1
     9dc:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
						for(Uint8 i=0;i<4;)
     9e0:	10 e0       	ldi	r17, 0x00	; 0
     9e2:	10 c0       	rjmp	.+32     	; 0xa04 <__stack+0x1a5>
						{
							Button_Flag=NULL_KEYPAD;
							Button_Flag=Keypad_GetValue();
     9e4:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
							while(Button_Flag != NULL_KEYPAD)
     9e8:	0b c0       	rjmp	.+22     	; 0xa00 <__stack+0x1a1>
							{
								Flag_Guest_User[i]=Button_Flag;
     9ea:	e5 e0       	ldi	r30, 0x05	; 5
     9ec:	f0 e0       	ldi	r31, 0x00	; 0
     9ee:	ec 0f       	add	r30, r28
     9f0:	fd 1f       	adc	r31, r29
     9f2:	e1 0f       	add	r30, r17
     9f4:	f1 1d       	adc	r31, r1
     9f6:	80 83       	st	Z, r24
								LCD_Write_Char(Flag_Guest_User[i]);
     9f8:	0e 94 8c 0a 	call	0x1518	; 0x1518 <LCD_Write_Char>
								Button_Flag=NULL_KEYPAD;
								i++;
     9fc:	1f 5f       	subi	r17, 0xFF	; 255
							Button_Flag=Keypad_GetValue();
							while(Button_Flag != NULL_KEYPAD)
							{
								Flag_Guest_User[i]=Button_Flag;
								LCD_Write_Char(Flag_Guest_User[i]);
								Button_Flag=NULL_KEYPAD;
     9fe:	80 e0       	ldi	r24, 0x00	; 0
						LCD_Write_String("Username:");
						for(Uint8 i=0;i<4;)
						{
							Button_Flag=NULL_KEYPAD;
							Button_Flag=Keypad_GetValue();
							while(Button_Flag != NULL_KEYPAD)
     a00:	81 11       	cpse	r24, r1
     a02:	f3 cf       	rjmp	.-26     	; 0x9ea <__stack+0x18b>
					LCD_Clear();
					LCD_Write_String("Username:");
					do{
						LCD_Clear();
						LCD_Write_String("Username:");
						for(Uint8 i=0;i<4;)
     a04:	14 30       	cpi	r17, 0x04	; 4
     a06:	70 f3       	brcs	.-36     	; 0x9e4 <__stack+0x185>
								LCD_Write_Char(Flag_Guest_User[i]);
								Button_Flag=NULL_KEYPAD;
								i++;
							}
						}
						LCD_Goto(1,0);
     a08:	60 e0       	ldi	r22, 0x00	; 0
     a0a:	81 e0       	ldi	r24, 0x01	; 1
     a0c:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
						LCD_Write_String("Guest pass:");
     a10:	86 ea       	ldi	r24, 0xA6	; 166
     a12:	91 e0       	ldi	r25, 0x01	; 1
     a14:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
						for(Uint8 i=0;i<4;)
     a18:	10 e0       	ldi	r17, 0x00	; 0
     a1a:	11 c0       	rjmp	.+34     	; 0xa3e <__stack+0x1df>
						{
							Button_Flag=NULL_KEYPAD;
							Button_Flag=Keypad_GetValue();
     a1c:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
							while(Button_Flag != NULL_KEYPAD)
     a20:	0c c0       	rjmp	.+24     	; 0xa3a <__stack+0x1db>
							{
								Flag_Guest_Pass[i]=Button_Flag;
     a22:	e9 e0       	ldi	r30, 0x09	; 9
     a24:	f0 e0       	ldi	r31, 0x00	; 0
     a26:	ec 0f       	add	r30, r28
     a28:	fd 1f       	adc	r31, r29
     a2a:	e1 0f       	add	r30, r17
     a2c:	f1 1d       	adc	r31, r1
     a2e:	80 83       	st	Z, r24
								LCD_Write_Char('*');
     a30:	8a e2       	ldi	r24, 0x2A	; 42
     a32:	0e 94 8c 0a 	call	0x1518	; 0x1518 <LCD_Write_Char>
								Button_Flag=NULL_KEYPAD;
								i++;
     a36:	1f 5f       	subi	r17, 0xFF	; 255
							Button_Flag=Keypad_GetValue();
							while(Button_Flag != NULL_KEYPAD)
							{
								Flag_Guest_Pass[i]=Button_Flag;
								LCD_Write_Char('*');
								Button_Flag=NULL_KEYPAD;
     a38:	80 e0       	ldi	r24, 0x00	; 0
						LCD_Write_String("Guest pass:");
						for(Uint8 i=0;i<4;)
						{
							Button_Flag=NULL_KEYPAD;
							Button_Flag=Keypad_GetValue();
							while(Button_Flag != NULL_KEYPAD)
     a3a:	81 11       	cpse	r24, r1
     a3c:	f2 cf       	rjmp	.-28     	; 0xa22 <__stack+0x1c3>
								i++;
							}
						}
						LCD_Goto(1,0);
						LCD_Write_String("Guest pass:");
						for(Uint8 i=0;i<4;)
     a3e:	14 30       	cpi	r17, 0x04	; 4
     a40:	68 f3       	brcs	.-38     	; 0xa1c <__stack+0x1bd>
								LCD_Write_Char('*');
								Button_Flag=NULL_KEYPAD;
								i++;
							}
						}
						LCD_Clear();
     a42:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
						
						/*Check For Username & Password*/
						
						Uint8 Flag_alarm=0;
						for (Uint8 y=0;y<Counter_User_Name_Keypad;y++)
     a46:	10 e0       	ldi	r17, 0x00	; 0
     a48:	83 c0       	rjmp	.+262    	; 0xb50 <__stack+0x2f1>
						{
							if (Flag_Guest_User[0]==EEPROM_ReadByte(Page_User_Name_KeyPad,y) && Flag_Guest_User[1]==EEPROM_ReadByte(Page_User_Name_KeyPad,y+1) && Flag_Guest_User[2]==EEPROM_ReadByte(Page_User_Name_KeyPad,y+2) && Flag_Guest_User[3]==EEPROM_ReadByte(Page_User_Name_KeyPad,y+3))
     a4a:	0d 81       	ldd	r16, Y+5	; 0x05
     a4c:	61 2f       	mov	r22, r17
     a4e:	82 e0       	ldi	r24, 0x02	; 2
     a50:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     a54:	08 13       	cpse	r16, r24
     a56:	7b c0       	rjmp	.+246    	; 0xb4e <__stack+0x2ef>
     a58:	ce 80       	ldd	r12, Y+6	; 0x06
     a5a:	01 e0       	ldi	r16, 0x01	; 1
     a5c:	01 0f       	add	r16, r17
     a5e:	60 2f       	mov	r22, r16
     a60:	82 e0       	ldi	r24, 0x02	; 2
     a62:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     a66:	c8 12       	cpse	r12, r24
     a68:	72 c0       	rjmp	.+228    	; 0xb4e <__stack+0x2ef>
     a6a:	cf 80       	ldd	r12, Y+7	; 0x07
     a6c:	68 94       	set
     a6e:	bb 24       	eor	r11, r11
     a70:	b1 f8       	bld	r11, 1
     a72:	b1 0e       	add	r11, r17
     a74:	6b 2d       	mov	r22, r11
     a76:	82 e0       	ldi	r24, 0x02	; 2
     a78:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     a7c:	c8 12       	cpse	r12, r24
     a7e:	67 c0       	rjmp	.+206    	; 0xb4e <__stack+0x2ef>
     a80:	a8 84       	ldd	r10, Y+8	; 0x08
     a82:	0f 2e       	mov	r0, r31
     a84:	f3 e0       	ldi	r31, 0x03	; 3
     a86:	cf 2e       	mov	r12, r31
     a88:	f0 2d       	mov	r31, r0
     a8a:	c1 0e       	add	r12, r17
     a8c:	6c 2d       	mov	r22, r12
     a8e:	82 e0       	ldi	r24, 0x02	; 2
     a90:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     a94:	a8 12       	cpse	r10, r24
     a96:	5b c0       	rjmp	.+182    	; 0xb4e <__stack+0x2ef>

							{
								if (Flag_Guest_Pass[0]==EEPROM_ReadByte(Page_Password_KeyPad,y) && Flag_Guest_Pass[1]==EEPROM_ReadByte(Page_Password_KeyPad,y+1) && Flag_Guest_Pass[2]==EEPROM_ReadByte(Page_Password_KeyPad,y+2) && Flag_Guest_Pass[3]==EEPROM_ReadByte(Page_Password_KeyPad,y+3))
     a98:	a9 84       	ldd	r10, Y+9	; 0x09
     a9a:	61 2f       	mov	r22, r17
     a9c:	83 e0       	ldi	r24, 0x03	; 3
     a9e:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     aa2:	a8 12       	cpse	r10, r24
     aa4:	29 c0       	rjmp	.+82     	; 0xaf8 <__stack+0x299>
     aa6:	1a 85       	ldd	r17, Y+10	; 0x0a
     aa8:	60 2f       	mov	r22, r16
     aaa:	83 e0       	ldi	r24, 0x03	; 3
     aac:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     ab0:	18 13       	cpse	r17, r24
     ab2:	22 c0       	rjmp	.+68     	; 0xaf8 <__stack+0x299>
     ab4:	1b 85       	ldd	r17, Y+11	; 0x0b
     ab6:	6b 2d       	mov	r22, r11
     ab8:	83 e0       	ldi	r24, 0x03	; 3
     aba:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     abe:	18 13       	cpse	r17, r24
     ac0:	1b c0       	rjmp	.+54     	; 0xaf8 <__stack+0x299>
     ac2:	1c 85       	ldd	r17, Y+12	; 0x0c
     ac4:	6c 2d       	mov	r22, r12
     ac6:	83 e0       	ldi	r24, 0x03	; 3
     ac8:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
     acc:	18 13       	cpse	r17, r24
     ace:	14 c0       	rjmp	.+40     	; 0xaf8 <__stack+0x299>
								{
									
									LCD_Write_String("Logged In");
     ad0:	8d ed       	ldi	r24, 0xDD	; 221
     ad2:	90 e0       	ldi	r25, 0x00	; 0
     ad4:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
									Login=1;
     ad8:	81 e0       	ldi	r24, 0x01	; 1
     ada:	80 93 13 08 	sts	0x0813, r24	; 0x800813 <Login>
     ade:	9f ef       	ldi	r25, 0xFF	; 255
     ae0:	23 ed       	ldi	r18, 0xD3	; 211
     ae2:	80 e3       	ldi	r24, 0x30	; 48
     ae4:	91 50       	subi	r25, 0x01	; 1
     ae6:	20 40       	sbci	r18, 0x00	; 0
     ae8:	80 40       	sbci	r24, 0x00	; 0
     aea:	e1 f7       	brne	.-8      	; 0xae4 <__stack+0x285>
     aec:	00 c0       	rjmp	.+0      	; 0xaee <__stack+0x28f>
     aee:	00 00       	nop
									_delay_ms(1000);
									LCD_Clear();
     af0:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
									counter_flag_2=0;
     af4:	e1 2c       	mov	r14, r1
									break;
     af6:	31 c0       	rjmp	.+98     	; 0xb5a <__stack+0x2fb>
								}
								else
								{
									Flag_alarm=1;
									counter_flag_2--;
     af8:	ea 94       	dec	r14
									LCD_Write_String("Invalid");
     afa:	87 ee       	ldi	r24, 0xE7	; 231
     afc:	90 e0       	ldi	r25, 0x00	; 0
     afe:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
									
									LCD_Goto(1,0);
     b02:	60 e0       	ldi	r22, 0x00	; 0
     b04:	81 e0       	ldi	r24, 0x01	; 1
     b06:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
									LCD_Write_String("Trials");
     b0a:	8f ee       	ldi	r24, 0xEF	; 239
     b0c:	90 e0       	ldi	r25, 0x00	; 0
     b0e:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
									
									LCD_Goto(1,7);
     b12:	67 e0       	ldi	r22, 0x07	; 7
     b14:	81 e0       	ldi	r24, 0x01	; 1
     b16:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
									LCD_Write_Integer(counter_flag_2);
     b1a:	6e 2d       	mov	r22, r14
     b1c:	70 e0       	ldi	r23, 0x00	; 0
     b1e:	80 e0       	ldi	r24, 0x00	; 0
     b20:	90 e0       	ldi	r25, 0x00	; 0
     b22:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <LCD_Write_Integer>
     b26:	9f ef       	ldi	r25, 0xFF	; 255
     b28:	23 ed       	ldi	r18, 0xD3	; 211
     b2a:	80 e3       	ldi	r24, 0x30	; 48
     b2c:	91 50       	subi	r25, 0x01	; 1
     b2e:	20 40       	sbci	r18, 0x00	; 0
     b30:	80 40       	sbci	r24, 0x00	; 0
     b32:	e1 f7       	brne	.-8      	; 0xb2c <__stack+0x2cd>
     b34:	00 c0       	rjmp	.+0      	; 0xb36 <__stack+0x2d7>
     b36:	00 00       	nop
									_delay_ms(1000);
									
									if (counter_flag_2==0)
     b38:	e1 10       	cpse	r14, r1
     b3a:	0f c0       	rjmp	.+30     	; 0xb5a <__stack+0x2fb>
									{
										LCD_Clear();
     b3c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
										LCD_Write_String("use the reset button");
     b40:	82 eb       	ldi	r24, 0xB2	; 178
     b42:	91 e0       	ldi	r25, 0x01	; 1
     b44:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
										while(1)
										{
											ALARM_ON();
     b48:	0e 94 b7 00 	call	0x16e	; 0x16e <ALARM_ON>
     b4c:	fd cf       	rjmp	.-6      	; 0xb48 <__stack+0x2e9>
						LCD_Clear();
						
						/*Check For Username & Password*/
						
						Uint8 Flag_alarm=0;
						for (Uint8 y=0;y<Counter_User_Name_Keypad;y++)
     b4e:	1f 5f       	subi	r17, 0xFF	; 255
     b50:	80 91 19 08 	lds	r24, 0x0819	; 0x800819 <Counter_User_Name_Keypad>
     b54:	18 17       	cp	r17, r24
     b56:	08 f4       	brcc	.+2      	; 0xb5a <__stack+0x2fb>
     b58:	78 cf       	rjmp	.-272    	; 0xa4a <__stack+0x1eb>
									}
									break;
								}
							}
						}
					}while (counter_flag_2);
     b5a:	e1 10       	cpse	r14, r1
     b5c:	3b cf       	rjmp	.-394    	; 0x9d4 <__stack+0x175>
     b5e:	05 c0       	rjmp	.+10     	; 0xb6a <__stack+0x30b>
/* Deny Var
* it is a flag will be fired if there is an admin logged in in UART and refused to make an user to enter the system so it will begin again
*/
{
    Button_Flag=NULL_KEYPAD;
	Deny_var=1;
     b60:	dd 24       	eor	r13, r13
     b62:	d3 94       	inc	r13
     b64:	02 c0       	rjmp	.+4      	; 0xb6a <__stack+0x30b>
     b66:	dd 24       	eor	r13, r13
     b68:	d3 94       	inc	r13
			}//End Of switch
		}//End Of If condition
	
}//End else Condition

		if (Login==1)
     b6a:	80 91 13 08 	lds	r24, 0x0813	; 0x800813 <Login>
     b6e:	81 30       	cpi	r24, 0x01	; 1
     b70:	09 f0       	breq	.+2      	; 0xb74 <__stack+0x315>
     b72:	23 c3       	rjmp	.+1606   	; 0x11ba <__stack+0x95b>
		{
			
			
				LCD_Clear();
     b74:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
				LCD_Write_String("1.Control System");
     b78:	87 ec       	ldi	r24, 0xC7	; 199
     b7a:	91 e0       	ldi	r25, 0x01	; 1
     b7c:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
				LCD_Goto(1,0);
     b80:	60 e0       	ldi	r22, 0x00	; 0
     b82:	81 e0       	ldi	r24, 0x01	; 1
     b84:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
				LCD_Write_String("2.Check system");
     b88:	88 ed       	ldi	r24, 0xD8	; 216
     b8a:	91 e0       	ldi	r25, 0x01	; 1
     b8c:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
				Button_Flag=NULL_KEYPAD;
     b90:	80 e0       	ldi	r24, 0x00	; 0
				while(Button_Flag==NULL_KEYPAD)
     b92:	03 c0       	rjmp	.+6      	; 0xb9a <__stack+0x33b>
				{
					Button_Flag=Keypad_GetValue();
     b94:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
					Flag = Button_Flag;
     b98:	f8 2e       	mov	r15, r24
				LCD_Clear();
				LCD_Write_String("1.Control System");
				LCD_Goto(1,0);
				LCD_Write_String("2.Check system");
				Button_Flag=NULL_KEYPAD;
				while(Button_Flag==NULL_KEYPAD)
     b9a:	88 23       	and	r24, r24
     b9c:	d9 f3       	breq	.-10     	; 0xb94 <__stack+0x335>
				{
					Button_Flag=Keypad_GetValue();
					Flag = Button_Flag;
				}
				if (Flag=='1'|| Flag=='2')
     b9e:	8f ec       	ldi	r24, 0xCF	; 207
     ba0:	8f 0d       	add	r24, r15
     ba2:	82 30       	cpi	r24, 0x02	; 2
     ba4:	08 f0       	brcs	.+2      	; 0xba8 <__stack+0x349>
     ba6:	09 c3       	rjmp	.+1554   	; 0x11ba <__stack+0x95b>
				{
					switch(Flag)
     ba8:	91 e3       	ldi	r25, 0x31	; 49
     baa:	f9 16       	cp	r15, r25
     bac:	09 f4       	brne	.+2      	; 0xbb0 <__stack+0x351>
     bae:	ff c1       	rjmp	.+1022   	; 0xfae <__stack+0x74f>
     bb0:	22 e3       	ldi	r18, 0x32	; 50
     bb2:	f2 16       	cp	r15, r18
     bb4:	09 f4       	brne	.+2      	; 0xbb8 <__stack+0x359>
     bb6:	fb c2       	rjmp	.+1526   	; 0x11ae <__stack+0x94f>
     bb8:	00 c3       	rjmp	.+1536   	; 0x11ba <__stack+0x95b>
						{
							Uint8 check=0;
							while (!check)
							{
								check=1;
								LCD_Clear();
     bba:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
								LCD_Write_String("1.Room1");
     bbe:	87 ee       	ldi	r24, 0xE7	; 231
     bc0:	91 e0       	ldi	r25, 0x01	; 1
     bc2:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
								LCD_Goto(1,0);
     bc6:	60 e0       	ldi	r22, 0x00	; 0
     bc8:	81 e0       	ldi	r24, 0x01	; 1
     bca:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
								LCD_Write_String("2.Room2");
     bce:	8f ee       	ldi	r24, 0xEF	; 239
     bd0:	91 e0       	ldi	r25, 0x01	; 1
     bd2:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
								LCD_Goto(0,9);
     bd6:	69 e0       	ldi	r22, 0x09	; 9
     bd8:	80 e0       	ldi	r24, 0x00	; 0
     bda:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
								LCD_Write_String("3.Room3");
     bde:	87 ef       	ldi	r24, 0xF7	; 247
     be0:	91 e0       	ldi	r25, 0x01	; 1
     be2:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
								LCD_Goto(1,9);
     be6:	69 e0       	ldi	r22, 0x09	; 9
     be8:	81 e0       	ldi	r24, 0x01	; 1
     bea:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
								LCD_Write_String("4.More");
     bee:	8f ef       	ldi	r24, 0xFF	; 255
     bf0:	91 e0       	ldi	r25, 0x01	; 1
     bf2:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
								// while(!(Keypad_GetValue() >= '1') && (Keypad_GetValue() <= '3') )
								Button_Flag=NULL_KEYPAD;
     bf6:	80 e0       	ldi	r24, 0x00	; 0
								while(Button_Flag==NULL_KEYPAD)
     bf8:	03 c0       	rjmp	.+6      	; 0xc00 <__stack+0x3a1>
								{
									Button_Flag=Keypad_GetValue();
     bfa:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
									Flag = Button_Flag;
     bfe:	f8 2e       	mov	r15, r24
								LCD_Write_String("3.Room3");
								LCD_Goto(1,9);
								LCD_Write_String("4.More");
								// while(!(Keypad_GetValue() >= '1') && (Keypad_GetValue() <= '3') )
								Button_Flag=NULL_KEYPAD;
								while(Button_Flag==NULL_KEYPAD)
     c00:	88 23       	and	r24, r24
     c02:	d9 f3       	breq	.-10     	; 0xbfa <__stack+0x39b>
								{
									Button_Flag=Keypad_GetValue();
									Flag = Button_Flag;
								}
								
								if (Flag=='1'|| Flag=='2' || Flag=='3' || Flag=='4')
     c04:	8f ec       	ldi	r24, 0xCF	; 207
     c06:	8f 0d       	add	r24, r15
     c08:	84 30       	cpi	r24, 0x04	; 4
     c0a:	08 f0       	brcs	.+2      	; 0xc0e <__stack+0x3af>
     c0c:	ba c1       	rjmp	.+884    	; 0xf82 <__stack+0x723>
								{
									switch(Flag)
     c0e:	82 e3       	ldi	r24, 0x32	; 50
     c10:	f8 16       	cp	r15, r24
     c12:	09 f4       	brne	.+2      	; 0xc16 <__stack+0x3b7>
     c14:	53 c0       	rjmp	.+166    	; 0xcbc <__stack+0x45d>
     c16:	8f 15       	cp	r24, r15
     c18:	20 f0       	brcs	.+8      	; 0xc22 <__stack+0x3c3>
     c1a:	91 e3       	ldi	r25, 0x31	; 49
     c1c:	f9 16       	cp	r15, r25
     c1e:	51 f0       	breq	.+20     	; 0xc34 <__stack+0x3d5>
     c20:	b2 c1       	rjmp	.+868    	; 0xf86 <__stack+0x727>
     c22:	23 e3       	ldi	r18, 0x33	; 51
     c24:	f2 16       	cp	r15, r18
     c26:	09 f4       	brne	.+2      	; 0xc2a <__stack+0x3cb>
     c28:	8d c0       	rjmp	.+282    	; 0xd44 <__stack+0x4e5>
     c2a:	84 e3       	ldi	r24, 0x34	; 52
     c2c:	f8 16       	cp	r15, r24
     c2e:	09 f4       	brne	.+2      	; 0xc32 <__stack+0x3d3>
     c30:	cd c0       	rjmp	.+410    	; 0xdcc <__stack+0x56d>
     c32:	a9 c1       	rjmp	.+850    	; 0xf86 <__stack+0x727>
									{
										case '1':
										{
											LCD_Clear();
     c34:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
											LCD_Write_String("1.turn on light");
     c38:	86 e0       	ldi	r24, 0x06	; 6
     c3a:	92 e0       	ldi	r25, 0x02	; 2
     c3c:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
     c40:	9f ef       	ldi	r25, 0xFF	; 255
     c42:	21 ee       	ldi	r18, 0xE1	; 225
     c44:	84 e0       	ldi	r24, 0x04	; 4
     c46:	91 50       	subi	r25, 0x01	; 1
     c48:	20 40       	sbci	r18, 0x00	; 0
     c4a:	80 40       	sbci	r24, 0x00	; 0
     c4c:	e1 f7       	brne	.-8      	; 0xc46 <__stack+0x3e7>
     c4e:	00 c0       	rjmp	.+0      	; 0xc50 <__stack+0x3f1>
     c50:	00 00       	nop
											_delay_ms(100);
											LCD_Goto(1,0);
     c52:	60 e0       	ldi	r22, 0x00	; 0
     c54:	81 e0       	ldi	r24, 0x01	; 1
     c56:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
											LCD_Write_String("2.turn off light");
     c5a:	86 e1       	ldi	r24, 0x16	; 22
     c5c:	92 e0       	ldi	r25, 0x02	; 2
     c5e:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
     c62:	9f ef       	ldi	r25, 0xFF	; 255
     c64:	21 ee       	ldi	r18, 0xE1	; 225
     c66:	84 e0       	ldi	r24, 0x04	; 4
     c68:	91 50       	subi	r25, 0x01	; 1
     c6a:	20 40       	sbci	r18, 0x00	; 0
     c6c:	80 40       	sbci	r24, 0x00	; 0
     c6e:	e1 f7       	brne	.-8      	; 0xc68 <__stack+0x409>
     c70:	00 c0       	rjmp	.+0      	; 0xc72 <__stack+0x413>
     c72:	00 00       	nop
											_delay_ms(100);
											Button_Flag=NULL_KEYPAD;
     c74:	80 e0       	ldi	r24, 0x00	; 0
											while(Button_Flag==NULL_KEYPAD)
     c76:	03 c0       	rjmp	.+6      	; 0xc7e <__stack+0x41f>
											{
												Button_Flag=Keypad_GetValue();
     c78:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
												Flag = Button_Flag;
     c7c:	f8 2e       	mov	r15, r24
											_delay_ms(100);
											LCD_Goto(1,0);
											LCD_Write_String("2.turn off light");
											_delay_ms(100);
											Button_Flag=NULL_KEYPAD;
											while(Button_Flag==NULL_KEYPAD)
     c7e:	88 23       	and	r24, r24
     c80:	d9 f3       	breq	.-10     	; 0xc78 <__stack+0x419>
											{
												Button_Flag=Keypad_GetValue();
												Flag = Button_Flag;
											}
											if (Flag=='1'|| Flag=='2')
     c82:	8f ec       	ldi	r24, 0xCF	; 207
     c84:	8f 0d       	add	r24, r15
     c86:	82 30       	cpi	r24, 0x02	; 2
     c88:	08 f0       	brcs	.+2      	; 0xc8c <__stack+0x42d>
     c8a:	7f c1       	rjmp	.+766    	; 0xf8a <__stack+0x72b>
											{
												switch (Flag)
     c8c:	91 e3       	ldi	r25, 0x31	; 49
     c8e:	f9 16       	cp	r15, r25
     c90:	21 f0       	breq	.+8      	; 0xc9a <__stack+0x43b>
     c92:	22 e3       	ldi	r18, 0x32	; 50
     c94:	f2 16       	cp	r15, r18
     c96:	51 f0       	breq	.+20     	; 0xcac <__stack+0x44d>
     c98:	7a c1       	rjmp	.+756    	; 0xf8e <__stack+0x72f>
												{
													case '1' :
													{
														LCD_Clear();
     c9a:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
														LED0_ON();
     c9e:	0e 94 80 0b 	call	0x1700	; 0x1700 <LED0_ON>
														Flag_Lamp=1;
     ca2:	81 e0       	ldi	r24, 0x01	; 1
     ca4:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <Flag_Lamp>
						case '1' :
						{
							Uint8 check=0;
							while (!check)
							{
								check=1;
     ca8:	11 e0       	ldi	r17, 0x01	; 1
													case '1' :
													{
														LCD_Clear();
														LED0_ON();
														Flag_Lamp=1;
														break;
     caa:	82 c1       	rjmp	.+772    	; 0xfb0 <__stack+0x751>
													}
													case'2' :
													{
														LCD_Clear();
     cac:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
														LED0_OFF();
     cb0:	0e 94 86 0b 	call	0x170c	; 0x170c <LED0_OFF>
														Flag_Lamp=0;
     cb4:	10 92 17 08 	sts	0x0817, r1	; 0x800817 <Flag_Lamp>
						case '1' :
						{
							Uint8 check=0;
							while (!check)
							{
								check=1;
     cb8:	11 e0       	ldi	r17, 0x01	; 1
													case'2' :
													{
														LCD_Clear();
														LED0_OFF();
														Flag_Lamp=0;
														break;
     cba:	7a c1       	rjmp	.+756    	; 0xfb0 <__stack+0x751>
											
											break;
										}//End OF Case 1
										case '2':
										{
											LCD_Clear();
     cbc:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
											LCD_Write_String("1.turn on light");
     cc0:	86 e0       	ldi	r24, 0x06	; 6
     cc2:	92 e0       	ldi	r25, 0x02	; 2
     cc4:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
     cc8:	8f ef       	ldi	r24, 0xFF	; 255
     cca:	91 ee       	ldi	r25, 0xE1	; 225
     ccc:	24 e0       	ldi	r18, 0x04	; 4
     cce:	81 50       	subi	r24, 0x01	; 1
     cd0:	90 40       	sbci	r25, 0x00	; 0
     cd2:	20 40       	sbci	r18, 0x00	; 0
     cd4:	e1 f7       	brne	.-8      	; 0xcce <__stack+0x46f>
     cd6:	00 c0       	rjmp	.+0      	; 0xcd8 <__stack+0x479>
     cd8:	00 00       	nop
											_delay_ms(100);
											LCD_Goto(1,0);
     cda:	60 e0       	ldi	r22, 0x00	; 0
     cdc:	81 e0       	ldi	r24, 0x01	; 1
     cde:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
											LCD_Write_String("2.turn off light");
     ce2:	86 e1       	ldi	r24, 0x16	; 22
     ce4:	92 e0       	ldi	r25, 0x02	; 2
     ce6:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
     cea:	8f ef       	ldi	r24, 0xFF	; 255
     cec:	91 ee       	ldi	r25, 0xE1	; 225
     cee:	24 e0       	ldi	r18, 0x04	; 4
     cf0:	81 50       	subi	r24, 0x01	; 1
     cf2:	90 40       	sbci	r25, 0x00	; 0
     cf4:	20 40       	sbci	r18, 0x00	; 0
     cf6:	e1 f7       	brne	.-8      	; 0xcf0 <__stack+0x491>
     cf8:	00 c0       	rjmp	.+0      	; 0xcfa <__stack+0x49b>
     cfa:	00 00       	nop
											_delay_ms(100);
											Button_Flag=NULL_KEYPAD;
     cfc:	80 e0       	ldi	r24, 0x00	; 0
											while(Button_Flag==NULL_KEYPAD)
     cfe:	03 c0       	rjmp	.+6      	; 0xd06 <__stack+0x4a7>
											{
												Button_Flag=Keypad_GetValue();
     d00:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
												Flag = Button_Flag;
     d04:	f8 2e       	mov	r15, r24
											_delay_ms(100);
											LCD_Goto(1,0);
											LCD_Write_String("2.turn off light");
											_delay_ms(100);
											Button_Flag=NULL_KEYPAD;
											while(Button_Flag==NULL_KEYPAD)
     d06:	88 23       	and	r24, r24
     d08:	d9 f3       	breq	.-10     	; 0xd00 <__stack+0x4a1>
											{
												Button_Flag=Keypad_GetValue();
												Flag = Button_Flag;
											}
											if (Flag=='1'|| Flag=='2')
     d0a:	8f ec       	ldi	r24, 0xCF	; 207
     d0c:	8f 0d       	add	r24, r15
     d0e:	82 30       	cpi	r24, 0x02	; 2
     d10:	08 f0       	brcs	.+2      	; 0xd14 <__stack+0x4b5>
     d12:	3f c1       	rjmp	.+638    	; 0xf92 <__stack+0x733>
											{
												switch (Flag)
     d14:	81 e3       	ldi	r24, 0x31	; 49
     d16:	f8 16       	cp	r15, r24
     d18:	21 f0       	breq	.+8      	; 0xd22 <__stack+0x4c3>
     d1a:	92 e3       	ldi	r25, 0x32	; 50
     d1c:	f9 16       	cp	r15, r25
     d1e:	51 f0       	breq	.+20     	; 0xd34 <__stack+0x4d5>
     d20:	3a c1       	rjmp	.+628    	; 0xf96 <__stack+0x737>
												{
													case '1' :
													{
														LCD_Clear();
     d22:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
														LED1_ON();
     d26:	0e 94 9c 0b 	call	0x1738	; 0x1738 <LED1_ON>
														Flag_Lamp_2=1;
     d2a:	81 e0       	ldi	r24, 0x01	; 1
     d2c:	80 93 16 08 	sts	0x0816, r24	; 0x800816 <Flag_Lamp_2>
						case '1' :
						{
							Uint8 check=0;
							while (!check)
							{
								check=1;
     d30:	11 e0       	ldi	r17, 0x01	; 1
													case '1' :
													{
														LCD_Clear();
														LED1_ON();
														Flag_Lamp_2=1;
														break;
     d32:	3e c1       	rjmp	.+636    	; 0xfb0 <__stack+0x751>
													}
													case'2' :
													{
														LCD_Clear();
     d34:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
														LED1_OFF();
     d38:	0e 94 a2 0b 	call	0x1744	; 0x1744 <LED1_OFF>
														Flag_Lamp_2=0;
     d3c:	10 92 16 08 	sts	0x0816, r1	; 0x800816 <Flag_Lamp_2>
						case '1' :
						{
							Uint8 check=0;
							while (!check)
							{
								check=1;
     d40:	11 e0       	ldi	r17, 0x01	; 1
													case'2' :
													{
														LCD_Clear();
														LED1_OFF();
														Flag_Lamp_2=0;
														break;
     d42:	36 c1       	rjmp	.+620    	; 0xfb0 <__stack+0x751>
											
											break;
										}//End OF Case 2
										case '3':
										{
											LCD_Clear();
     d44:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
											LCD_Write_String("1.turn on light");
     d48:	86 e0       	ldi	r24, 0x06	; 6
     d4a:	92 e0       	ldi	r25, 0x02	; 2
     d4c:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
     d50:	2f ef       	ldi	r18, 0xFF	; 255
     d52:	81 ee       	ldi	r24, 0xE1	; 225
     d54:	94 e0       	ldi	r25, 0x04	; 4
     d56:	21 50       	subi	r18, 0x01	; 1
     d58:	80 40       	sbci	r24, 0x00	; 0
     d5a:	90 40       	sbci	r25, 0x00	; 0
     d5c:	e1 f7       	brne	.-8      	; 0xd56 <__stack+0x4f7>
     d5e:	00 c0       	rjmp	.+0      	; 0xd60 <__stack+0x501>
     d60:	00 00       	nop
											_delay_ms(100);
											LCD_Goto(1,0);
     d62:	60 e0       	ldi	r22, 0x00	; 0
     d64:	81 e0       	ldi	r24, 0x01	; 1
     d66:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
											LCD_Write_String("2.turn off light");
     d6a:	86 e1       	ldi	r24, 0x16	; 22
     d6c:	92 e0       	ldi	r25, 0x02	; 2
     d6e:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
     d72:	2f ef       	ldi	r18, 0xFF	; 255
     d74:	81 ee       	ldi	r24, 0xE1	; 225
     d76:	94 e0       	ldi	r25, 0x04	; 4
     d78:	21 50       	subi	r18, 0x01	; 1
     d7a:	80 40       	sbci	r24, 0x00	; 0
     d7c:	90 40       	sbci	r25, 0x00	; 0
     d7e:	e1 f7       	brne	.-8      	; 0xd78 <__stack+0x519>
     d80:	00 c0       	rjmp	.+0      	; 0xd82 <__stack+0x523>
     d82:	00 00       	nop
											_delay_ms(100);
											Button_Flag=NULL_KEYPAD;
     d84:	80 e0       	ldi	r24, 0x00	; 0
											while(Button_Flag==NULL_KEYPAD)
     d86:	03 c0       	rjmp	.+6      	; 0xd8e <__stack+0x52f>
											{
												Button_Flag=Keypad_GetValue();
     d88:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
												Flag = Button_Flag;
     d8c:	f8 2e       	mov	r15, r24
											_delay_ms(100);
											LCD_Goto(1,0);
											LCD_Write_String("2.turn off light");
											_delay_ms(100);
											Button_Flag=NULL_KEYPAD;
											while(Button_Flag==NULL_KEYPAD)
     d8e:	88 23       	and	r24, r24
     d90:	d9 f3       	breq	.-10     	; 0xd88 <__stack+0x529>
											{
												Button_Flag=Keypad_GetValue();
												Flag = Button_Flag;
											}
											if (Flag=='1'|| Flag=='2')
     d92:	8f ec       	ldi	r24, 0xCF	; 207
     d94:	8f 0d       	add	r24, r15
     d96:	82 30       	cpi	r24, 0x02	; 2
     d98:	08 f0       	brcs	.+2      	; 0xd9c <__stack+0x53d>
     d9a:	ff c0       	rjmp	.+510    	; 0xf9a <__stack+0x73b>
											{
												switch (Flag)
     d9c:	21 e3       	ldi	r18, 0x31	; 49
     d9e:	f2 16       	cp	r15, r18
     da0:	21 f0       	breq	.+8      	; 0xdaa <__stack+0x54b>
     da2:	82 e3       	ldi	r24, 0x32	; 50
     da4:	f8 16       	cp	r15, r24
     da6:	51 f0       	breq	.+20     	; 0xdbc <__stack+0x55d>
     da8:	fa c0       	rjmp	.+500    	; 0xf9e <__stack+0x73f>
												{
													case '1' :
													{
														LCD_Clear();
     daa:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
														LED2_ON();
     dae:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LED2_ON>
														Flag_Lamp_3=1;
     db2:	81 e0       	ldi	r24, 0x01	; 1
     db4:	80 93 15 08 	sts	0x0815, r24	; 0x800815 <Flag_Lamp_3>
						case '1' :
						{
							Uint8 check=0;
							while (!check)
							{
								check=1;
     db8:	11 e0       	ldi	r17, 0x01	; 1
													case '1' :
													{
														LCD_Clear();
														LED2_ON();
														Flag_Lamp_3=1;
														break;
     dba:	fa c0       	rjmp	.+500    	; 0xfb0 <__stack+0x751>
													}
													case'2' :
													{
														LCD_Clear();
     dbc:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
														LED2_OFF();
     dc0:	0e 94 be 0b 	call	0x177c	; 0x177c <LED2_OFF>
														Flag_Lamp_3=0;
     dc4:	10 92 15 08 	sts	0x0815, r1	; 0x800815 <Flag_Lamp_3>
						case '1' :
						{
							Uint8 check=0;
							while (!check)
							{
								check=1;
     dc8:	11 e0       	ldi	r17, 0x01	; 1
													{
														LCD_Clear();
														LED2_OFF();
														Flag_Lamp_3=0;

														break;
     dca:	f2 c0       	rjmp	.+484    	; 0xfb0 <__stack+0x751>
											
											break;
										}//End OF Case 3
										case '4' :
										{
											LCD_Clear();
     dcc:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
											LCD_Write_String("5.Room4");
     dd0:	87 e2       	ldi	r24, 0x27	; 39
     dd2:	92 e0       	ldi	r25, 0x02	; 2
     dd4:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
											LCD_Goto(1,0);
     dd8:	60 e0       	ldi	r22, 0x00	; 0
     dda:	81 e0       	ldi	r24, 0x01	; 1
     ddc:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
											LCD_Write_String("6.LAMP");
     de0:	8f e2       	ldi	r24, 0x2F	; 47
     de2:	92 e0       	ldi	r25, 0x02	; 2
     de4:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
											LCD_Goto(1,8);
     de8:	68 e0       	ldi	r22, 0x08	; 8
     dea:	81 e0       	ldi	r24, 0x01	; 1
     dec:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
											LCD_Write_String("7.Back");
     df0:	86 e3       	ldi	r24, 0x36	; 54
     df2:	92 e0       	ldi	r25, 0x02	; 2
     df4:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
											Button_Flag=NULL_KEYPAD;
     df8:	80 e0       	ldi	r24, 0x00	; 0
											while(Button_Flag==NULL_KEYPAD)
     dfa:	03 c0       	rjmp	.+6      	; 0xe02 <__stack+0x5a3>
											{
												Button_Flag=Keypad_GetValue();
     dfc:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
												Flag = Button_Flag;
     e00:	f8 2e       	mov	r15, r24
											LCD_Goto(1,0);
											LCD_Write_String("6.LAMP");
											LCD_Goto(1,8);
											LCD_Write_String("7.Back");
											Button_Flag=NULL_KEYPAD;
											while(Button_Flag==NULL_KEYPAD)
     e02:	88 23       	and	r24, r24
     e04:	d9 f3       	breq	.-10     	; 0xdfc <__stack+0x59d>
											{
												Button_Flag=Keypad_GetValue();
												Flag = Button_Flag;
											}
											if ( Flag=='5' || Flag=='6' || Flag=='7')
     e06:	8b ec       	ldi	r24, 0xCB	; 203
     e08:	8f 0d       	add	r24, r15
     e0a:	83 30       	cpi	r24, 0x03	; 3
     e0c:	08 f0       	brcs	.+2      	; 0xe10 <__stack+0x5b1>
     e0e:	c9 c0       	rjmp	.+402    	; 0xfa2 <__stack+0x743>
											{
												switch (Flag)
     e10:	96 e3       	ldi	r25, 0x36	; 54
     e12:	f9 16       	cp	r15, r25
     e14:	09 f4       	brne	.+2      	; 0xe18 <__stack+0x5b9>
     e16:	4d c0       	rjmp	.+154    	; 0xeb2 <__stack+0x653>
     e18:	27 e3       	ldi	r18, 0x37	; 55
     e1a:	f2 16       	cp	r15, r18
     e1c:	09 f4       	brne	.+2      	; 0xe20 <__stack+0x5c1>
     e1e:	c8 c0       	rjmp	.+400    	; 0xfb0 <__stack+0x751>
     e20:	85 e3       	ldi	r24, 0x35	; 53
     e22:	f8 16       	cp	r15, r24
     e24:	11 f0       	breq	.+4      	; 0xe2a <__stack+0x5cb>
						case '1' :
						{
							Uint8 check=0;
							while (!check)
							{
								check=1;
     e26:	11 e0       	ldi	r17, 0x01	; 1
     e28:	c3 c0       	rjmp	.+390    	; 0xfb0 <__stack+0x751>
											{
												switch (Flag)
												{
													case'5':
													{
														LCD_Clear();
     e2a:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
														LCD_Write_String("1.turn on light");
     e2e:	86 e0       	ldi	r24, 0x06	; 6
     e30:	92 e0       	ldi	r25, 0x02	; 2
     e32:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
     e36:	9f ef       	ldi	r25, 0xFF	; 255
     e38:	21 ee       	ldi	r18, 0xE1	; 225
     e3a:	84 e0       	ldi	r24, 0x04	; 4
     e3c:	91 50       	subi	r25, 0x01	; 1
     e3e:	20 40       	sbci	r18, 0x00	; 0
     e40:	80 40       	sbci	r24, 0x00	; 0
     e42:	e1 f7       	brne	.-8      	; 0xe3c <__stack+0x5dd>
     e44:	00 c0       	rjmp	.+0      	; 0xe46 <__stack+0x5e7>
     e46:	00 00       	nop
														_delay_ms(100);
														LCD_Goto(1,0);
     e48:	60 e0       	ldi	r22, 0x00	; 0
     e4a:	81 e0       	ldi	r24, 0x01	; 1
     e4c:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
														LCD_Write_String("2.turn off light");
     e50:	86 e1       	ldi	r24, 0x16	; 22
     e52:	92 e0       	ldi	r25, 0x02	; 2
     e54:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
     e58:	9f ef       	ldi	r25, 0xFF	; 255
     e5a:	21 ee       	ldi	r18, 0xE1	; 225
     e5c:	84 e0       	ldi	r24, 0x04	; 4
     e5e:	91 50       	subi	r25, 0x01	; 1
     e60:	20 40       	sbci	r18, 0x00	; 0
     e62:	80 40       	sbci	r24, 0x00	; 0
     e64:	e1 f7       	brne	.-8      	; 0xe5e <__stack+0x5ff>
     e66:	00 c0       	rjmp	.+0      	; 0xe68 <__stack+0x609>
     e68:	00 00       	nop
														_delay_ms(100);
														Button_Flag=NULL_KEYPAD;
     e6a:	80 e0       	ldi	r24, 0x00	; 0
														while(Button_Flag==NULL_KEYPAD)
     e6c:	03 c0       	rjmp	.+6      	; 0xe74 <__stack+0x615>
														{
															Button_Flag=Keypad_GetValue();
     e6e:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
															Flag = Button_Flag;
     e72:	f8 2e       	mov	r15, r24
														_delay_ms(100);
														LCD_Goto(1,0);
														LCD_Write_String("2.turn off light");
														_delay_ms(100);
														Button_Flag=NULL_KEYPAD;
														while(Button_Flag==NULL_KEYPAD)
     e74:	88 23       	and	r24, r24
     e76:	d9 f3       	breq	.-10     	; 0xe6e <__stack+0x60f>
														{
															Button_Flag=Keypad_GetValue();
															Flag = Button_Flag;
														}
														if (Flag=='1'|| Flag=='2')
     e78:	8f ec       	ldi	r24, 0xCF	; 207
     e7a:	8f 0d       	add	r24, r15
     e7c:	82 30       	cpi	r24, 0x02	; 2
     e7e:	08 f0       	brcs	.+2      	; 0xe82 <__stack+0x623>
     e80:	92 c0       	rjmp	.+292    	; 0xfa6 <__stack+0x747>
														{
															switch (Flag)
     e82:	91 e3       	ldi	r25, 0x31	; 49
     e84:	f9 16       	cp	r15, r25
     e86:	21 f0       	breq	.+8      	; 0xe90 <__stack+0x631>
     e88:	22 e3       	ldi	r18, 0x32	; 50
     e8a:	f2 16       	cp	r15, r18
     e8c:	51 f0       	breq	.+20     	; 0xea2 <__stack+0x643>
     e8e:	8d c0       	rjmp	.+282    	; 0xfaa <__stack+0x74b>
															{
																case '1' :
																{
																	LCD_Clear();
     e90:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
																	LED3_ON();
     e94:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <LED3_ON>
																	Flag_Lamp_4=1;
     e98:	81 e0       	ldi	r24, 0x01	; 1
     e9a:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <Flag_Lamp_4>
						case '1' :
						{
							Uint8 check=0;
							while (!check)
							{
								check=1;
     e9e:	11 e0       	ldi	r17, 0x01	; 1
																case '1' :
																{
																	LCD_Clear();
																	LED3_ON();
																	Flag_Lamp_4=1;
																	break;
     ea0:	87 c0       	rjmp	.+270    	; 0xfb0 <__stack+0x751>
																}
																case'2' :
																{
																	LCD_Clear();
     ea2:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
																	LED3_OFF();
     ea6:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <LED3_OFF>
																	Flag_Lamp_4=0;
     eaa:	10 92 14 08 	sts	0x0814, r1	; 0x800814 <Flag_Lamp_4>
						case '1' :
						{
							Uint8 check=0;
							while (!check)
							{
								check=1;
     eae:	11 e0       	ldi	r17, 0x01	; 1
																case'2' :
																{
																	LCD_Clear();
																	LED3_OFF();
																	Flag_Lamp_4=0;
																	break;
     eb0:	7f c0       	rjmp	.+254    	; 0xfb0 <__stack+0x751>
														break;
														
													}//end of case 5
													case '6' :
													{
														LCD_Clear();
     eb2:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
														LCD_Write_String("1-25%");
     eb6:	8d e3       	ldi	r24, 0x3D	; 61
     eb8:	92 e0       	ldi	r25, 0x02	; 2
     eba:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
														LCD_Goto(0,7);
     ebe:	67 e0       	ldi	r22, 0x07	; 7
     ec0:	80 e0       	ldi	r24, 0x00	; 0
     ec2:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
														LCD_Write_String("2-50%");
     ec6:	83 e4       	ldi	r24, 0x43	; 67
     ec8:	92 e0       	ldi	r25, 0x02	; 2
     eca:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
														LCD_Goto(1,0);
     ece:	60 e0       	ldi	r22, 0x00	; 0
     ed0:	81 e0       	ldi	r24, 0x01	; 1
     ed2:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
														LCD_Write_String("3-75%");
     ed6:	89 e4       	ldi	r24, 0x49	; 73
     ed8:	92 e0       	ldi	r25, 0x02	; 2
     eda:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
														LCD_Goto(1,7);
     ede:	67 e0       	ldi	r22, 0x07	; 7
     ee0:	81 e0       	ldi	r24, 0x01	; 1
     ee2:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
														LCD_Write_String("4-100%");
     ee6:	8f e4       	ldi	r24, 0x4F	; 79
     ee8:	92 e0       	ldi	r25, 0x02	; 2
     eea:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
														Button_Flag=NULL_KEYPAD;
     eee:	80 e0       	ldi	r24, 0x00	; 0
														while(Button_Flag==NULL_KEYPAD)
     ef0:	03 c0       	rjmp	.+6      	; 0xef8 <__stack+0x699>
														{
															Button_Flag=Keypad_GetValue();
     ef2:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
															Flag = Button_Flag;
     ef6:	f8 2e       	mov	r15, r24
														LCD_Goto(1,0);
														LCD_Write_String("3-75%");
														LCD_Goto(1,7);
														LCD_Write_String("4-100%");
														Button_Flag=NULL_KEYPAD;
														while(Button_Flag==NULL_KEYPAD)
     ef8:	88 23       	and	r24, r24
     efa:	d9 f3       	breq	.-10     	; 0xef2 <__stack+0x693>
														{
															Button_Flag=Keypad_GetValue();
															Flag = Button_Flag;
														}
														if (Flag=='1'|| Flag=='2' || Flag=='3' || Flag=='4')
     efc:	8f ec       	ldi	r24, 0xCF	; 207
     efe:	8f 0d       	add	r24, r15
     f00:	84 30       	cpi	r24, 0x04	; 4
     f02:	b8 f5       	brcc	.+110    	; 0xf72 <__stack+0x713>
														{
															switch (Flag)
     f04:	82 e3       	ldi	r24, 0x32	; 50
     f06:	f8 16       	cp	r15, r24
     f08:	b9 f0       	breq	.+46     	; 0xf38 <__stack+0x6d9>
     f0a:	8f 15       	cp	r24, r15
     f0c:	20 f0       	brcs	.+8      	; 0xf16 <__stack+0x6b7>
     f0e:	91 e3       	ldi	r25, 0x31	; 49
     f10:	f9 16       	cp	r15, r25
     f12:	41 f0       	breq	.+16     	; 0xf24 <__stack+0x6c5>
     f14:	2e c0       	rjmp	.+92     	; 0xf72 <__stack+0x713>
     f16:	23 e3       	ldi	r18, 0x33	; 51
     f18:	f2 16       	cp	r15, r18
     f1a:	c1 f0       	breq	.+48     	; 0xf4c <__stack+0x6ed>
     f1c:	84 e3       	ldi	r24, 0x34	; 52
     f1e:	f8 16       	cp	r15, r24
     f20:	f9 f0       	breq	.+62     	; 0xf60 <__stack+0x701>
     f22:	27 c0       	rjmp	.+78     	; 0xf72 <__stack+0x713>
															{
																case '1':
																{
																	PWM0_Gen(25);
     f24:	60 e0       	ldi	r22, 0x00	; 0
     f26:	70 e0       	ldi	r23, 0x00	; 0
     f28:	88 ec       	ldi	r24, 0xC8	; 200
     f2a:	91 e4       	ldi	r25, 0x41	; 65
     f2c:	0e 94 a0 13 	call	0x2740	; 0x2740 <PWM0_Gen>
																	Flag_Dimmer=1;
     f30:	81 e0       	ldi	r24, 0x01	; 1
     f32:	80 93 10 08 	sts	0x0810, r24	; 0x800810 <Flag_Dimmer>
																	break;
     f36:	1d c0       	rjmp	.+58     	; 0xf72 <__stack+0x713>
																}//End Of Case 1
																case '2':
																{
																	PWM0_Gen(50);
     f38:	60 e0       	ldi	r22, 0x00	; 0
     f3a:	70 e0       	ldi	r23, 0x00	; 0
     f3c:	88 e4       	ldi	r24, 0x48	; 72
     f3e:	92 e4       	ldi	r25, 0x42	; 66
     f40:	0e 94 a0 13 	call	0x2740	; 0x2740 <PWM0_Gen>
																	Flag_Dimmer=1;
     f44:	81 e0       	ldi	r24, 0x01	; 1
     f46:	80 93 10 08 	sts	0x0810, r24	; 0x800810 <Flag_Dimmer>
																	break;
     f4a:	13 c0       	rjmp	.+38     	; 0xf72 <__stack+0x713>
																}//End Of Case 2
																case '3':
																{
																	PWM0_Gen(75);
     f4c:	60 e0       	ldi	r22, 0x00	; 0
     f4e:	70 e0       	ldi	r23, 0x00	; 0
     f50:	86 e9       	ldi	r24, 0x96	; 150
     f52:	92 e4       	ldi	r25, 0x42	; 66
     f54:	0e 94 a0 13 	call	0x2740	; 0x2740 <PWM0_Gen>
																	Flag_Dimmer=1;
     f58:	81 e0       	ldi	r24, 0x01	; 1
     f5a:	80 93 10 08 	sts	0x0810, r24	; 0x800810 <Flag_Dimmer>
																	break;
     f5e:	09 c0       	rjmp	.+18     	; 0xf72 <__stack+0x713>
																}//End Of Case 3
																case '4':
																{
																	PWM0_Gen(100);
     f60:	60 e0       	ldi	r22, 0x00	; 0
     f62:	70 e0       	ldi	r23, 0x00	; 0
     f64:	88 ec       	ldi	r24, 0xC8	; 200
     f66:	92 e4       	ldi	r25, 0x42	; 66
     f68:	0e 94 a0 13 	call	0x2740	; 0x2740 <PWM0_Gen>
																	Flag_Dimmer=1;
     f6c:	81 e0       	ldi	r24, 0x01	; 1
     f6e:	80 93 10 08 	sts	0x0810, r24	; 0x800810 <Flag_Dimmer>
																	break;
																}//End Of Case 4
															}//End Of switch case
														}//End Of If Conditon
														LCD_Clear();
     f72:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
														LCD_Write_String("Done");
     f76:	86 e5       	ldi	r24, 0x56	; 86
     f78:	92 e0       	ldi	r25, 0x02	; 2
     f7a:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
						case '1' :
						{
							Uint8 check=0;
							while (!check)
							{
								check=1;
     f7e:	11 e0       	ldi	r17, 0x01	; 1
															}//End Of switch case
														}//End Of If Conditon
														LCD_Clear();
														LCD_Write_String("Done");
																						
														break;
     f80:	17 c0       	rjmp	.+46     	; 0xfb0 <__stack+0x751>
						case '1' :
						{
							Uint8 check=0;
							while (!check)
							{
								check=1;
     f82:	11 e0       	ldi	r17, 0x01	; 1
     f84:	15 c0       	rjmp	.+42     	; 0xfb0 <__stack+0x751>
     f86:	11 e0       	ldi	r17, 0x01	; 1
     f88:	13 c0       	rjmp	.+38     	; 0xfb0 <__stack+0x751>
     f8a:	11 e0       	ldi	r17, 0x01	; 1
     f8c:	11 c0       	rjmp	.+34     	; 0xfb0 <__stack+0x751>
     f8e:	11 e0       	ldi	r17, 0x01	; 1
     f90:	0f c0       	rjmp	.+30     	; 0xfb0 <__stack+0x751>
     f92:	11 e0       	ldi	r17, 0x01	; 1
     f94:	0d c0       	rjmp	.+26     	; 0xfb0 <__stack+0x751>
     f96:	11 e0       	ldi	r17, 0x01	; 1
     f98:	0b c0       	rjmp	.+22     	; 0xfb0 <__stack+0x751>
     f9a:	11 e0       	ldi	r17, 0x01	; 1
     f9c:	09 c0       	rjmp	.+18     	; 0xfb0 <__stack+0x751>
     f9e:	11 e0       	ldi	r17, 0x01	; 1
     fa0:	07 c0       	rjmp	.+14     	; 0xfb0 <__stack+0x751>
     fa2:	11 e0       	ldi	r17, 0x01	; 1
     fa4:	05 c0       	rjmp	.+10     	; 0xfb0 <__stack+0x751>
     fa6:	11 e0       	ldi	r17, 0x01	; 1
     fa8:	03 c0       	rjmp	.+6      	; 0xfb0 <__stack+0x751>
     faa:	11 e0       	ldi	r17, 0x01	; 1
     fac:	01 c0       	rjmp	.+2      	; 0xfb0 <__stack+0x751>
					Button_Flag=Keypad_GetValue();
					Flag = Button_Flag;
				}
				if (Flag=='1'|| Flag=='2')
				{
					switch(Flag)
     fae:	10 e0       	ldi	r17, 0x00	; 0
					{
						
						case '1' :
						{
							Uint8 check=0;
							while (!check)
     fb0:	11 23       	and	r17, r17
     fb2:	09 f4       	brne	.+2      	; 0xfb6 <__stack+0x757>
     fb4:	02 ce       	rjmp	.-1020   	; 0xbba <__stack+0x35b>
     fb6:	01 c1       	rjmp	.+514    	; 0x11ba <__stack+0x95b>
						{
							Uint8 check=0;
							while (!check)
							{
								check =1;
								LCD_Clear();
     fb8:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
								LCD_Write_String("1.Room1");
     fbc:	87 ee       	ldi	r24, 0xE7	; 231
     fbe:	91 e0       	ldi	r25, 0x01	; 1
     fc0:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
								LCD_Goto(0,9);
     fc4:	69 e0       	ldi	r22, 0x09	; 9
     fc6:	80 e0       	ldi	r24, 0x00	; 0
     fc8:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
								LCD_Write_String("2.Room2");
     fcc:	8f ee       	ldi	r24, 0xEF	; 239
     fce:	91 e0       	ldi	r25, 0x01	; 1
     fd0:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
								LCD_Goto(1,0);
     fd4:	60 e0       	ldi	r22, 0x00	; 0
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
								LCD_Write_String("3.Room3");
     fdc:	87 ef       	ldi	r24, 0xF7	; 247
     fde:	91 e0       	ldi	r25, 0x01	; 1
     fe0:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
								LCD_Goto(1,9);
     fe4:	69 e0       	ldi	r22, 0x09	; 9
     fe6:	81 e0       	ldi	r24, 0x01	; 1
     fe8:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
								LCD_Write_String("4.More");
     fec:	8f ef       	ldi	r24, 0xFF	; 255
     fee:	91 e0       	ldi	r25, 0x01	; 1
     ff0:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
								Button_Flag=NULL_KEYPAD;
     ff4:	80 e0       	ldi	r24, 0x00	; 0
								while(Button_Flag==NULL_KEYPAD)
     ff6:	03 c0       	rjmp	.+6      	; 0xffe <__stack+0x79f>
								{
									Button_Flag=Keypad_GetValue();
     ff8:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
									Flag = Button_Flag;
     ffc:	f8 2e       	mov	r15, r24
								LCD_Goto(1,0);
								LCD_Write_String("3.Room3");
								LCD_Goto(1,9);
								LCD_Write_String("4.More");
								Button_Flag=NULL_KEYPAD;
								while(Button_Flag==NULL_KEYPAD)
     ffe:	88 23       	and	r24, r24
    1000:	d9 f3       	breq	.-10     	; 0xff8 <__stack+0x799>
								{
									Button_Flag=Keypad_GetValue();
									Flag = Button_Flag;
								}
								
								if (Flag=='1'|| Flag=='2' || Flag=='3' || Flag=='4')
    1002:	8f ec       	ldi	r24, 0xCF	; 207
    1004:	8f 0d       	add	r24, r15
    1006:	84 30       	cpi	r24, 0x04	; 4
    1008:	08 f0       	brcs	.+2      	; 0x100c <__stack+0x7ad>
    100a:	cb c0       	rjmp	.+406    	; 0x11a2 <__stack+0x943>
								{
									switch(Flag)
    100c:	92 e3       	ldi	r25, 0x32	; 50
    100e:	f9 16       	cp	r15, r25
    1010:	a9 f1       	breq	.+106    	; 0x107c <__stack+0x81d>
    1012:	9f 15       	cp	r25, r15
    1014:	20 f0       	brcs	.+8      	; 0x101e <__stack+0x7bf>
    1016:	21 e3       	ldi	r18, 0x31	; 49
    1018:	f2 16       	cp	r15, r18
    101a:	51 f0       	breq	.+20     	; 0x1030 <__stack+0x7d1>
    101c:	c4 c0       	rjmp	.+392    	; 0x11a6 <__stack+0x947>
    101e:	83 e3       	ldi	r24, 0x33	; 51
    1020:	f8 16       	cp	r15, r24
    1022:	09 f4       	brne	.+2      	; 0x1026 <__stack+0x7c7>
    1024:	51 c0       	rjmp	.+162    	; 0x10c8 <__stack+0x869>
    1026:	94 e3       	ldi	r25, 0x34	; 52
    1028:	f9 16       	cp	r15, r25
    102a:	09 f4       	brne	.+2      	; 0x102e <__stack+0x7cf>
    102c:	73 c0       	rjmp	.+230    	; 0x1114 <__stack+0x8b5>
    102e:	bb c0       	rjmp	.+374    	; 0x11a6 <__stack+0x947>
									{
										case '1' :
										{
											if (Flag_Lamp==1)
    1030:	80 91 17 08 	lds	r24, 0x0817	; 0x800817 <Flag_Lamp>
    1034:	81 30       	cpi	r24, 0x01	; 1
    1036:	89 f4       	brne	.+34     	; 0x105a <__stack+0x7fb>
											{
												LCD_Clear();
    1038:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
												LCD_Write_String("LAMP IS ON");
    103c:	8b e5       	ldi	r24, 0x5B	; 91
    103e:	92 e0       	ldi	r25, 0x02	; 2
    1040:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
    1044:	2f ef       	ldi	r18, 0xFF	; 255
    1046:	87 ea       	ldi	r24, 0xA7	; 167
    1048:	91 e6       	ldi	r25, 0x61	; 97
    104a:	21 50       	subi	r18, 0x01	; 1
    104c:	80 40       	sbci	r24, 0x00	; 0
    104e:	90 40       	sbci	r25, 0x00	; 0
    1050:	e1 f7       	brne	.-8      	; 0x104a <__stack+0x7eb>
    1052:	00 c0       	rjmp	.+0      	; 0x1054 <__stack+0x7f5>
    1054:	00 00       	nop
						case '2' :
						{
							Uint8 check=0;
							while (!check)
							{
								check =1;
    1056:	11 e0       	ldi	r17, 0x01	; 1
    1058:	ab c0       	rjmp	.+342    	; 0x11b0 <__stack+0x951>
												LCD_Write_String("LAMP IS ON");
												_delay_ms(2000);
											}
											else
											{
												LCD_Clear();
    105a:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
												LCD_Write_String("LAMP IS OFF");
    105e:	86 e6       	ldi	r24, 0x66	; 102
    1060:	92 e0       	ldi	r25, 0x02	; 2
    1062:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
    1066:	2f ef       	ldi	r18, 0xFF	; 255
    1068:	87 ea       	ldi	r24, 0xA7	; 167
    106a:	91 e6       	ldi	r25, 0x61	; 97
    106c:	21 50       	subi	r18, 0x01	; 1
    106e:	80 40       	sbci	r24, 0x00	; 0
    1070:	90 40       	sbci	r25, 0x00	; 0
    1072:	e1 f7       	brne	.-8      	; 0x106c <__stack+0x80d>
    1074:	00 c0       	rjmp	.+0      	; 0x1076 <__stack+0x817>
    1076:	00 00       	nop
						case '2' :
						{
							Uint8 check=0;
							while (!check)
							{
								check =1;
    1078:	11 e0       	ldi	r17, 0x01	; 1
    107a:	9a c0       	rjmp	.+308    	; 0x11b0 <__stack+0x951>
											}
											break;
										}//end of case 1
										case '2' :
										{
											if (Flag_Lamp_2==1)
    107c:	80 91 16 08 	lds	r24, 0x0816	; 0x800816 <Flag_Lamp_2>
    1080:	81 30       	cpi	r24, 0x01	; 1
    1082:	89 f4       	brne	.+34     	; 0x10a6 <__stack+0x847>
											{
												LCD_Clear();
    1084:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
												LCD_Write_String("LAMP IS ON");
    1088:	8b e5       	ldi	r24, 0x5B	; 91
    108a:	92 e0       	ldi	r25, 0x02	; 2
    108c:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
    1090:	2f ef       	ldi	r18, 0xFF	; 255
    1092:	87 ea       	ldi	r24, 0xA7	; 167
    1094:	91 e6       	ldi	r25, 0x61	; 97
    1096:	21 50       	subi	r18, 0x01	; 1
    1098:	80 40       	sbci	r24, 0x00	; 0
    109a:	90 40       	sbci	r25, 0x00	; 0
    109c:	e1 f7       	brne	.-8      	; 0x1096 <__stack+0x837>
    109e:	00 c0       	rjmp	.+0      	; 0x10a0 <__stack+0x841>
    10a0:	00 00       	nop
						case '2' :
						{
							Uint8 check=0;
							while (!check)
							{
								check =1;
    10a2:	11 e0       	ldi	r17, 0x01	; 1
    10a4:	85 c0       	rjmp	.+266    	; 0x11b0 <__stack+0x951>
												LCD_Write_String("LAMP IS ON");
												_delay_ms(2000);
											}
											else
											{
												LCD_Clear();
    10a6:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
												LCD_Write_String("LAMP IS OFF");
    10aa:	86 e6       	ldi	r24, 0x66	; 102
    10ac:	92 e0       	ldi	r25, 0x02	; 2
    10ae:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
    10b2:	2f ef       	ldi	r18, 0xFF	; 255
    10b4:	87 ea       	ldi	r24, 0xA7	; 167
    10b6:	91 e6       	ldi	r25, 0x61	; 97
    10b8:	21 50       	subi	r18, 0x01	; 1
    10ba:	80 40       	sbci	r24, 0x00	; 0
    10bc:	90 40       	sbci	r25, 0x00	; 0
    10be:	e1 f7       	brne	.-8      	; 0x10b8 <__stack+0x859>
    10c0:	00 c0       	rjmp	.+0      	; 0x10c2 <__stack+0x863>
    10c2:	00 00       	nop
						case '2' :
						{
							Uint8 check=0;
							while (!check)
							{
								check =1;
    10c4:	11 e0       	ldi	r17, 0x01	; 1
    10c6:	74 c0       	rjmp	.+232    	; 0x11b0 <__stack+0x951>
											}
											break;
										}//end of case 2
										case '3' :
										{
											if (Flag_Lamp_3==1)
    10c8:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <Flag_Lamp_3>
    10cc:	81 30       	cpi	r24, 0x01	; 1
    10ce:	89 f4       	brne	.+34     	; 0x10f2 <__stack+0x893>
											{
												LCD_Clear();
    10d0:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
												LCD_Write_String("LAMP IS ON");
    10d4:	8b e5       	ldi	r24, 0x5B	; 91
    10d6:	92 e0       	ldi	r25, 0x02	; 2
    10d8:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
    10dc:	2f ef       	ldi	r18, 0xFF	; 255
    10de:	87 ea       	ldi	r24, 0xA7	; 167
    10e0:	91 e6       	ldi	r25, 0x61	; 97
    10e2:	21 50       	subi	r18, 0x01	; 1
    10e4:	80 40       	sbci	r24, 0x00	; 0
    10e6:	90 40       	sbci	r25, 0x00	; 0
    10e8:	e1 f7       	brne	.-8      	; 0x10e2 <__stack+0x883>
    10ea:	00 c0       	rjmp	.+0      	; 0x10ec <__stack+0x88d>
    10ec:	00 00       	nop
						case '2' :
						{
							Uint8 check=0;
							while (!check)
							{
								check =1;
    10ee:	11 e0       	ldi	r17, 0x01	; 1
    10f0:	5f c0       	rjmp	.+190    	; 0x11b0 <__stack+0x951>
												LCD_Write_String("LAMP IS ON");
												_delay_ms(2000);
											}
											else
											{
												LCD_Clear();
    10f2:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
												LCD_Write_String("LAMP IS OFF");
    10f6:	86 e6       	ldi	r24, 0x66	; 102
    10f8:	92 e0       	ldi	r25, 0x02	; 2
    10fa:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
    10fe:	2f ef       	ldi	r18, 0xFF	; 255
    1100:	87 ea       	ldi	r24, 0xA7	; 167
    1102:	91 e6       	ldi	r25, 0x61	; 97
    1104:	21 50       	subi	r18, 0x01	; 1
    1106:	80 40       	sbci	r24, 0x00	; 0
    1108:	90 40       	sbci	r25, 0x00	; 0
    110a:	e1 f7       	brne	.-8      	; 0x1104 <__stack+0x8a5>
    110c:	00 c0       	rjmp	.+0      	; 0x110e <__stack+0x8af>
    110e:	00 00       	nop
						case '2' :
						{
							Uint8 check=0;
							while (!check)
							{
								check =1;
    1110:	11 e0       	ldi	r17, 0x01	; 1
    1112:	4e c0       	rjmp	.+156    	; 0x11b0 <__stack+0x951>
											}
											break;
										}//end of case 3
										case '4' :
										{
											LCD_Clear();
    1114:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
											LCD_Write_String("5.Room 4");
    1118:	82 e7       	ldi	r24, 0x72	; 114
    111a:	92 e0       	ldi	r25, 0x02	; 2
    111c:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
											LCD_Goto(1,0);
    1120:	60 e0       	ldi	r22, 0x00	; 0
    1122:	81 e0       	ldi	r24, 0x01	; 1
    1124:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
											LCD_Write_String("6.Back");
    1128:	8b e7       	ldi	r24, 0x7B	; 123
    112a:	92 e0       	ldi	r25, 0x02	; 2
    112c:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
											Button_Flag=NULL_KEYPAD;
    1130:	80 e0       	ldi	r24, 0x00	; 0
											while(Button_Flag==NULL_KEYPAD)
    1132:	03 c0       	rjmp	.+6      	; 0x113a <__stack+0x8db>
											{
												Button_Flag=Keypad_GetValue();
    1134:	0e 94 aa 09 	call	0x1354	; 0x1354 <Keypad_GetValue>
												Flag = Button_Flag;
    1138:	f8 2e       	mov	r15, r24
											LCD_Clear();
											LCD_Write_String("5.Room 4");
											LCD_Goto(1,0);
											LCD_Write_String("6.Back");
											Button_Flag=NULL_KEYPAD;
											while(Button_Flag==NULL_KEYPAD)
    113a:	88 23       	and	r24, r24
    113c:	d9 f3       	breq	.-10     	; 0x1134 <__stack+0x8d5>
											{
												Button_Flag=Keypad_GetValue();
												Flag = Button_Flag;
											}
											if ( Flag=='5' || Flag=='6' )
    113e:	8b ec       	ldi	r24, 0xCB	; 203
    1140:	8f 0d       	add	r24, r15
    1142:	82 30       	cpi	r24, 0x02	; 2
    1144:	90 f5       	brcc	.+100    	; 0x11aa <__stack+0x94b>
											{
												switch (Flag)
    1146:	25 e3       	ldi	r18, 0x35	; 53
    1148:	f2 16       	cp	r15, r18
    114a:	29 f0       	breq	.+10     	; 0x1156 <__stack+0x8f7>
    114c:	86 e3       	ldi	r24, 0x36	; 54
    114e:	f8 16       	cp	r15, r24
    1150:	79 f1       	breq	.+94     	; 0x11b0 <__stack+0x951>
						case '2' :
						{
							Uint8 check=0;
							while (!check)
							{
								check =1;
    1152:	11 e0       	ldi	r17, 0x01	; 1
    1154:	2d c0       	rjmp	.+90     	; 0x11b0 <__stack+0x951>
											{
												switch (Flag)
												{
													case'5':
													{
														if (Flag_Lamp_4==1)
    1156:	80 91 14 08 	lds	r24, 0x0814	; 0x800814 <Flag_Lamp_4>
    115a:	81 30       	cpi	r24, 0x01	; 1
    115c:	89 f4       	brne	.+34     	; 0x1180 <__stack+0x921>
														{
															LCD_Clear();
    115e:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
															LCD_Write_String("LAMP IS ON");
    1162:	8b e5       	ldi	r24, 0x5B	; 91
    1164:	92 e0       	ldi	r25, 0x02	; 2
    1166:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
    116a:	9f ef       	ldi	r25, 0xFF	; 255
    116c:	27 ea       	ldi	r18, 0xA7	; 167
    116e:	81 e6       	ldi	r24, 0x61	; 97
    1170:	91 50       	subi	r25, 0x01	; 1
    1172:	20 40       	sbci	r18, 0x00	; 0
    1174:	80 40       	sbci	r24, 0x00	; 0
    1176:	e1 f7       	brne	.-8      	; 0x1170 <__stack+0x911>
    1178:	00 c0       	rjmp	.+0      	; 0x117a <__stack+0x91b>
    117a:	00 00       	nop
						case '2' :
						{
							Uint8 check=0;
							while (!check)
							{
								check =1;
    117c:	11 e0       	ldi	r17, 0x01	; 1
    117e:	18 c0       	rjmp	.+48     	; 0x11b0 <__stack+0x951>
															LCD_Write_String("LAMP IS ON");
															_delay_ms(2000);
														}
														else
														{
															LCD_Clear();
    1180:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
															LCD_Write_String("LAMP IS OFF");
    1184:	86 e6       	ldi	r24, 0x66	; 102
    1186:	92 e0       	ldi	r25, 0x02	; 2
    1188:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
    118c:	9f ef       	ldi	r25, 0xFF	; 255
    118e:	27 ea       	ldi	r18, 0xA7	; 167
    1190:	81 e6       	ldi	r24, 0x61	; 97
    1192:	91 50       	subi	r25, 0x01	; 1
    1194:	20 40       	sbci	r18, 0x00	; 0
    1196:	80 40       	sbci	r24, 0x00	; 0
    1198:	e1 f7       	brne	.-8      	; 0x1192 <__stack+0x933>
    119a:	00 c0       	rjmp	.+0      	; 0x119c <__stack+0x93d>
    119c:	00 00       	nop
						case '2' :
						{
							Uint8 check=0;
							while (!check)
							{
								check =1;
    119e:	11 e0       	ldi	r17, 0x01	; 1
    11a0:	07 c0       	rjmp	.+14     	; 0x11b0 <__stack+0x951>
    11a2:	11 e0       	ldi	r17, 0x01	; 1
    11a4:	05 c0       	rjmp	.+10     	; 0x11b0 <__stack+0x951>
    11a6:	11 e0       	ldi	r17, 0x01	; 1
    11a8:	03 c0       	rjmp	.+6      	; 0x11b0 <__stack+0x951>
    11aa:	11 e0       	ldi	r17, 0x01	; 1
    11ac:	01 c0       	rjmp	.+2      	; 0x11b0 <__stack+0x951>
					Button_Flag=Keypad_GetValue();
					Flag = Button_Flag;
				}
				if (Flag=='1'|| Flag=='2')
				{
					switch(Flag)
    11ae:	10 e0       	ldi	r17, 0x00	; 0
							break;
						}// end of case 1
						case '2' :
						{
							Uint8 check=0;
							while (!check)
    11b0:	11 23       	and	r17, r17
    11b2:	09 f4       	brne	.+2      	; 0x11b6 <__stack+0x957>
    11b4:	01 cf       	rjmp	.-510    	; 0xfb8 <__stack+0x759>
    11b6:	01 c0       	rjmp	.+2      	; 0x11ba <__stack+0x95b>
								
						}//End of switch case
						
						if (Deny_var==0)
						{
							 Flag=0;
    11b8:	f1 2c       	mov	r15, r1




/* Printing Welcome screen */
while(!Deny_var) 
    11ba:	dd 20       	and	r13, r13
    11bc:	09 f4       	brne	.+2      	; 0x11c0 <__stack+0x961>
    11be:	af ca       	rjmp	.-2722   	; 0x71e <LCD_LogIN_system+0xb2>




	
}
    11c0:	2c 96       	adiw	r28, 0x0c	; 12
    11c2:	0f b6       	in	r0, 0x3f	; 63
    11c4:	f8 94       	cli
    11c6:	de bf       	out	0x3e, r29	; 62
    11c8:	0f be       	out	0x3f, r0	; 63
    11ca:	cd bf       	out	0x3d, r28	; 61
    11cc:	df 91       	pop	r29
    11ce:	cf 91       	pop	r28
    11d0:	1f 91       	pop	r17
    11d2:	0f 91       	pop	r16
    11d4:	ff 90       	pop	r15
    11d6:	ef 90       	pop	r14
    11d8:	df 90       	pop	r13
    11da:	cf 90       	pop	r12
    11dc:	bf 90       	pop	r11
    11de:	af 90       	pop	r10
    11e0:	08 95       	ret

000011e2 <__vector_1>:
ISR(INT0_vect)
{
    11e2:	1f 92       	push	r1
    11e4:	0f 92       	push	r0
    11e6:	0f b6       	in	r0, 0x3f	; 63
    11e8:	0f 92       	push	r0
    11ea:	11 24       	eor	r1, r1
    11ec:	2f 93       	push	r18
    11ee:	3f 93       	push	r19
    11f0:	4f 93       	push	r20
    11f2:	5f 93       	push	r21
    11f4:	6f 93       	push	r22
    11f6:	7f 93       	push	r23
    11f8:	8f 93       	push	r24
    11fa:	9f 93       	push	r25
    11fc:	af 93       	push	r26
    11fe:	bf 93       	push	r27
    1200:	ef 93       	push	r30
    1202:	ff 93       	push	r31
	LCD_LogIN_system();	
    1204:	0e 94 36 03 	call	0x66c	; 0x66c <LCD_LogIN_system>
	LCD_Clear();
    1208:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
	LCD_Write_String("Press the button");
    120c:	82 e8       	ldi	r24, 0x82	; 130
    120e:	92 e0       	ldi	r25, 0x02	; 2
    1210:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
	LCD_Goto(1,0);
    1214:	60 e0       	ldi	r22, 0x00	; 0
    1216:	81 e0       	ldi	r24, 0x01	; 1
    1218:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
	LCD_Write_String("to start");
    121c:	83 e9       	ldi	r24, 0x93	; 147
    121e:	92 e0       	ldi	r25, 0x02	; 2
    1220:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
	
 }//End Of ISR
    1224:	ff 91       	pop	r31
    1226:	ef 91       	pop	r30
    1228:	bf 91       	pop	r27
    122a:	af 91       	pop	r26
    122c:	9f 91       	pop	r25
    122e:	8f 91       	pop	r24
    1230:	7f 91       	pop	r23
    1232:	6f 91       	pop	r22
    1234:	5f 91       	pop	r21
    1236:	4f 91       	pop	r20
    1238:	3f 91       	pop	r19
    123a:	2f 91       	pop	r18
    123c:	0f 90       	pop	r0
    123e:	0f be       	out	0x3f, r0	; 63
    1240:	0f 90       	pop	r0
    1242:	1f 90       	pop	r1
    1244:	18 95       	reti

00001246 <I2C_INIT>:
// 	{
// 		(*pptr0)();
// 		(*pptr1)(string16);
// 	}
	return TWDR;
}
    1246:	80 e8       	ldi	r24, 0x80	; 128
    1248:	8f bf       	out	0x3f, r24	; 63
    124a:	85 e0       	ldi	r24, 0x05	; 5
    124c:	86 bf       	out	0x36, r24	; 54
    124e:	8c e0       	ldi	r24, 0x0C	; 12
    1250:	80 b9       	out	0x00, r24	; 0
    1252:	11 b8       	out	0x01, r1	; 1
    1254:	08 95       	ret

00001256 <I2C_SendStartCond>:
    1256:	84 ea       	ldi	r24, 0xA4	; 164
    1258:	86 bf       	out	0x36, r24	; 54
    125a:	06 b6       	in	r0, 0x36	; 54
    125c:	07 fe       	sbrs	r0, 7
    125e:	fd cf       	rjmp	.-6      	; 0x125a <I2C_SendStartCond+0x4>
    1260:	08 95       	ret

00001262 <I2C_SendRepStartCond>:
    1262:	84 ea       	ldi	r24, 0xA4	; 164
    1264:	86 bf       	out	0x36, r24	; 54
    1266:	06 b6       	in	r0, 0x36	; 54
    1268:	07 fe       	sbrs	r0, 7
    126a:	fd cf       	rjmp	.-6      	; 0x1266 <I2C_SendRepStartCond+0x4>
    126c:	08 95       	ret

0000126e <I2C_SendSlaveAdd_WriteOP>:
    126e:	88 0f       	add	r24, r24
    1270:	83 b9       	out	0x03, r24	; 3
    1272:	84 e8       	ldi	r24, 0x84	; 132
    1274:	86 bf       	out	0x36, r24	; 54
    1276:	06 b6       	in	r0, 0x36	; 54
    1278:	07 fe       	sbrs	r0, 7
    127a:	fd cf       	rjmp	.-6      	; 0x1276 <I2C_SendSlaveAdd_WriteOP+0x8>
    127c:	2f ef       	ldi	r18, 0xFF	; 255
    127e:	81 ee       	ldi	r24, 0xE1	; 225
    1280:	94 e0       	ldi	r25, 0x04	; 4
    1282:	21 50       	subi	r18, 0x01	; 1
    1284:	80 40       	sbci	r24, 0x00	; 0
    1286:	90 40       	sbci	r25, 0x00	; 0
    1288:	e1 f7       	brne	.-8      	; 0x1282 <I2C_SendSlaveAdd_WriteOP+0x14>
    128a:	00 c0       	rjmp	.+0      	; 0x128c <I2C_SendSlaveAdd_WriteOP+0x1e>
    128c:	00 00       	nop
    128e:	08 95       	ret

00001290 <I2C_SendSlaveAdd_ReadOP>:
    1290:	90 e0       	ldi	r25, 0x00	; 0
    1292:	88 0f       	add	r24, r24
    1294:	99 1f       	adc	r25, r25
    1296:	81 60       	ori	r24, 0x01	; 1
    1298:	83 b9       	out	0x03, r24	; 3
    129a:	84 e8       	ldi	r24, 0x84	; 132
    129c:	86 bf       	out	0x36, r24	; 54
    129e:	06 b6       	in	r0, 0x36	; 54
    12a0:	07 fe       	sbrs	r0, 7
    12a2:	fd cf       	rjmp	.-6      	; 0x129e <I2C_SendSlaveAdd_ReadOP+0xe>
    12a4:	08 95       	ret

000012a6 <I2C_SendData>:
    12a6:	83 b9       	out	0x03, r24	; 3
    12a8:	84 e8       	ldi	r24, 0x84	; 132
    12aa:	86 bf       	out	0x36, r24	; 54
    12ac:	06 b6       	in	r0, 0x36	; 54
    12ae:	07 fe       	sbrs	r0, 7
    12b0:	fd cf       	rjmp	.-6      	; 0x12ac <I2C_SendData+0x6>
    12b2:	08 95       	ret

000012b4 <I2C_ReadData>:
    12b4:	84 e8       	ldi	r24, 0x84	; 132
    12b6:	86 bf       	out	0x36, r24	; 54
    12b8:	06 b6       	in	r0, 0x36	; 54
    12ba:	07 fe       	sbrs	r0, 7
    12bc:	fd cf       	rjmp	.-6      	; 0x12b8 <I2C_ReadData+0x4>
    12be:	83 b1       	in	r24, 0x03	; 3
    12c0:	08 95       	ret

000012c2 <I2C_SendStopCond>:

void I2C_SendStopCond(void)
{
	TWCR = (1<<TWSTO)|(1<<TWEN)|(1<<TWINT);
    12c2:	84 e9       	ldi	r24, 0x94	; 148
    12c4:	86 bf       	out	0x36, r24	; 54
	Set_Bit(TWCR, 7);
    12c6:	86 b7       	in	r24, 0x36	; 54
    12c8:	80 68       	ori	r24, 0x80	; 128
    12ca:	86 bf       	out	0x36, r24	; 54
    12cc:	08 95       	ret

000012ce <Keypad_Init>:
			       {'7','8','9'},
			       {'*','0','#'}}; 	   	   	

void Keypad_Init()
{
	DIO_SetPin_Dir(Keypad_Row_Port, Keypad_Row_PIN_0, PIN_IN);
    12ce:	40 e0       	ldi	r20, 0x00	; 0
    12d0:	63 e0       	ldi	r22, 0x03	; 3
    12d2:	80 e0       	ldi	r24, 0x00	; 0
    12d4:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
	DIO_SetPin_Dir(Keypad_Row_Port, Keypad_Row_PIN_1, PIN_IN);
    12d8:	40 e0       	ldi	r20, 0x00	; 0
    12da:	64 e0       	ldi	r22, 0x04	; 4
    12dc:	80 e0       	ldi	r24, 0x00	; 0
    12de:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
	DIO_SetPin_Dir(Keypad_Row_Port, Keypad_Row_PIN_2, PIN_IN);
    12e2:	40 e0       	ldi	r20, 0x00	; 0
    12e4:	65 e0       	ldi	r22, 0x05	; 5
    12e6:	80 e0       	ldi	r24, 0x00	; 0
    12e8:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
	DIO_SetPin_Dir(Keypad_Row_Port, Keypad_Row_PIN_3, PIN_IN);
    12ec:	40 e0       	ldi	r20, 0x00	; 0
    12ee:	66 e0       	ldi	r22, 0x06	; 6
    12f0:	80 e0       	ldi	r24, 0x00	; 0
    12f2:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
	
	DIO_SetPin_Pullup(Keypad_Row_Port, Keypad_Row_PIN_0);
    12f6:	63 e0       	ldi	r22, 0x03	; 3
    12f8:	80 e0       	ldi	r24, 0x00	; 0
    12fa:	0e 94 b1 02 	call	0x562	; 0x562 <DIO_SetPin_Pullup>
	DIO_SetPin_Pullup(Keypad_Row_Port, Keypad_Row_PIN_1);
    12fe:	64 e0       	ldi	r22, 0x04	; 4
    1300:	80 e0       	ldi	r24, 0x00	; 0
    1302:	0e 94 b1 02 	call	0x562	; 0x562 <DIO_SetPin_Pullup>
	DIO_SetPin_Pullup(Keypad_Row_Port, Keypad_Row_PIN_2);
    1306:	65 e0       	ldi	r22, 0x05	; 5
    1308:	80 e0       	ldi	r24, 0x00	; 0
    130a:	0e 94 b1 02 	call	0x562	; 0x562 <DIO_SetPin_Pullup>
	DIO_SetPin_Pullup(Keypad_Row_Port, Keypad_Row_PIN_3);
    130e:	66 e0       	ldi	r22, 0x06	; 6
    1310:	80 e0       	ldi	r24, 0x00	; 0
    1312:	0e 94 b1 02 	call	0x562	; 0x562 <DIO_SetPin_Pullup>
	
	DIO_SetPin_Dir(Keypad_Column_Port, Keypad_Column_PIN_0, PIN_OUT);
    1316:	41 e0       	ldi	r20, 0x01	; 1
    1318:	60 e0       	ldi	r22, 0x00	; 0
    131a:	81 e0       	ldi	r24, 0x01	; 1
    131c:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
	DIO_SetPin_Dir(Keypad_Column_Port, Keypad_Column_PIN_1, PIN_OUT);
    1320:	41 e0       	ldi	r20, 0x01	; 1
    1322:	61 e0       	ldi	r22, 0x01	; 1
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
	DIO_SetPin_Dir(Keypad_Column_Port, Keypad_Column_PIN_2, PIN_OUT);
    132a:	41 e0       	ldi	r20, 0x01	; 1
    132c:	62 e0       	ldi	r22, 0x02	; 2
    132e:	81 e0       	ldi	r24, 0x01	; 1
    1330:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
	//DIO_SetPin_Dir(Keypad_Column_Port, Keypad_Column_PIN_3, PIN_OUT);
	
	DIO_SetPin_Value(Keypad_Column_Port, Keypad_Column_PIN_0, PIN_ON);
    1334:	40 e0       	ldi	r20, 0x00	; 0
    1336:	60 e0       	ldi	r22, 0x00	; 0
    1338:	81 e0       	ldi	r24, 0x01	; 1
    133a:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
	DIO_SetPin_Value(Keypad_Column_Port, Keypad_Column_PIN_1, PIN_ON);
    133e:	40 e0       	ldi	r20, 0x00	; 0
    1340:	61 e0       	ldi	r22, 0x01	; 1
    1342:	81 e0       	ldi	r24, 0x01	; 1
    1344:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
	DIO_SetPin_Value(Keypad_Column_Port, Keypad_Column_PIN_2, PIN_ON);
    1348:	40 e0       	ldi	r20, 0x00	; 0
    134a:	62 e0       	ldi	r22, 0x02	; 2
    134c:	81 e0       	ldi	r24, 0x01	; 1
    134e:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    1352:	08 95       	ret

00001354 <Keypad_GetValue>:
	//DIO_SetPin_Value(Keypad_Column_Port, Keypad_Column_PIN_3, PIN_ON);
}

Uint8 Keypad_GetValue()
{
    1354:	1f 93       	push	r17
    1356:	cf 93       	push	r28
    1358:	df 93       	push	r29
	Uint8 Value = 0;
	
	for(Uint8 i = Keypad_Column_PIN_0; i <= Keypad_Column_PIN_2; i++)
    135a:	d0 e0       	ldi	r29, 0x00	; 0
	//DIO_SetPin_Value(Keypad_Column_Port, Keypad_Column_PIN_3, PIN_ON);
}

Uint8 Keypad_GetValue()
{
	Uint8 Value = 0;
    135c:	10 e0       	ldi	r17, 0x00	; 0
	
	for(Uint8 i = Keypad_Column_PIN_0; i <= Keypad_Column_PIN_2; i++)
    135e:	29 c0       	rjmp	.+82     	; 0x13b2 <Keypad_GetValue+0x5e>
	{
		DIO_SetPin_Value(Keypad_Column_Port, i, PIN_OFF);
    1360:	41 e0       	ldi	r20, 0x01	; 1
    1362:	6d 2f       	mov	r22, r29
    1364:	81 e0       	ldi	r24, 0x01	; 1
    1366:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
		for(Uint8 j = Keypad_Row_PIN_0; j <= Keypad_Row_PIN_3; j++)
    136a:	c3 e0       	ldi	r28, 0x03	; 3
    136c:	1a c0       	rjmp	.+52     	; 0x13a2 <Keypad_GetValue+0x4e>
		{
			if(!DIO_GetPin_Value(Keypad_Row_Port, j))
    136e:	6c 2f       	mov	r22, r28
    1370:	80 e0       	ldi	r24, 0x00	; 0
    1372:	0e 94 4f 02 	call	0x49e	; 0x49e <DIO_GetPin_Value>
    1376:	81 11       	cpse	r24, r1
    1378:	13 c0       	rjmp	.+38     	; 0x13a0 <Keypad_GetValue+0x4c>
			{
				Value = arr[j-Keypad_Row_PIN_0][i-Keypad_Column_PIN_0];
    137a:	8c 2f       	mov	r24, r28
    137c:	90 e0       	ldi	r25, 0x00	; 0
    137e:	03 97       	sbiw	r24, 0x03	; 3
    1380:	fc 01       	movw	r30, r24
    1382:	ee 0f       	add	r30, r30
    1384:	ff 1f       	adc	r31, r31
    1386:	e8 0f       	add	r30, r24
    1388:	f9 1f       	adc	r31, r25
    138a:	ef 59       	subi	r30, 0x9F	; 159
    138c:	ff 4f       	sbci	r31, 0xFF	; 255
    138e:	ed 0f       	add	r30, r29
    1390:	f1 1d       	adc	r31, r1
    1392:	10 81       	ld	r17, Z
				while(!DIO_GetPin_Value(Keypad_Row_Port, j));
    1394:	6c 2f       	mov	r22, r28
    1396:	80 e0       	ldi	r24, 0x00	; 0
    1398:	0e 94 4f 02 	call	0x49e	; 0x49e <DIO_GetPin_Value>
    139c:	88 23       	and	r24, r24
    139e:	d1 f3       	breq	.-12     	; 0x1394 <Keypad_GetValue+0x40>
	Uint8 Value = 0;
	
	for(Uint8 i = Keypad_Column_PIN_0; i <= Keypad_Column_PIN_2; i++)
	{
		DIO_SetPin_Value(Keypad_Column_Port, i, PIN_OFF);
		for(Uint8 j = Keypad_Row_PIN_0; j <= Keypad_Row_PIN_3; j++)
    13a0:	cf 5f       	subi	r28, 0xFF	; 255
    13a2:	c7 30       	cpi	r28, 0x07	; 7
    13a4:	20 f3       	brcs	.-56     	; 0x136e <Keypad_GetValue+0x1a>
			{
				Value = arr[j-Keypad_Row_PIN_0][i-Keypad_Column_PIN_0];
				while(!DIO_GetPin_Value(Keypad_Row_Port, j));
			} 
		}
		DIO_SetPin_Value(Keypad_Column_Port, i, PIN_ON);
    13a6:	40 e0       	ldi	r20, 0x00	; 0
    13a8:	6d 2f       	mov	r22, r29
    13aa:	81 e0       	ldi	r24, 0x01	; 1
    13ac:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>

Uint8 Keypad_GetValue()
{
	Uint8 Value = 0;
	
	for(Uint8 i = Keypad_Column_PIN_0; i <= Keypad_Column_PIN_2; i++)
    13b0:	df 5f       	subi	r29, 0xFF	; 255
    13b2:	d3 30       	cpi	r29, 0x03	; 3
    13b4:	a8 f2       	brcs	.-86     	; 0x1360 <Keypad_GetValue+0xc>
			} 
		}
		DIO_SetPin_Value(Keypad_Column_Port, i, PIN_ON);
	}
	return Value;
    13b6:	81 2f       	mov	r24, r17
    13b8:	df 91       	pop	r29
    13ba:	cf 91       	pop	r28
    13bc:	1f 91       	pop	r17
    13be:	08 95       	ret

000013c0 <LCD_Write_CMD>:
		data *= 10;
		num = data;
		LCD_Write_Char(num + 48);
		data -= num;
	}
}
    13c0:	cf 93       	push	r28
    13c2:	c8 2f       	mov	r28, r24
    13c4:	41 e0       	ldi	r20, 0x01	; 1
    13c6:	60 e0       	ldi	r22, 0x00	; 0
    13c8:	80 e0       	ldi	r24, 0x00	; 0
    13ca:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    13ce:	41 e0       	ldi	r20, 0x01	; 1
    13d0:	61 e0       	ldi	r22, 0x01	; 1
    13d2:	80 e0       	ldi	r24, 0x00	; 0
    13d4:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    13d8:	41 e0       	ldi	r20, 0x01	; 1
    13da:	62 e0       	ldi	r22, 0x02	; 2
    13dc:	80 e0       	ldi	r24, 0x00	; 0
    13de:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    13e2:	88 b3       	in	r24, 0x18	; 24
    13e4:	9c 2f       	mov	r25, r28
    13e6:	90 7f       	andi	r25, 0xF0	; 240
    13e8:	8f 70       	andi	r24, 0x0F	; 15
    13ea:	89 2b       	or	r24, r25
    13ec:	88 bb       	out	0x18, r24	; 24
    13ee:	40 e0       	ldi	r20, 0x00	; 0
    13f0:	62 e0       	ldi	r22, 0x02	; 2
    13f2:	80 e0       	ldi	r24, 0x00	; 0
    13f4:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    13f8:	8f e9       	ldi	r24, 0x9F	; 159
    13fa:	9f e0       	ldi	r25, 0x0F	; 15
    13fc:	01 97       	sbiw	r24, 0x01	; 1
    13fe:	f1 f7       	brne	.-4      	; 0x13fc <LCD_Write_CMD+0x3c>
    1400:	00 c0       	rjmp	.+0      	; 0x1402 <LCD_Write_CMD+0x42>
    1402:	00 00       	nop
    1404:	41 e0       	ldi	r20, 0x01	; 1
    1406:	62 e0       	ldi	r22, 0x02	; 2
    1408:	80 e0       	ldi	r24, 0x00	; 0
    140a:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    140e:	20 e1       	ldi	r18, 0x10	; 16
    1410:	c2 9f       	mul	r28, r18
    1412:	c0 01       	movw	r24, r0
    1414:	11 24       	eor	r1, r1
    1416:	98 b3       	in	r25, 0x18	; 24
    1418:	9f 70       	andi	r25, 0x0F	; 15
    141a:	89 2b       	or	r24, r25
    141c:	88 bb       	out	0x18, r24	; 24
    141e:	40 e0       	ldi	r20, 0x00	; 0
    1420:	62 e0       	ldi	r22, 0x02	; 2
    1422:	80 e0       	ldi	r24, 0x00	; 0
    1424:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    1428:	8f e9       	ldi	r24, 0x9F	; 159
    142a:	9f e0       	ldi	r25, 0x0F	; 15
    142c:	01 97       	sbiw	r24, 0x01	; 1
    142e:	f1 f7       	brne	.-4      	; 0x142c <LCD_Write_CMD+0x6c>
    1430:	00 c0       	rjmp	.+0      	; 0x1432 <LCD_Write_CMD+0x72>
    1432:	00 00       	nop
    1434:	41 e0       	ldi	r20, 0x01	; 1
    1436:	62 e0       	ldi	r22, 0x02	; 2
    1438:	80 e0       	ldi	r24, 0x00	; 0
    143a:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    143e:	8f e1       	ldi	r24, 0x1F	; 31
    1440:	9e e4       	ldi	r25, 0x4E	; 78
    1442:	01 97       	sbiw	r24, 0x01	; 1
    1444:	f1 f7       	brne	.-4      	; 0x1442 <LCD_Write_CMD+0x82>
    1446:	00 c0       	rjmp	.+0      	; 0x1448 <LCD_Write_CMD+0x88>
    1448:	00 00       	nop
    144a:	cf 91       	pop	r28
    144c:	08 95       	ret

0000144e <LCD_Init>:
    144e:	41 e0       	ldi	r20, 0x01	; 1
    1450:	60 e0       	ldi	r22, 0x00	; 0
    1452:	80 e0       	ldi	r24, 0x00	; 0
    1454:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    1458:	41 e0       	ldi	r20, 0x01	; 1
    145a:	61 e0       	ldi	r22, 0x01	; 1
    145c:	80 e0       	ldi	r24, 0x00	; 0
    145e:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    1462:	41 e0       	ldi	r20, 0x01	; 1
    1464:	62 e0       	ldi	r22, 0x02	; 2
    1466:	80 e0       	ldi	r24, 0x00	; 0
    1468:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    146c:	41 e0       	ldi	r20, 0x01	; 1
    146e:	64 e0       	ldi	r22, 0x04	; 4
    1470:	81 e0       	ldi	r24, 0x01	; 1
    1472:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    1476:	41 e0       	ldi	r20, 0x01	; 1
    1478:	65 e0       	ldi	r22, 0x05	; 5
    147a:	81 e0       	ldi	r24, 0x01	; 1
    147c:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    1480:	41 e0       	ldi	r20, 0x01	; 1
    1482:	66 e0       	ldi	r22, 0x06	; 6
    1484:	81 e0       	ldi	r24, 0x01	; 1
    1486:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    148a:	41 e0       	ldi	r20, 0x01	; 1
    148c:	67 e0       	ldi	r22, 0x07	; 7
    148e:	81 e0       	ldi	r24, 0x01	; 1
    1490:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    1494:	41 e0       	ldi	r20, 0x01	; 1
    1496:	60 e0       	ldi	r22, 0x00	; 0
    1498:	80 e0       	ldi	r24, 0x00	; 0
    149a:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    149e:	41 e0       	ldi	r20, 0x01	; 1
    14a0:	61 e0       	ldi	r22, 0x01	; 1
    14a2:	80 e0       	ldi	r24, 0x00	; 0
    14a4:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    14a8:	41 e0       	ldi	r20, 0x01	; 1
    14aa:	62 e0       	ldi	r22, 0x02	; 2
    14ac:	80 e0       	ldi	r24, 0x00	; 0
    14ae:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    14b2:	41 e0       	ldi	r20, 0x01	; 1
    14b4:	64 e0       	ldi	r22, 0x04	; 4
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    14bc:	41 e0       	ldi	r20, 0x01	; 1
    14be:	65 e0       	ldi	r22, 0x05	; 5
    14c0:	81 e0       	ldi	r24, 0x01	; 1
    14c2:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    14c6:	41 e0       	ldi	r20, 0x01	; 1
    14c8:	66 e0       	ldi	r22, 0x06	; 6
    14ca:	81 e0       	ldi	r24, 0x01	; 1
    14cc:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    14d0:	41 e0       	ldi	r20, 0x01	; 1
    14d2:	67 e0       	ldi	r22, 0x07	; 7
    14d4:	81 e0       	ldi	r24, 0x01	; 1
    14d6:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    14da:	2f ef       	ldi	r18, 0xFF	; 255
    14dc:	81 ee       	ldi	r24, 0xE1	; 225
    14de:	94 e0       	ldi	r25, 0x04	; 4
    14e0:	21 50       	subi	r18, 0x01	; 1
    14e2:	80 40       	sbci	r24, 0x00	; 0
    14e4:	90 40       	sbci	r25, 0x00	; 0
    14e6:	e1 f7       	brne	.-8      	; 0x14e0 <LCD_Init+0x92>
    14e8:	00 c0       	rjmp	.+0      	; 0x14ea <LCD_Init+0x9c>
    14ea:	00 00       	nop
    14ec:	83 e3       	ldi	r24, 0x33	; 51
    14ee:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <LCD_Write_CMD>
    14f2:	82 e3       	ldi	r24, 0x32	; 50
    14f4:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <LCD_Write_CMD>
    14f8:	88 e2       	ldi	r24, 0x28	; 40
    14fa:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <LCD_Write_CMD>
    14fe:	81 e0       	ldi	r24, 0x01	; 1
    1500:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <LCD_Write_CMD>
    1504:	82 e0       	ldi	r24, 0x02	; 2
    1506:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <LCD_Write_CMD>
    150a:	86 e0       	ldi	r24, 0x06	; 6
    150c:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <LCD_Write_CMD>
    1510:	8e e0       	ldi	r24, 0x0E	; 14
    1512:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <LCD_Write_CMD>
    1516:	08 95       	ret

00001518 <LCD_Write_Char>:
    1518:	cf 93       	push	r28
    151a:	c8 2f       	mov	r28, r24
    151c:	40 e0       	ldi	r20, 0x00	; 0
    151e:	60 e0       	ldi	r22, 0x00	; 0
    1520:	80 e0       	ldi	r24, 0x00	; 0
    1522:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    1526:	41 e0       	ldi	r20, 0x01	; 1
    1528:	61 e0       	ldi	r22, 0x01	; 1
    152a:	80 e0       	ldi	r24, 0x00	; 0
    152c:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    1530:	41 e0       	ldi	r20, 0x01	; 1
    1532:	62 e0       	ldi	r22, 0x02	; 2
    1534:	80 e0       	ldi	r24, 0x00	; 0
    1536:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    153a:	88 b3       	in	r24, 0x18	; 24
    153c:	9c 2f       	mov	r25, r28
    153e:	90 7f       	andi	r25, 0xF0	; 240
    1540:	8f 70       	andi	r24, 0x0F	; 15
    1542:	89 2b       	or	r24, r25
    1544:	88 bb       	out	0x18, r24	; 24
    1546:	40 e0       	ldi	r20, 0x00	; 0
    1548:	62 e0       	ldi	r22, 0x02	; 2
    154a:	80 e0       	ldi	r24, 0x00	; 0
    154c:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    1550:	8f e9       	ldi	r24, 0x9F	; 159
    1552:	9f e0       	ldi	r25, 0x0F	; 15
    1554:	01 97       	sbiw	r24, 0x01	; 1
    1556:	f1 f7       	brne	.-4      	; 0x1554 <LCD_Write_Char+0x3c>
    1558:	00 c0       	rjmp	.+0      	; 0x155a <LCD_Write_Char+0x42>
    155a:	00 00       	nop
    155c:	41 e0       	ldi	r20, 0x01	; 1
    155e:	62 e0       	ldi	r22, 0x02	; 2
    1560:	80 e0       	ldi	r24, 0x00	; 0
    1562:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    1566:	20 e1       	ldi	r18, 0x10	; 16
    1568:	c2 9f       	mul	r28, r18
    156a:	c0 01       	movw	r24, r0
    156c:	11 24       	eor	r1, r1
    156e:	98 b3       	in	r25, 0x18	; 24
    1570:	9f 70       	andi	r25, 0x0F	; 15
    1572:	89 2b       	or	r24, r25
    1574:	88 bb       	out	0x18, r24	; 24
    1576:	40 e0       	ldi	r20, 0x00	; 0
    1578:	62 e0       	ldi	r22, 0x02	; 2
    157a:	80 e0       	ldi	r24, 0x00	; 0
    157c:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    1580:	8f e9       	ldi	r24, 0x9F	; 159
    1582:	9f e0       	ldi	r25, 0x0F	; 15
    1584:	01 97       	sbiw	r24, 0x01	; 1
    1586:	f1 f7       	brne	.-4      	; 0x1584 <LCD_Write_Char+0x6c>
    1588:	00 c0       	rjmp	.+0      	; 0x158a <LCD_Write_Char+0x72>
    158a:	00 00       	nop
    158c:	41 e0       	ldi	r20, 0x01	; 1
    158e:	62 e0       	ldi	r22, 0x02	; 2
    1590:	80 e0       	ldi	r24, 0x00	; 0
    1592:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    1596:	cf 91       	pop	r28
    1598:	08 95       	ret

0000159a <LCD_Write_String>:
    159a:	0f 93       	push	r16
    159c:	1f 93       	push	r17
    159e:	cf 93       	push	r28
    15a0:	8c 01       	movw	r16, r24
    15a2:	c0 e0       	ldi	r28, 0x00	; 0
    15a4:	03 c0       	rjmp	.+6      	; 0x15ac <LCD_Write_String+0x12>
    15a6:	0e 94 8c 0a 	call	0x1518	; 0x1518 <LCD_Write_Char>
    15aa:	cf 5f       	subi	r28, 0xFF	; 255
    15ac:	f8 01       	movw	r30, r16
    15ae:	ec 0f       	add	r30, r28
    15b0:	f1 1d       	adc	r31, r1
    15b2:	80 81       	ld	r24, Z
    15b4:	81 11       	cpse	r24, r1
    15b6:	f7 cf       	rjmp	.-18     	; 0x15a6 <LCD_Write_String+0xc>
    15b8:	cf 91       	pop	r28
    15ba:	1f 91       	pop	r17
    15bc:	0f 91       	pop	r16
    15be:	08 95       	ret

000015c0 <LCD_Write_Integer>:
    15c0:	8f 92       	push	r8
    15c2:	9f 92       	push	r9
    15c4:	af 92       	push	r10
    15c6:	bf 92       	push	r11
    15c8:	ef 92       	push	r14
    15ca:	ff 92       	push	r15
    15cc:	0f 93       	push	r16
    15ce:	1f 93       	push	r17
    15d0:	cf 93       	push	r28
    15d2:	df 93       	push	r29
    15d4:	4b 01       	movw	r8, r22
    15d6:	5c 01       	movw	r10, r24
    15d8:	67 2b       	or	r22, r23
    15da:	68 2b       	or	r22, r24
    15dc:	69 2b       	or	r22, r25
    15de:	19 f4       	brne	.+6      	; 0x15e6 <LCD_Write_Integer+0x26>
    15e0:	80 e3       	ldi	r24, 0x30	; 48
    15e2:	0e 94 8c 0a 	call	0x1518	; 0x1518 <LCD_Write_Char>
    15e6:	01 e0       	ldi	r16, 0x01	; 1
    15e8:	10 e0       	ldi	r17, 0x00	; 0
    15ea:	e1 2c       	mov	r14, r1
    15ec:	f1 2c       	mov	r15, r1
    15ee:	2f c0       	rjmp	.+94     	; 0x164e <LCD_Write_Integer+0x8e>
    15f0:	c7 01       	movw	r24, r14
    15f2:	88 0f       	add	r24, r24
    15f4:	99 1f       	adc	r25, r25
    15f6:	b7 01       	movw	r22, r14
    15f8:	66 0f       	add	r22, r22
    15fa:	77 1f       	adc	r23, r23
    15fc:	66 0f       	add	r22, r22
    15fe:	77 1f       	adc	r23, r23
    1600:	66 0f       	add	r22, r22
    1602:	77 1f       	adc	r23, r23
    1604:	7c 01       	movw	r14, r24
    1606:	e6 0e       	add	r14, r22
    1608:	f7 1e       	adc	r15, r23
    160a:	c5 01       	movw	r24, r10
    160c:	b4 01       	movw	r22, r8
    160e:	2a e0       	ldi	r18, 0x0A	; 10
    1610:	30 e0       	ldi	r19, 0x00	; 0
    1612:	40 e0       	ldi	r20, 0x00	; 0
    1614:	50 e0       	ldi	r21, 0x00	; 0
    1616:	0e 94 e5 17 	call	0x2fca	; 0x2fca <__udivmodsi4>
    161a:	e6 0e       	add	r14, r22
    161c:	f7 1e       	adc	r15, r23
    161e:	e1 14       	cp	r14, r1
    1620:	f1 04       	cpc	r15, r1
    1622:	59 f4       	brne	.+22     	; 0x163a <LCD_Write_Integer+0x7a>
    1624:	c8 01       	movw	r24, r16
    1626:	88 0f       	add	r24, r24
    1628:	99 1f       	adc	r25, r25
    162a:	00 0f       	add	r16, r16
    162c:	11 1f       	adc	r17, r17
    162e:	00 0f       	add	r16, r16
    1630:	11 1f       	adc	r17, r17
    1632:	00 0f       	add	r16, r16
    1634:	11 1f       	adc	r17, r17
    1636:	08 0f       	add	r16, r24
    1638:	19 1f       	adc	r17, r25
    163a:	c5 01       	movw	r24, r10
    163c:	b4 01       	movw	r22, r8
    163e:	2a e0       	ldi	r18, 0x0A	; 10
    1640:	30 e0       	ldi	r19, 0x00	; 0
    1642:	40 e0       	ldi	r20, 0x00	; 0
    1644:	50 e0       	ldi	r21, 0x00	; 0
    1646:	0e 94 e5 17 	call	0x2fca	; 0x2fca <__udivmodsi4>
    164a:	49 01       	movw	r8, r18
    164c:	5a 01       	movw	r10, r20
    164e:	81 14       	cp	r8, r1
    1650:	91 04       	cpc	r9, r1
    1652:	a1 04       	cpc	r10, r1
    1654:	b1 04       	cpc	r11, r1
    1656:	61 f6       	brne	.-104    	; 0x15f0 <LCD_Write_Integer+0x30>
    1658:	a1 2c       	mov	r10, r1
    165a:	b1 2c       	mov	r11, r1
    165c:	16 c0       	rjmp	.+44     	; 0x168a <LCD_Write_Integer+0xca>
    165e:	c7 01       	movw	r24, r14
    1660:	6a e0       	ldi	r22, 0x0A	; 10
    1662:	70 e0       	ldi	r23, 0x00	; 0
    1664:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <__divmodhi4>
    1668:	d6 2f       	mov	r29, r22
    166a:	c7 2f       	mov	r28, r23
    166c:	80 5d       	subi	r24, 0xD0	; 208
    166e:	0e 94 8c 0a 	call	0x1518	; 0x1518 <LCD_Write_Char>
    1672:	ed 2e       	mov	r14, r29
    1674:	fc 2e       	mov	r15, r28
    1676:	e1 14       	cp	r14, r1
    1678:	f1 04       	cpc	r15, r1
    167a:	39 f4       	brne	.+14     	; 0x168a <LCD_Write_Integer+0xca>
    167c:	0a 30       	cpi	r16, 0x0A	; 10
    167e:	11 05       	cpc	r17, r1
    1680:	24 f0       	brlt	.+8      	; 0x168a <LCD_Write_Integer+0xca>
    1682:	78 01       	movw	r14, r16
    1684:	aa 24       	eor	r10, r10
    1686:	a3 94       	inc	r10
    1688:	b1 2c       	mov	r11, r1
    168a:	ea 14       	cp	r14, r10
    168c:	fb 04       	cpc	r15, r11
    168e:	39 f7       	brne	.-50     	; 0x165e <LCD_Write_Integer+0x9e>
    1690:	df 91       	pop	r29
    1692:	cf 91       	pop	r28
    1694:	1f 91       	pop	r17
    1696:	0f 91       	pop	r16
    1698:	ff 90       	pop	r15
    169a:	ef 90       	pop	r14
    169c:	bf 90       	pop	r11
    169e:	af 90       	pop	r10
    16a0:	9f 90       	pop	r9
    16a2:	8f 90       	pop	r8
    16a4:	08 95       	ret

000016a6 <LCD_Clear>:

void LCD_Clear(void)
{
	LCD_Write_CMD(Clear_Display_Screen);
    16a6:	81 e0       	ldi	r24, 0x01	; 1
    16a8:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <LCD_Write_CMD>
    16ac:	08 95       	ret

000016ae <LCD_Goto>:
}

void LCD_Goto(Uint8 row, Uint8 column)
{
    16ae:	cf 93       	push	r28
    16b0:	df 93       	push	r29
    16b2:	00 d0       	rcall	.+0      	; 0x16b4 <LCD_Goto+0x6>
    16b4:	cd b7       	in	r28, 0x3d	; 61
    16b6:	de b7       	in	r29, 0x3e	; 62
	Uint8 arr[2] = {DDRAM_Cursor_Begin_1st_Line, DDRAM_Cursor_Begin_2st_Line};
    16b8:	90 e8       	ldi	r25, 0x80	; 128
    16ba:	99 83       	std	Y+1, r25	; 0x01
    16bc:	90 ec       	ldi	r25, 0xC0	; 192
    16be:	9a 83       	std	Y+2, r25	; 0x02
		
	row = (row >= 0) && (row <= 1)? row : 0;
    16c0:	82 30       	cpi	r24, 0x02	; 2
    16c2:	08 f0       	brcs	.+2      	; 0x16c6 <LCD_Goto+0x18>
    16c4:	80 e0       	ldi	r24, 0x00	; 0
	column = (column >= 0) && (column <= 39)? column : 0; 
    16c6:	68 32       	cpi	r22, 0x28	; 40
    16c8:	08 f0       	brcs	.+2      	; 0x16cc <LCD_Goto+0x1e>
    16ca:	60 e0       	ldi	r22, 0x00	; 0
	
	LCD_Write_CMD(arr[row] + column);	
    16cc:	e1 e0       	ldi	r30, 0x01	; 1
    16ce:	f0 e0       	ldi	r31, 0x00	; 0
    16d0:	ec 0f       	add	r30, r28
    16d2:	fd 1f       	adc	r31, r29
    16d4:	e8 0f       	add	r30, r24
    16d6:	f1 1d       	adc	r31, r1
    16d8:	80 81       	ld	r24, Z
    16da:	86 0f       	add	r24, r22
    16dc:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <LCD_Write_CMD>
}
    16e0:	0f 90       	pop	r0
    16e2:	0f 90       	pop	r0
    16e4:	df 91       	pop	r29
    16e6:	cf 91       	pop	r28
    16e8:	08 95       	ret

000016ea <LED0_Init>:
	DIO_SetPin_Value(LED4_Port, LED4_Pin, PIN_OFF);
}

void LED4_ON(void)
{
	DIO_SetPin_Value(LED4_Port, LED4_Pin, PIN_ON);
    16ea:	41 e0       	ldi	r20, 0x01	; 1
    16ec:	62 e0       	ldi	r22, 0x02	; 2
    16ee:	82 e0       	ldi	r24, 0x02	; 2
    16f0:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    16f4:	41 e0       	ldi	r20, 0x01	; 1
    16f6:	62 e0       	ldi	r22, 0x02	; 2
    16f8:	82 e0       	ldi	r24, 0x02	; 2
    16fa:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    16fe:	08 95       	ret

00001700 <LED0_ON>:
    1700:	40 e0       	ldi	r20, 0x00	; 0
    1702:	62 e0       	ldi	r22, 0x02	; 2
    1704:	82 e0       	ldi	r24, 0x02	; 2
    1706:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    170a:	08 95       	ret

0000170c <LED0_OFF>:
    170c:	41 e0       	ldi	r20, 0x01	; 1
    170e:	62 e0       	ldi	r22, 0x02	; 2
    1710:	82 e0       	ldi	r24, 0x02	; 2
    1712:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    1716:	08 95       	ret

00001718 <LED0_Toggle>:
    1718:	62 e0       	ldi	r22, 0x02	; 2
    171a:	82 e0       	ldi	r24, 0x02	; 2
    171c:	0e 94 7d 02 	call	0x4fa	; 0x4fa <DIO_TogglePin_Value>
    1720:	08 95       	ret

00001722 <LED1_Init>:
    1722:	41 e0       	ldi	r20, 0x01	; 1
    1724:	63 e0       	ldi	r22, 0x03	; 3
    1726:	82 e0       	ldi	r24, 0x02	; 2
    1728:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    172c:	41 e0       	ldi	r20, 0x01	; 1
    172e:	63 e0       	ldi	r22, 0x03	; 3
    1730:	82 e0       	ldi	r24, 0x02	; 2
    1732:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    1736:	08 95       	ret

00001738 <LED1_ON>:
    1738:	40 e0       	ldi	r20, 0x00	; 0
    173a:	63 e0       	ldi	r22, 0x03	; 3
    173c:	82 e0       	ldi	r24, 0x02	; 2
    173e:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    1742:	08 95       	ret

00001744 <LED1_OFF>:
    1744:	41 e0       	ldi	r20, 0x01	; 1
    1746:	63 e0       	ldi	r22, 0x03	; 3
    1748:	82 e0       	ldi	r24, 0x02	; 2
    174a:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    174e:	08 95       	ret

00001750 <LED1_Toggle>:
    1750:	63 e0       	ldi	r22, 0x03	; 3
    1752:	82 e0       	ldi	r24, 0x02	; 2
    1754:	0e 94 7d 02 	call	0x4fa	; 0x4fa <DIO_TogglePin_Value>
    1758:	08 95       	ret

0000175a <LED2_Init>:
    175a:	41 e0       	ldi	r20, 0x01	; 1
    175c:	64 e0       	ldi	r22, 0x04	; 4
    175e:	82 e0       	ldi	r24, 0x02	; 2
    1760:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    1764:	41 e0       	ldi	r20, 0x01	; 1
    1766:	64 e0       	ldi	r22, 0x04	; 4
    1768:	82 e0       	ldi	r24, 0x02	; 2
    176a:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    176e:	08 95       	ret

00001770 <LED2_ON>:
    1770:	40 e0       	ldi	r20, 0x00	; 0
    1772:	64 e0       	ldi	r22, 0x04	; 4
    1774:	82 e0       	ldi	r24, 0x02	; 2
    1776:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    177a:	08 95       	ret

0000177c <LED2_OFF>:
    177c:	41 e0       	ldi	r20, 0x01	; 1
    177e:	64 e0       	ldi	r22, 0x04	; 4
    1780:	82 e0       	ldi	r24, 0x02	; 2
    1782:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    1786:	08 95       	ret

00001788 <LED2_Toggle>:
    1788:	64 e0       	ldi	r22, 0x04	; 4
    178a:	82 e0       	ldi	r24, 0x02	; 2
    178c:	0e 94 7d 02 	call	0x4fa	; 0x4fa <DIO_TogglePin_Value>
    1790:	08 95       	ret

00001792 <LED3_Init>:
    1792:	41 e0       	ldi	r20, 0x01	; 1
    1794:	65 e0       	ldi	r22, 0x05	; 5
    1796:	82 e0       	ldi	r24, 0x02	; 2
    1798:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    179c:	41 e0       	ldi	r20, 0x01	; 1
    179e:	65 e0       	ldi	r22, 0x05	; 5
    17a0:	82 e0       	ldi	r24, 0x02	; 2
    17a2:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    17a6:	08 95       	ret

000017a8 <LED3_ON>:
    17a8:	40 e0       	ldi	r20, 0x00	; 0
    17aa:	65 e0       	ldi	r22, 0x05	; 5
    17ac:	82 e0       	ldi	r24, 0x02	; 2
    17ae:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    17b2:	08 95       	ret

000017b4 <LED3_OFF>:
    17b4:	41 e0       	ldi	r20, 0x01	; 1
    17b6:	65 e0       	ldi	r22, 0x05	; 5
    17b8:	82 e0       	ldi	r24, 0x02	; 2
    17ba:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    17be:	08 95       	ret

000017c0 <LED3_Toggle>:
    17c0:	65 e0       	ldi	r22, 0x05	; 5
    17c2:	82 e0       	ldi	r24, 0x02	; 2
    17c4:	0e 94 7d 02 	call	0x4fa	; 0x4fa <DIO_TogglePin_Value>
    17c8:	08 95       	ret

000017ca <LED4_Init>:
    17ca:	41 e0       	ldi	r20, 0x01	; 1
    17cc:	66 e0       	ldi	r22, 0x06	; 6
    17ce:	82 e0       	ldi	r24, 0x02	; 2
    17d0:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    17d4:	41 e0       	ldi	r20, 0x01	; 1
    17d6:	66 e0       	ldi	r22, 0x06	; 6
    17d8:	82 e0       	ldi	r24, 0x02	; 2
    17da:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    17de:	08 95       	ret

000017e0 <LED4_OFF>:
}
void LED4_OFF(void)
{
	DIO_SetPin_Value(LED4_Port, LED4_Pin, PIN_OFF);
    17e0:	41 e0       	ldi	r20, 0x01	; 1
    17e2:	66 e0       	ldi	r22, 0x06	; 6
    17e4:	82 e0       	ldi	r24, 0x02	; 2
    17e6:	0e 94 de 01 	call	0x3bc	; 0x3bc <DIO_SetPin_Value>
    17ea:	08 95       	ret

000017ec <LED4_Toggle>:
}

void LED4_Toggle(void)
{
	DIO_TogglePin_Value(LED4_Port, LED4_Pin);
    17ec:	66 e0       	ldi	r22, 0x06	; 6
    17ee:	82 e0       	ldi	r24, 0x02	; 2
    17f0:	0e 94 7d 02 	call	0x4fa	; 0x4fa <DIO_TogglePin_Value>
    17f4:	08 95       	ret

000017f6 <main>:
Uint8 Login=0; // Flag to know if any login is happened
Uint8 Admin_login=0; // Flag to know if the admin is logged in 
Uint8 Check_UART_Option=0; // Flag to make sure that user will choose appropriate choice
Uint8 Flag_Dimmer=0; // Flag to know if Dimmer circuit is on or off
int main(void)
{
    17f6:	cf 93       	push	r28
    17f8:	df 93       	push	r29
    17fa:	cd b7       	in	r28, 0x3d	; 61
    17fc:	de b7       	in	r29, 0x3e	; 62
    17fe:	2c 97       	sbiw	r28, 0x0c	; 12
    1800:	0f b6       	in	r0, 0x3f	; 63
    1802:	f8 94       	cli
    1804:	de bf       	out	0x3e, r29	; 62
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	cd bf       	out	0x3d, r28	; 61
	sei();
    180a:	78 94       	sei
	/*Initialization*/
	LCD_Init();
    180c:	0e 94 27 0a 	call	0x144e	; 0x144e <LCD_Init>
	Keypad_Init();
    1810:	0e 94 67 09 	call	0x12ce	; 0x12ce <Keypad_Init>
	EEPROM_INIT();
    1814:	0e 94 e5 02 	call	0x5ca	; 0x5ca <EEPROM_INIT>
	UART_Init();
    1818:	0e 94 9d 15 	call	0x2b3a	; 0x2b3a <UART_Init>
	LCD_Init();
    181c:	0e 94 27 0a 	call	0x144e	; 0x144e <LCD_Init>
	Init_Button(PORTD,PIN_2);
    1820:	82 b3       	in	r24, 0x12	; 18
    1822:	62 e0       	ldi	r22, 0x02	; 2
    1824:	0e 94 01 01 	call	0x202	; 0x202 <Init_Button>
	Keypad_Init();
    1828:	0e 94 67 09 	call	0x12ce	; 0x12ce <Keypad_Init>
	INT0_Init();
    182c:	0e 94 27 03 	call	0x64e	; 0x64e <INT0_Init>
	Servo_INIT();
    1830:	0e 94 72 13 	call	0x26e4	; 0x26e4 <Servo_INIT>
	LED0_Init();
    1834:	0e 94 75 0b 	call	0x16ea	; 0x16ea <LED0_Init>
	LED1_Init();
    1838:	0e 94 91 0b 	call	0x1722	; 0x1722 <LED1_Init>
	LED2_Init();
    183c:	0e 94 ad 0b 	call	0x175a	; 0x175a <LED2_Init>
	LED3_Init();
    1840:	0e 94 c9 0b 	call	0x1792	; 0x1792 <LED3_Init>
	LED4_Init();
    1844:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <LED4_Init>
	Buzzer_Init();
    1848:	0e 94 0e 01 	call	0x21c	; 0x21c <Buzzer_Init>
	DC_Motor1_INIT();
    184c:	0e 94 24 01 	call	0x248	; 0x248 <DC_Motor1_INIT>
	ADC_Init();
    1850:	0e 94 49 00 	call	0x92	; 0x92 <ADC_Init>
	Timer0_Init();
    1854:	0e 94 8a 13 	call	0x2714	; 0x2714 <Timer0_Init>
	Timer0_Start();
    1858:	0e 94 da 13 	call	0x27b4	; 0x27b4 <Timer0_Start>
	Uint8 User_Name_PC[4]={0};
	Uint8 Password_PC[4]={0};
	Uint8 Counter_Alarm=3;
	Uint8 VAR1=0;
	Uint8 USER_NAME[4]={0};
	Uint8 User_User_Name[4]={0};
    185c:	19 82       	std	Y+1, r1	; 0x01
    185e:	1a 82       	std	Y+2, r1	; 0x02
    1860:	1b 82       	std	Y+3, r1	; 0x03
    1862:	1c 82       	std	Y+4, r1	; 0x04
	Uint8 User_Password[4]={0};
    1864:	1d 82       	std	Y+5, r1	; 0x05
    1866:	1e 82       	std	Y+6, r1	; 0x06
    1868:	1f 82       	std	Y+7, r1	; 0x07
    186a:	18 86       	std	Y+8, r1	; 0x08
	/*-------------------------->Checking the EEPROM<--------------------------*/
	
	/*check the EEPROM to get the saved data and check if the program start for the first time or not */
	/*Check for counter of user name and get its value to continue on it because every time program start and end it re assign the value of counter to zero*/
	
	if ((EEPROM_ReadByte(7,0)!=0XFF))  // Counter Username For PC
    186c:	60 e0       	ldi	r22, 0x00	; 0
    186e:	87 e0       	ldi	r24, 0x07	; 7
    1870:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1874:	8f 3f       	cpi	r24, 0xFF	; 255
    1876:	41 f0       	breq	.+16     	; 0x1888 <main+0x92>
	{
		Counter_User_Name= EEPROM_ReadByte(7,0);
    1878:	60 e0       	ldi	r22, 0x00	; 0
    187a:	87 e0       	ldi	r24, 0x07	; 7
    187c:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
		Counter_User_Name++;
    1880:	8f 5f       	subi	r24, 0xFF	; 255
    1882:	80 93 1b 08 	sts	0x081B, r24	; 0x80081b <Counter_User_Name>
    1886:	02 c0       	rjmp	.+4      	; 0x188c <main+0x96>
		
	}
	else
	{
		Counter_User_Name=0;
    1888:	10 92 1b 08 	sts	0x081B, r1	; 0x80081b <Counter_User_Name>
	}
	if ((EEPROM_ReadByte(7,1)!=0XFF)) // Counter Password For PC
    188c:	61 e0       	ldi	r22, 0x01	; 1
    188e:	87 e0       	ldi	r24, 0x07	; 7
    1890:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1894:	8f 3f       	cpi	r24, 0xFF	; 255
    1896:	41 f0       	breq	.+16     	; 0x18a8 <main+0xb2>
	{
		Counter_Password= EEPROM_ReadByte(7,1);
    1898:	61 e0       	ldi	r22, 0x01	; 1
    189a:	87 e0       	ldi	r24, 0x07	; 7
    189c:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
		Counter_Password++;
    18a0:	8f 5f       	subi	r24, 0xFF	; 255
    18a2:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <Counter_Password>
    18a6:	02 c0       	rjmp	.+4      	; 0x18ac <main+0xb6>
	}
	else
	{
		Counter_Password=0;
    18a8:	10 92 1a 08 	sts	0x081A, r1	; 0x80081a <Counter_Password>
	}
	if((EEPROM_ReadByte(5,1)!=0XFF))
    18ac:	61 e0       	ldi	r22, 0x01	; 1
    18ae:	85 e0       	ldi	r24, 0x05	; 5
    18b0:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    18b4:	8f 3f       	cpi	r24, 0xFF	; 255
    18b6:	41 f0       	breq	.+16     	; 0x18c8 <main+0xd2>
	{
		Counter_Password_Keypad= EEPROM_ReadByte(5,1);
    18b8:	61 e0       	ldi	r22, 0x01	; 1
    18ba:	85 e0       	ldi	r24, 0x05	; 5
    18bc:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
		Counter_Password_Keypad++;
    18c0:	8f 5f       	subi	r24, 0xFF	; 255
    18c2:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <Counter_Password_Keypad>
    18c6:	02 c0       	rjmp	.+4      	; 0x18cc <main+0xd6>
	}
	else
	{
		Counter_Password_Keypad=0;
    18c8:	10 92 18 08 	sts	0x0818, r1	; 0x800818 <Counter_Password_Keypad>
	}
	if((EEPROM_ReadByte(5,0)!=0XFF))
    18cc:	60 e0       	ldi	r22, 0x00	; 0
    18ce:	85 e0       	ldi	r24, 0x05	; 5
    18d0:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    18d4:	8f 3f       	cpi	r24, 0xFF	; 255
    18d6:	41 f0       	breq	.+16     	; 0x18e8 <main+0xf2>
	{
		Counter_User_Name_Keypad= EEPROM_ReadByte(5,0);
    18d8:	60 e0       	ldi	r22, 0x00	; 0
    18da:	85 e0       	ldi	r24, 0x05	; 5
    18dc:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
		Counter_User_Name_Keypad++;
    18e0:	8f 5f       	subi	r24, 0xFF	; 255
    18e2:	80 93 19 08 	sts	0x0819, r24	; 0x800819 <Counter_User_Name_Keypad>
    18e6:	02 c0       	rjmp	.+4      	; 0x18ec <main+0xf6>
	}
	else
	{
		Counter_User_Name_Keypad=0;
    18e8:	10 92 19 08 	sts	0x0819, r1	; 0x800819 <Counter_User_Name_Keypad>
	
	/*-------------------------------------------------------------------------------------------------------------------------*/
	
	
   /* send a message to user to inform him how to use the LCD Mode */
	LCD_Init();
    18ec:	0e 94 27 0a 	call	0x144e	; 0x144e <LCD_Init>
	LCD_Clear();
    18f0:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Clear>
	LCD_Write_String("Press button to");
    18f4:	8c e9       	ldi	r24, 0x9C	; 156
    18f6:	92 e0       	ldi	r25, 0x02	; 2
    18f8:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
	LCD_Goto(1,0);
    18fc:	60 e0       	ldi	r22, 0x00	; 0
    18fe:	81 e0       	ldi	r24, 0x01	; 1
    1900:	0e 94 57 0b 	call	0x16ae	; 0x16ae <LCD_Goto>
	LCD_Write_String("start LCD Mode");
    1904:	8c ea       	ldi	r24, 0xAC	; 172
    1906:	92 e0       	ldi	r25, 0x02	; 2
    1908:	0e 94 cd 0a 	call	0x159a	; 0x159a <LCD_Write_String>
	/*------------------------------------------------------------*/
		
	/*-------------------------->UART Programing<--------------------------*/
	
	
	UART_TX_Str("Welcome To Home System\r\n");
    190c:	8b eb       	ldi	r24, 0xBB	; 187
    190e:	92 e0       	ldi	r25, 0x02	; 2
    1910:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
	/*Check the the address Of Admin Password if it assigned to 255 "Factory mode"  
	* so if it not equal to 255 so it used before and user assigned a value to admin password
	*/
	if((EEPROM_ReadByte(6,0))==255)
    1914:	60 e0       	ldi	r22, 0x00	; 0
    1916:	86 e0       	ldi	r24, 0x06	; 6
    1918:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    191c:	8f 3f       	cpi	r24, 0xFF	; 255
    191e:	09 f0       	breq	.+2      	; 0x1922 <main+0x12c>
    1920:	92 c1       	rjmp	.+804    	; 0x1c46 <main+0x450>
	{
		/*Logging In for first time*/
		UART_TX_Str("Login For First Time\r\n");   
    1922:	84 ed       	ldi	r24, 0xD4	; 212
    1924:	92 e0       	ldi	r25, 0x02	; 2
    1926:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    192a:	2f ef       	ldi	r18, 0xFF	; 255
    192c:	89 e6       	ldi	r24, 0x69	; 105
    192e:	98 e1       	ldi	r25, 0x18	; 24
    1930:	21 50       	subi	r18, 0x01	; 1
    1932:	80 40       	sbci	r24, 0x00	; 0
    1934:	90 40       	sbci	r25, 0x00	; 0
    1936:	e1 f7       	brne	.-8      	; 0x1930 <main+0x13a>
    1938:	00 c0       	rjmp	.+0      	; 0x193a <main+0x144>
    193a:	00 00       	nop
		_delay_ms(500);
		UART_TX_Str("Set Admin Password\r\n"); // Get a new Admin Password from user
    193c:	8b ee       	ldi	r24, 0xEB	; 235
    193e:	92 e0       	ldi	r25, 0x02	; 2
    1940:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1944:	2f ef       	ldi	r18, 0xFF	; 255
    1946:	89 e6       	ldi	r24, 0x69	; 105
    1948:	98 e1       	ldi	r25, 0x18	; 24
    194a:	21 50       	subi	r18, 0x01	; 1
    194c:	80 40       	sbci	r24, 0x00	; 0
    194e:	90 40       	sbci	r25, 0x00	; 0
    1950:	e1 f7       	brne	.-8      	; 0x194a <main+0x154>
    1952:	00 c0       	rjmp	.+0      	; 0x1954 <main+0x15e>
    1954:	00 00       	nop
		_delay_ms(500);
		UART_TX_Str("Admin Password\r\n");
    1956:	8f ee       	ldi	r24, 0xEF	; 239
    1958:	92 e0       	ldi	r25, 0x02	; 2
    195a:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
		
		/*Admin Password consists of 4 Digits get them from user and save it in array that i pass every element of the array
		* to  a specific address in the EEPROM page 6
		*/
		Uint8 Admin_Pass[4]={0};
		for(Uint8 i=0 ;i<4;i++)
    195e:	10 e0       	ldi	r17, 0x00	; 0
    1960:	0a c0       	rjmp	.+20     	; 0x1976 <main+0x180>
		{
			
			while (!Get_Bit(UCSRA,7));
    1962:	5f 9b       	sbis	0x0b, 7	; 11
    1964:	fe cf       	rjmp	.-4      	; 0x1962 <main+0x16c>
			Admin_Pass[i]=UART_RX_Char();
    1966:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
			EEPROM_WriteByte(6,i,Admin_Pass[i]);
    196a:	48 2f       	mov	r20, r24
    196c:	61 2f       	mov	r22, r17
    196e:	86 e0       	ldi	r24, 0x06	; 6
    1970:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
		
		/*Admin Password consists of 4 Digits get them from user and save it in array that i pass every element of the array
		* to  a specific address in the EEPROM page 6
		*/
		Uint8 Admin_Pass[4]={0};
		for(Uint8 i=0 ;i<4;i++)
    1974:	1f 5f       	subi	r17, 0xFF	; 255
    1976:	14 30       	cpi	r17, 0x04	; 4
    1978:	a0 f3       	brcs	.-24     	; 0x1962 <main+0x16c>
    197a:	2f ef       	ldi	r18, 0xFF	; 255
    197c:	89 e6       	ldi	r24, 0x69	; 105
    197e:	98 e1       	ldi	r25, 0x18	; 24
    1980:	21 50       	subi	r18, 0x01	; 1
    1982:	80 40       	sbci	r24, 0x00	; 0
    1984:	90 40       	sbci	r25, 0x00	; 0
    1986:	e1 f7       	brne	.-8      	; 0x1980 <main+0x18a>
    1988:	00 c0       	rjmp	.+0      	; 0x198a <main+0x194>
    198a:	00 00       	nop
			Admin_Pass[i]=UART_RX_Char();
			EEPROM_WriteByte(6,i,Admin_Pass[i]);
			
		}
		_delay_ms(500);
		UART_TX_Str("\r\n");
    198c:	8e eb       	ldi	r24, 0xBE	; 190
    198e:	97 e0       	ldi	r25, 0x07	; 7
    1990:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
		UART_TX_Str("Password Saved\r\n");
    1994:	80 e0       	ldi	r24, 0x00	; 0
    1996:	93 e0       	ldi	r25, 0x03	; 3
    1998:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    199c:	59 c1       	rjmp	.+690    	; 0x1c50 <main+0x45a>
	{
		
		while (!Check_UART_Option) // While Loop to make sure that the user will choose the right input 
		{
			
			Check_UART_Option=1; // Flag that will change in default  if the user choose wrong input 
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	80 93 11 08 	sts	0x0811, r24	; 0x800811 <Check_UART_Option>
			/*Interfacing*/
			UART_TX_Str("Login System\r\n");
    19a4:	81 e1       	ldi	r24, 0x11	; 17
    19a6:	93 e0       	ldi	r25, 0x03	; 3
    19a8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
			UART_TX_Str("\r\n");
    19ac:	8e eb       	ldi	r24, 0xBE	; 190
    19ae:	97 e0       	ldi	r25, 0x07	; 7
    19b0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    19b4:	2f ef       	ldi	r18, 0xFF	; 255
    19b6:	89 e6       	ldi	r24, 0x69	; 105
    19b8:	98 e1       	ldi	r25, 0x18	; 24
    19ba:	21 50       	subi	r18, 0x01	; 1
    19bc:	80 40       	sbci	r24, 0x00	; 0
    19be:	90 40       	sbci	r25, 0x00	; 0
    19c0:	e1 f7       	brne	.-8      	; 0x19ba <main+0x1c4>
    19c2:	00 c0       	rjmp	.+0      	; 0x19c4 <main+0x1ce>
    19c4:	00 00       	nop
			_delay_ms(500);
			UART_TX_Str("1. Admin\r\n");
    19c6:	80 e2       	ldi	r24, 0x20	; 32
    19c8:	93 e0       	ldi	r25, 0x03	; 3
    19ca:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    19ce:	2f ef       	ldi	r18, 0xFF	; 255
    19d0:	89 e6       	ldi	r24, 0x69	; 105
    19d2:	98 e1       	ldi	r25, 0x18	; 24
    19d4:	21 50       	subi	r18, 0x01	; 1
    19d6:	80 40       	sbci	r24, 0x00	; 0
    19d8:	90 40       	sbci	r25, 0x00	; 0
    19da:	e1 f7       	brne	.-8      	; 0x19d4 <main+0x1de>
    19dc:	00 c0       	rjmp	.+0      	; 0x19de <main+0x1e8>
    19de:	00 00       	nop
			_delay_ms(500);
			UART_TX_Str("2. Guest\r\n");
    19e0:	8b e2       	ldi	r24, 0x2B	; 43
    19e2:	93 e0       	ldi	r25, 0x03	; 3
    19e4:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    19e8:	2f ef       	ldi	r18, 0xFF	; 255
    19ea:	89 e6       	ldi	r24, 0x69	; 105
    19ec:	98 e1       	ldi	r25, 0x18	; 24
    19ee:	21 50       	subi	r18, 0x01	; 1
    19f0:	80 40       	sbci	r24, 0x00	; 0
    19f2:	90 40       	sbci	r25, 0x00	; 0
    19f4:	e1 f7       	brne	.-8      	; 0x19ee <main+0x1f8>
    19f6:	00 c0       	rjmp	.+0      	; 0x19f8 <main+0x202>
    19f8:	00 00       	nop
			_delay_ms(500);
			UART_TX_Str("Please Enter Your Mode Number\r\n");
    19fa:	86 e3       	ldi	r24, 0x36	; 54
    19fc:	93 e0       	ldi	r25, 0x03	; 3
    19fe:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
			UART_RX_Char();
    1a02:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
			while (!Get_Bit(UCSRA,7));
    1a06:	5f 9b       	sbis	0x0b, 7	; 11
    1a08:	fe cf       	rjmp	.-4      	; 0x1a06 <main+0x210>
			/*----------------------------------------------*/
			
			
			
			Uint8 Var_Login=UDR;// get data from user that is sent to UDR Register 
    1a0a:	8c b1       	in	r24, 0x0c	; 12
			
			switch (Var_Login) // Switch over the value IF it 1 or 2
    1a0c:	81 33       	cpi	r24, 0x31	; 49
    1a0e:	21 f0       	breq	.+8      	; 0x1a18 <main+0x222>
    1a10:	82 33       	cpi	r24, 0x32	; 50
    1a12:	09 f4       	brne	.+2      	; 0x1a16 <main+0x220>
    1a14:	61 c0       	rjmp	.+194    	; 0x1ad8 <main+0x2e2>
    1a16:	0d c1       	rjmp	.+538    	; 0x1c32 <main+0x43c>
				/*----------------->Admin Login<-----------------*/
				/*only one Admin and use only password to log in*/
				case '1':
				{
					Counter_Alarm=3; // Flag that control the alarm if user enter password 3 times wrong alarm will turn on
					Uint8 Flag_Admin_pass_PC[4]={0}; // Array will have the input password from user to compare it with EEPROM
    1a18:	19 86       	std	Y+9, r1	; 0x09
    1a1a:	1a 86       	std	Y+10, r1	; 0x0a
    1a1c:	1b 86       	std	Y+11, r1	; 0x0b
    1a1e:	1c 86       	std	Y+12, r1	; 0x0c
			{
				/*----------------->Admin Login<-----------------*/
				/*only one Admin and use only password to log in*/
				case '1':
				{
					Counter_Alarm=3; // Flag that control the alarm if user enter password 3 times wrong alarm will turn on
    1a20:	13 e0       	ldi	r17, 0x03	; 3
					Uint8 Flag_Admin_pass_PC[4]={0}; // Array will have the input password from user to compare it with EEPROM
					do
					{
						UART_TX_Str("\r\n");
    1a22:	8e eb       	ldi	r24, 0xBE	; 190
    1a24:	97 e0       	ldi	r25, 0x07	; 7
    1a26:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str("Admin Pass\r\n");
    1a2a:	86 e5       	ldi	r24, 0x56	; 86
    1a2c:	93 e0       	ldi	r25, 0x03	; 3
    1a2e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						for(Uint8 i=0 ;i<4;i++)
    1a32:	00 e0       	ldi	r16, 0x00	; 0
    1a34:	0e c0       	rjmp	.+28     	; 0x1a52 <main+0x25c>
						{
							while (!Get_Bit(UCSRA,7)); // waiting until user enter a digit
    1a36:	5f 9b       	sbis	0x0b, 7	; 11
    1a38:	fe cf       	rjmp	.-4      	; 0x1a36 <main+0x240>
							Flag_Admin_pass_PC[i]=UART_RX_Char();
    1a3a:	e0 2e       	mov	r14, r16
    1a3c:	f1 2c       	mov	r15, r1
    1a3e:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
    1a42:	e9 e0       	ldi	r30, 0x09	; 9
    1a44:	f0 e0       	ldi	r31, 0x00	; 0
    1a46:	ec 0f       	add	r30, r28
    1a48:	fd 1f       	adc	r31, r29
    1a4a:	ee 0d       	add	r30, r14
    1a4c:	ff 1d       	adc	r31, r15
    1a4e:	80 83       	st	Z, r24
					Uint8 Flag_Admin_pass_PC[4]={0}; // Array will have the input password from user to compare it with EEPROM
					do
					{
						UART_TX_Str("\r\n");
						UART_TX_Str("Admin Pass\r\n");
						for(Uint8 i=0 ;i<4;i++)
    1a50:	0f 5f       	subi	r16, 0xFF	; 255
    1a52:	04 30       	cpi	r16, 0x04	; 4
    1a54:	80 f3       	brcs	.-32     	; 0x1a36 <main+0x240>
						/* check by comparing every element in the array with every byte in EEPROM 
						* by using if Condition and logical And
						* if all is true so it enter if condition and will display login 
						*if any digit is wrong it will enter else and decrease alarm by 1 and it will start take the password again
						*/
						if (Flag_Admin_pass_PC[0]== EEPROM_ReadByte(6,0) && Flag_Admin_pass_PC[1]== EEPROM_ReadByte(6,1) && Flag_Admin_pass_PC[2]== EEPROM_ReadByte(6,2) && Flag_Admin_pass_PC[3]== EEPROM_ReadByte(6,3))
    1a56:	09 85       	ldd	r16, Y+9	; 0x09
    1a58:	60 e0       	ldi	r22, 0x00	; 0
    1a5a:	86 e0       	ldi	r24, 0x06	; 6
    1a5c:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1a60:	08 13       	cpse	r16, r24
    1a62:	22 c0       	rjmp	.+68     	; 0x1aa8 <main+0x2b2>
    1a64:	0a 85       	ldd	r16, Y+10	; 0x0a
    1a66:	61 e0       	ldi	r22, 0x01	; 1
    1a68:	86 e0       	ldi	r24, 0x06	; 6
    1a6a:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1a6e:	08 13       	cpse	r16, r24
    1a70:	1b c0       	rjmp	.+54     	; 0x1aa8 <main+0x2b2>
    1a72:	0b 85       	ldd	r16, Y+11	; 0x0b
    1a74:	62 e0       	ldi	r22, 0x02	; 2
    1a76:	86 e0       	ldi	r24, 0x06	; 6
    1a78:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1a7c:	08 13       	cpse	r16, r24
    1a7e:	14 c0       	rjmp	.+40     	; 0x1aa8 <main+0x2b2>
    1a80:	0c 85       	ldd	r16, Y+12	; 0x0c
    1a82:	63 e0       	ldi	r22, 0x03	; 3
    1a84:	86 e0       	ldi	r24, 0x06	; 6
    1a86:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1a8a:	08 13       	cpse	r16, r24
    1a8c:	0d c0       	rjmp	.+26     	; 0x1aa8 <main+0x2b2>
						{
							UART_TX_Str("\r\n");
    1a8e:	8e eb       	ldi	r24, 0xBE	; 190
    1a90:	97 e0       	ldi	r25, 0x07	; 7
    1a92:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							UART_TX_Str("Logged In\r\n");
    1a96:	83 e6       	ldi	r24, 0x63	; 99
    1a98:	93 e0       	ldi	r25, 0x03	; 3
    1a9a:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							Admin_login=1;
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	80 93 12 08 	sts	0x0812, r24	; 0x800812 <Admin_login>
							Counter_Alarm=0; // To break the while loop
    1aa4:	10 e0       	ldi	r17, 0x00	; 0
    1aa6:	15 c0       	rjmp	.+42     	; 0x1ad2 <main+0x2dc>
						}
						else
						{
							Counter_Alarm--; //Decrement of alarm counter
    1aa8:	11 50       	subi	r17, 0x01	; 1
							UART_TX_Str("\r\n");
    1aaa:	8e eb       	ldi	r24, 0xBE	; 190
    1aac:	97 e0       	ldi	r25, 0x07	; 7
    1aae:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							UART_TX_Str("Invalid pass\r\n");
    1ab2:	8f e6       	ldi	r24, 0x6F	; 111
    1ab4:	93 e0       	ldi	r25, 0x03	; 3
    1ab6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							UART_TX_Str("Please Try again\r\n");
    1aba:	8e e7       	ldi	r24, 0x7E	; 126
    1abc:	93 e0       	ldi	r25, 0x03	; 3
    1abe:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							if (Counter_Alarm==0)
    1ac2:	11 11       	cpse	r17, r1
    1ac4:	03 c0       	rjmp	.+6      	; 0x1acc <main+0x2d6>
							{
								//Alarm
								while (1)
								{
									ALARM_ON();
    1ac6:	0e 94 b7 00 	call	0x16e	; 0x16e <ALARM_ON>
    1aca:	fd cf       	rjmp	.-6      	; 0x1ac6 <main+0x2d0>
								}
								
							}
							UART_TX_Char(Counter_Alarm);
    1acc:	81 2f       	mov	r24, r17
    1ace:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <UART_TX_Char>
							
						}
						
						
					} while (Counter_Alarm); // the while loop which make the user enter the password again if it is wrong by checking the counter alarm
    1ad2:	11 11       	cpse	r17, r1
    1ad4:	a6 cf       	rjmp	.-180    	; 0x1a22 <main+0x22c>
    1ad6:	b7 c0       	rjmp	.+366    	; 0x1c46 <main+0x450>
			
			
			
			Uint8 Var_Login=UDR;// get data from user that is sent to UDR Register 
			
			switch (Var_Login) // Switch over the value IF it 1 or 2
    1ad8:	03 e0       	ldi	r16, 0x03	; 3
				case '2':
				{
					/*the same as admin log in except checking for username*/
					Counter_Alarm=3;
					do{
						UART_TX_Str("\r\n");
    1ada:	8e eb       	ldi	r24, 0xBE	; 190
    1adc:	97 e0       	ldi	r25, 0x07	; 7
    1ade:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str("Username\r\n");
    1ae2:	8f ea       	ldi	r24, 0xAF	; 175
    1ae4:	93 e0       	ldi	r25, 0x03	; 3
    1ae6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						for(Uint8 i=0 ;i<4;i++)
    1aea:	10 e0       	ldi	r17, 0x00	; 0
    1aec:	0e c0       	rjmp	.+28     	; 0x1b0a <main+0x314>
						{
							while (!Get_Bit(UCSRA,7));
    1aee:	5f 9b       	sbis	0x0b, 7	; 11
    1af0:	fe cf       	rjmp	.-4      	; 0x1aee <main+0x2f8>
							User_User_Name[i]=UART_RX_Char();
    1af2:	e1 2e       	mov	r14, r17
    1af4:	f1 2c       	mov	r15, r1
    1af6:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
    1afa:	e1 e0       	ldi	r30, 0x01	; 1
    1afc:	f0 e0       	ldi	r31, 0x00	; 0
    1afe:	ec 0f       	add	r30, r28
    1b00:	fd 1f       	adc	r31, r29
    1b02:	ee 0d       	add	r30, r14
    1b04:	ff 1d       	adc	r31, r15
    1b06:	80 83       	st	Z, r24
					/*the same as admin log in except checking for username*/
					Counter_Alarm=3;
					do{
						UART_TX_Str("\r\n");
						UART_TX_Str("Username\r\n");
						for(Uint8 i=0 ;i<4;i++)
    1b08:	1f 5f       	subi	r17, 0xFF	; 255
    1b0a:	14 30       	cpi	r17, 0x04	; 4
    1b0c:	80 f3       	brcs	.-32     	; 0x1aee <main+0x2f8>
						{
							while (!Get_Bit(UCSRA,7));
							User_User_Name[i]=UART_RX_Char();
						}//End Of For Loop
						UART_TX_Str("\r\n");
    1b0e:	8e eb       	ldi	r24, 0xBE	; 190
    1b10:	97 e0       	ldi	r25, 0x07	; 7
    1b12:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str("Password\r\n");
    1b16:	85 ef       	ldi	r24, 0xF5	; 245
    1b18:	92 e0       	ldi	r25, 0x02	; 2
    1b1a:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						
						for(Uint8 i=0 ;i<4;i++)
    1b1e:	10 e0       	ldi	r17, 0x00	; 0
    1b20:	0e c0       	rjmp	.+28     	; 0x1b3e <main+0x348>
						{
							while (!Get_Bit(UCSRA,7));
    1b22:	5f 9b       	sbis	0x0b, 7	; 11
    1b24:	fe cf       	rjmp	.-4      	; 0x1b22 <main+0x32c>
							User_Password[i]=UART_RX_Char();
    1b26:	e1 2e       	mov	r14, r17
    1b28:	f1 2c       	mov	r15, r1
    1b2a:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
    1b2e:	e5 e0       	ldi	r30, 0x05	; 5
    1b30:	f0 e0       	ldi	r31, 0x00	; 0
    1b32:	ec 0f       	add	r30, r28
    1b34:	fd 1f       	adc	r31, r29
    1b36:	ee 0d       	add	r30, r14
    1b38:	ff 1d       	adc	r31, r15
    1b3a:	80 83       	st	Z, r24
							User_User_Name[i]=UART_RX_Char();
						}//End Of For Loop
						UART_TX_Str("\r\n");
						UART_TX_Str("Password\r\n");
						
						for(Uint8 i=0 ;i<4;i++)
    1b3c:	1f 5f       	subi	r17, 0xFF	; 255
    1b3e:	14 30       	cpi	r17, 0x04	; 4
    1b40:	80 f3       	brcs	.-32     	; 0x1b22 <main+0x32c>
    1b42:	10 e0       	ldi	r17, 0x00	; 0
    1b44:	64 c0       	rjmp	.+200    	; 0x1c0e <main+0x418>
						if exceeds the 3 trials so alarm will on
						*/
						
						for (Uint8 i=0; i<=Counter_User_Name;i++) // loop to chrck the whole page addresses
						{
							if((User_User_Name[0]== EEPROM_ReadByte(Page_User_Name,i)) && (User_User_Name[1]== EEPROM_ReadByte(Page_User_Name,i+1)) && (User_User_Name[2]== EEPROM_ReadByte(Page_User_Name,i+2)) && (User_User_Name[3]== EEPROM_ReadByte(Page_User_Name,i+3)))// If Condition For checking Username
    1b46:	f9 80       	ldd	r15, Y+1	; 0x01
    1b48:	61 2f       	mov	r22, r17
    1b4a:	80 e0       	ldi	r24, 0x00	; 0
    1b4c:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1b50:	f8 12       	cpse	r15, r24
    1b52:	5c c0       	rjmp	.+184    	; 0x1c0c <main+0x416>
    1b54:	ea 80       	ldd	r14, Y+2	; 0x02
    1b56:	ff 24       	eor	r15, r15
    1b58:	f3 94       	inc	r15
    1b5a:	f1 0e       	add	r15, r17
    1b5c:	6f 2d       	mov	r22, r15
    1b5e:	80 e0       	ldi	r24, 0x00	; 0
    1b60:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1b64:	e8 12       	cpse	r14, r24
    1b66:	52 c0       	rjmp	.+164    	; 0x1c0c <main+0x416>
    1b68:	eb 80       	ldd	r14, Y+3	; 0x03
    1b6a:	68 94       	set
    1b6c:	dd 24       	eor	r13, r13
    1b6e:	d1 f8       	bld	r13, 1
    1b70:	d1 0e       	add	r13, r17
    1b72:	6d 2d       	mov	r22, r13
    1b74:	80 e0       	ldi	r24, 0x00	; 0
    1b76:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1b7a:	e8 12       	cpse	r14, r24
    1b7c:	47 c0       	rjmp	.+142    	; 0x1c0c <main+0x416>
    1b7e:	cc 80       	ldd	r12, Y+4	; 0x04
    1b80:	0f 2e       	mov	r0, r31
    1b82:	f3 e0       	ldi	r31, 0x03	; 3
    1b84:	ef 2e       	mov	r14, r31
    1b86:	f0 2d       	mov	r31, r0
    1b88:	e1 0e       	add	r14, r17
    1b8a:	6e 2d       	mov	r22, r14
    1b8c:	80 e0       	ldi	r24, 0x00	; 0
    1b8e:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1b92:	c8 12       	cpse	r12, r24
    1b94:	3b c0       	rjmp	.+118    	; 0x1c0c <main+0x416>
							{
								if ((User_Password[0]==EEPROM_ReadByte(Page_Password,i)) && (User_Password[1]==EEPROM_ReadByte(Page_Password,i+1)) && (User_Password[2]==EEPROM_ReadByte(Page_Password,i+2)) && (User_Password[3]==EEPROM_ReadByte(Page_Password,i+3)))// If Condition For checking password
    1b96:	cd 80       	ldd	r12, Y+5	; 0x05
    1b98:	61 2f       	mov	r22, r17
    1b9a:	81 e0       	ldi	r24, 0x01	; 1
    1b9c:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1ba0:	c8 12       	cpse	r12, r24
    1ba2:	1f c0       	rjmp	.+62     	; 0x1be2 <main+0x3ec>
    1ba4:	ce 80       	ldd	r12, Y+6	; 0x06
    1ba6:	6f 2d       	mov	r22, r15
    1ba8:	81 e0       	ldi	r24, 0x01	; 1
    1baa:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1bae:	c8 12       	cpse	r12, r24
    1bb0:	18 c0       	rjmp	.+48     	; 0x1be2 <main+0x3ec>
    1bb2:	ff 80       	ldd	r15, Y+7	; 0x07
    1bb4:	6d 2d       	mov	r22, r13
    1bb6:	81 e0       	ldi	r24, 0x01	; 1
    1bb8:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1bbc:	f8 12       	cpse	r15, r24
    1bbe:	11 c0       	rjmp	.+34     	; 0x1be2 <main+0x3ec>
    1bc0:	f8 84       	ldd	r15, Y+8	; 0x08
    1bc2:	6e 2d       	mov	r22, r14
    1bc4:	81 e0       	ldi	r24, 0x01	; 1
    1bc6:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    1bca:	f8 12       	cpse	r15, r24
    1bcc:	0a c0       	rjmp	.+20     	; 0x1be2 <main+0x3ec>
								{
									UART_TX_Str("\r\n");
    1bce:	8e eb       	ldi	r24, 0xBE	; 190
    1bd0:	97 e0       	ldi	r25, 0x07	; 7
    1bd2:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str("Logged In\r\n");
    1bd6:	83 e6       	ldi	r24, 0x63	; 99
    1bd8:	93 e0       	ldi	r25, 0x03	; 3
    1bda:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									//_delay_ms(5000);
									Counter_Alarm=0;
    1bde:	00 e0       	ldi	r16, 0x00	; 0
									break;
    1be0:	1b c0       	rjmp	.+54     	; 0x1c18 <main+0x422>
									//_delay_ms(5000);
								}//End Of If Condition Of Checking Password
								
								else
								{
									Counter_Alarm--;
    1be2:	01 50       	subi	r16, 0x01	; 1
									UART_TX_Str("\r\n");
    1be4:	8e eb       	ldi	r24, 0xBE	; 190
    1be6:	97 e0       	ldi	r25, 0x07	; 7
    1be8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str("Invalid pass\r\n");
    1bec:	8f e6       	ldi	r24, 0x6F	; 111
    1bee:	93 e0       	ldi	r25, 0x03	; 3
    1bf0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str("Number of trials left\r\n");
    1bf4:	81 e9       	ldi	r24, 0x91	; 145
    1bf6:	93 e0       	ldi	r25, 0x03	; 3
    1bf8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									if (Counter_Alarm==0)
    1bfc:	01 11       	cpse	r16, r1
    1bfe:	03 c0       	rjmp	.+6      	; 0x1c06 <main+0x410>
									{
										while (1)
										{
											ALARM_ON(); // a pattern of leds and buzzer
    1c00:	0e 94 b7 00 	call	0x16e	; 0x16e <ALARM_ON>
    1c04:	fd cf       	rjmp	.-6      	; 0x1c00 <main+0x40a>
										}
										
									}
									UART_TX_Char(Counter_Alarm);
    1c06:	80 2f       	mov	r24, r16
    1c08:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <UART_TX_Char>
						2- if not found display wrong user name
						3- if username is correct but password is not correct it will display incorrect password and have 3 trials
						if exceeds the 3 trials so alarm will on
						*/
						
						for (Uint8 i=0; i<=Counter_User_Name;i++) // loop to chrck the whole page addresses
    1c0c:	1f 5f       	subi	r17, 0xFF	; 255
    1c0e:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <Counter_User_Name>
    1c12:	81 17       	cp	r24, r17
    1c14:	08 f0       	brcs	.+2      	; 0x1c18 <main+0x422>
    1c16:	97 cf       	rjmp	.-210    	; 0x1b46 <main+0x350>
									UART_TX_Char(Counter_Alarm);
								}// Else For Wrong Password
							}//End Of If Condition Of User
							
						}//End Of For Loop
						if (Counter_Alarm==3)//Condition Of Wrong UserName
    1c18:	03 30       	cpi	r16, 0x03	; 3
    1c1a:	41 f4       	brne	.+16     	; 0x1c2c <main+0x436>
						{
							UART_TX_Str("\r\n");
    1c1c:	8e eb       	ldi	r24, 0xBE	; 190
    1c1e:	97 e0       	ldi	r25, 0x07	; 7
    1c20:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							UART_TX_Str("Wrong Username\r\n");
    1c24:	89 ea       	ldi	r24, 0xA9	; 169
    1c26:	93 e0       	ldi	r25, 0x03	; 3
    1c28:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						}//End Of If Condition (Checking for wrong user name)
					}while(Counter_Alarm);
    1c2c:	01 11       	cpse	r16, r1
    1c2e:	55 cf       	rjmp	.-342    	; 0x1ada <main+0x2e4>
    1c30:	0a c0       	rjmp	.+20     	; 0x1c46 <main+0x450>
					
				break;	}// End Of Case 2
				default:
				{
					UART_TX_Str("\r\n");
    1c32:	8e eb       	ldi	r24, 0xBE	; 190
    1c34:	97 e0       	ldi	r25, 0x07	; 7
    1c36:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
					UART_TX_Str("Wrong Input Please Try Again\r\n");
    1c3a:	8a eb       	ldi	r24, 0xBA	; 186
    1c3c:	93 e0       	ldi	r25, 0x03	; 3
    1c3e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
					Check_UART_Option=0;
    1c42:	10 92 11 08 	sts	0x0811, r1	; 0x800811 <Check_UART_Option>
	}
	/*------------------------------------------------------------------------*/
	else
	{
		
		while (!Check_UART_Option) // While Loop to make sure that the user will choose the right input 
    1c46:	80 91 11 08 	lds	r24, 0x0811	; 0x800811 <Check_UART_Option>
    1c4a:	88 23       	and	r24, r24
    1c4c:	09 f4       	brne	.+2      	; 0x1c50 <main+0x45a>
    1c4e:	a7 ce       	rjmp	.-690    	; 0x199e <main+0x1a8>
		 *1- Control all Home (Lamps , Door)
		 *2- Check all status of home 
		 *3- Add an User (Can be created by Admin and user of UART only)
		 *4- Delete User (Can be Deleted by Admin and user of UART only) 
		 */
			UART_TX_Str("\r\n");
    1c50:	8e eb       	ldi	r24, 0xBE	; 190
    1c52:	97 e0       	ldi	r25, 0x07	; 7
    1c54:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
			UART_TX_Str("1. Control Home System\r\n");
    1c58:	89 ed       	ldi	r24, 0xD9	; 217
    1c5a:	93 e0       	ldi	r25, 0x03	; 3
    1c5c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
			UART_TX_Str("2. Check Status Of Home \r\n");
    1c60:	82 ef       	ldi	r24, 0xF2	; 242
    1c62:	93 e0       	ldi	r25, 0x03	; 3
    1c64:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
			UART_TX_Str("3. Add User\r\n");
    1c68:	8d e0       	ldi	r24, 0x0D	; 13
    1c6a:	94 e0       	ldi	r25, 0x04	; 4
    1c6c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
			UART_TX_Str("4. Delete User\r\n");
    1c70:	8b e1       	ldi	r24, 0x1B	; 27
    1c72:	94 e0       	ldi	r25, 0x04	; 4
    1c74:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1c78:	2f ef       	ldi	r18, 0xFF	; 255
    1c7a:	81 ee       	ldi	r24, 0xE1	; 225
    1c7c:	94 e0       	ldi	r25, 0x04	; 4
    1c7e:	21 50       	subi	r18, 0x01	; 1
    1c80:	80 40       	sbci	r24, 0x00	; 0
    1c82:	90 40       	sbci	r25, 0x00	; 0
    1c84:	e1 f7       	brne	.-8      	; 0x1c7e <main+0x488>
    1c86:	00 c0       	rjmp	.+0      	; 0x1c88 <main+0x492>
    1c88:	00 00       	nop
			_delay_ms(100);
			UART_TX_Str("Enter Your Command Number\r\n");
    1c8a:	8c e2       	ldi	r24, 0x2C	; 44
    1c8c:	94 e0       	ldi	r25, 0x04	; 4
    1c8e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
			UART_RX_Char();
    1c92:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
			while (!Get_Bit(UCSRA,7));
    1c96:	5f 9b       	sbis	0x0b, 7	; 11
    1c98:	fe cf       	rjmp	.-4      	; 0x1c96 <main+0x4a0>
			
		
		
		Uint8 Var_status=UDR;
    1c9a:	8c b1       	in	r24, 0x0c	; 12
		switch (Var_status)
    1c9c:	82 33       	cpi	r24, 0x32	; 50
    1c9e:	09 f4       	brne	.+2      	; 0x1ca2 <main+0x4ac>
    1ca0:	91 c2       	rjmp	.+1314   	; 0x21c4 <main+0x9ce>
    1ca2:	18 f4       	brcc	.+6      	; 0x1caa <main+0x4b4>
    1ca4:	81 33       	cpi	r24, 0x31	; 49
    1ca6:	41 f0       	breq	.+16     	; 0x1cb8 <main+0x4c2>
    1ca8:	09 c5       	rjmp	.+2578   	; 0x26bc <main+0xec6>
    1caa:	83 33       	cpi	r24, 0x33	; 51
    1cac:	09 f4       	brne	.+2      	; 0x1cb0 <main+0x4ba>
    1cae:	36 c3       	rjmp	.+1644   	; 0x231c <main+0xb26>
    1cb0:	84 33       	cpi	r24, 0x34	; 52
    1cb2:	09 f4       	brne	.+2      	; 0x1cb6 <main+0x4c0>
    1cb4:	f6 c3       	rjmp	.+2028   	; 0x24a2 <main+0xcac>
    1cb6:	02 c5       	rjmp	.+2564   	; 0x26bc <main+0xec6>
		{
			/*------------------------------------------>HOME SYSTEM<------------------------------------------*/
			case'1':
			{
				UART_TX_Str("\r\n");
    1cb8:	8e eb       	ldi	r24, 0xBE	; 190
    1cba:	97 e0       	ldi	r25, 0x07	; 7
    1cbc:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
				UART_TX_Str("1. Open Door\r\n");
    1cc0:	88 e4       	ldi	r24, 0x48	; 72
    1cc2:	94 e0       	ldi	r25, 0x04	; 4
    1cc4:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1cc8:	2f ef       	ldi	r18, 0xFF	; 255
    1cca:	81 ee       	ldi	r24, 0xE1	; 225
    1ccc:	94 e0       	ldi	r25, 0x04	; 4
    1cce:	21 50       	subi	r18, 0x01	; 1
    1cd0:	80 40       	sbci	r24, 0x00	; 0
    1cd2:	90 40       	sbci	r25, 0x00	; 0
    1cd4:	e1 f7       	brne	.-8      	; 0x1cce <main+0x4d8>
    1cd6:	00 c0       	rjmp	.+0      	; 0x1cd8 <main+0x4e2>
    1cd8:	00 00       	nop
				_delay_ms(100);
				UART_TX_Str("2. Close The Door \r\n");
    1cda:	87 e5       	ldi	r24, 0x57	; 87
    1cdc:	94 e0       	ldi	r25, 0x04	; 4
    1cde:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1ce2:	2f ef       	ldi	r18, 0xFF	; 255
    1ce4:	81 ee       	ldi	r24, 0xE1	; 225
    1ce6:	94 e0       	ldi	r25, 0x04	; 4
    1ce8:	21 50       	subi	r18, 0x01	; 1
    1cea:	80 40       	sbci	r24, 0x00	; 0
    1cec:	90 40       	sbci	r25, 0x00	; 0
    1cee:	e1 f7       	brne	.-8      	; 0x1ce8 <main+0x4f2>
    1cf0:	00 c0       	rjmp	.+0      	; 0x1cf2 <main+0x4fc>
    1cf2:	00 00       	nop
				_delay_ms(100);
				UART_TX_Str("3. Room 1\r\n");
    1cf4:	8c e6       	ldi	r24, 0x6C	; 108
    1cf6:	94 e0       	ldi	r25, 0x04	; 4
    1cf8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1cfc:	2f ef       	ldi	r18, 0xFF	; 255
    1cfe:	81 ee       	ldi	r24, 0xE1	; 225
    1d00:	94 e0       	ldi	r25, 0x04	; 4
    1d02:	21 50       	subi	r18, 0x01	; 1
    1d04:	80 40       	sbci	r24, 0x00	; 0
    1d06:	90 40       	sbci	r25, 0x00	; 0
    1d08:	e1 f7       	brne	.-8      	; 0x1d02 <main+0x50c>
    1d0a:	00 c0       	rjmp	.+0      	; 0x1d0c <main+0x516>
    1d0c:	00 00       	nop
				_delay_ms(100);
				UART_TX_Str("4. Room 2\r\n");
    1d0e:	88 e7       	ldi	r24, 0x78	; 120
    1d10:	94 e0       	ldi	r25, 0x04	; 4
    1d12:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1d16:	2f ef       	ldi	r18, 0xFF	; 255
    1d18:	81 ee       	ldi	r24, 0xE1	; 225
    1d1a:	94 e0       	ldi	r25, 0x04	; 4
    1d1c:	21 50       	subi	r18, 0x01	; 1
    1d1e:	80 40       	sbci	r24, 0x00	; 0
    1d20:	90 40       	sbci	r25, 0x00	; 0
    1d22:	e1 f7       	brne	.-8      	; 0x1d1c <main+0x526>
    1d24:	00 c0       	rjmp	.+0      	; 0x1d26 <main+0x530>
    1d26:	00 00       	nop
				_delay_ms(100);
				UART_TX_Str("5. Reception\r\n");
    1d28:	84 e8       	ldi	r24, 0x84	; 132
    1d2a:	94 e0       	ldi	r25, 0x04	; 4
    1d2c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1d30:	2f ef       	ldi	r18, 0xFF	; 255
    1d32:	81 ee       	ldi	r24, 0xE1	; 225
    1d34:	94 e0       	ldi	r25, 0x04	; 4
    1d36:	21 50       	subi	r18, 0x01	; 1
    1d38:	80 40       	sbci	r24, 0x00	; 0
    1d3a:	90 40       	sbci	r25, 0x00	; 0
    1d3c:	e1 f7       	brne	.-8      	; 0x1d36 <main+0x540>
    1d3e:	00 c0       	rjmp	.+0      	; 0x1d40 <main+0x54a>
    1d40:	00 00       	nop
				_delay_ms(100);
				UART_TX_Str("6. Master Room\r\n");
    1d42:	83 e9       	ldi	r24, 0x93	; 147
    1d44:	94 e0       	ldi	r25, 0x04	; 4
    1d46:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1d4a:	2f ef       	ldi	r18, 0xFF	; 255
    1d4c:	81 ee       	ldi	r24, 0xE1	; 225
    1d4e:	94 e0       	ldi	r25, 0x04	; 4
    1d50:	21 50       	subi	r18, 0x01	; 1
    1d52:	80 40       	sbci	r24, 0x00	; 0
    1d54:	90 40       	sbci	r25, 0x00	; 0
    1d56:	e1 f7       	brne	.-8      	; 0x1d50 <main+0x55a>
    1d58:	00 c0       	rjmp	.+0      	; 0x1d5a <main+0x564>
    1d5a:	00 00       	nop
				_delay_ms(100);
				UART_TX_Str("Enter Your Command Number\r\n");
    1d5c:	8c e2       	ldi	r24, 0x2C	; 44
    1d5e:	94 e0       	ldi	r25, 0x04	; 4
    1d60:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
				while (!Get_Bit(UCSRA,7));
    1d64:	5f 9b       	sbis	0x0b, 7	; 11
    1d66:	fe cf       	rjmp	.-4      	; 0x1d64 <main+0x56e>
				Uint8 VAR=UDR;
    1d68:	8c b1       	in	r24, 0x0c	; 12
				switch (VAR)
    1d6a:	83 33       	cpi	r24, 0x33	; 51
    1d6c:	b9 f1       	breq	.+110    	; 0x1ddc <main+0x5e6>
    1d6e:	28 f4       	brcc	.+10     	; 0x1d7a <main+0x584>
    1d70:	81 33       	cpi	r24, 0x31	; 49
    1d72:	61 f0       	breq	.+24     	; 0x1d8c <main+0x596>
    1d74:	82 33       	cpi	r24, 0x32	; 50
    1d76:	f1 f0       	breq	.+60     	; 0x1db4 <main+0x5be>
    1d78:	20 c2       	rjmp	.+1088   	; 0x21ba <main+0x9c4>
    1d7a:	85 33       	cpi	r24, 0x35	; 53
    1d7c:	09 f4       	brne	.+2      	; 0x1d80 <main+0x58a>
    1d7e:	e0 c0       	rjmp	.+448    	; 0x1f40 <main+0x74a>
    1d80:	08 f4       	brcc	.+2      	; 0x1d84 <main+0x58e>
    1d82:	87 c0       	rjmp	.+270    	; 0x1e92 <main+0x69c>
    1d84:	86 33       	cpi	r24, 0x36	; 54
    1d86:	09 f4       	brne	.+2      	; 0x1d8a <main+0x594>
    1d88:	32 c1       	rjmp	.+612    	; 0x1fee <main+0x7f8>
    1d8a:	17 c2       	rjmp	.+1070   	; 0x21ba <main+0x9c4>
				{
					case '1':
					{
						UART_TX_Str("\r\n");
    1d8c:	8e eb       	ldi	r24, 0xBE	; 190
    1d8e:	97 e0       	ldi	r25, 0x07	; 7
    1d90:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						Servo_Open();
    1d94:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <Servo_Open>
    1d98:	2f ef       	ldi	r18, 0xFF	; 255
    1d9a:	83 ec       	ldi	r24, 0xC3	; 195
    1d9c:	99 e0       	ldi	r25, 0x09	; 9
    1d9e:	21 50       	subi	r18, 0x01	; 1
    1da0:	80 40       	sbci	r24, 0x00	; 0
    1da2:	90 40       	sbci	r25, 0x00	; 0
    1da4:	e1 f7       	brne	.-8      	; 0x1d9e <main+0x5a8>
    1da6:	00 c0       	rjmp	.+0      	; 0x1da8 <main+0x5b2>
    1da8:	00 00       	nop
						_delay_ms(200);
						UART_TX_Str("Door Opened\r\n");
    1daa:	84 ea       	ldi	r24, 0xA4	; 164
    1dac:	94 e0       	ldi	r25, 0x04	; 4
    1dae:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						break;
    1db2:	4e cf       	rjmp	.-356    	; 0x1c50 <main+0x45a>
					}//End of Case 1
					case '2':
					{
						UART_TX_Str("\r\n");
    1db4:	8e eb       	ldi	r24, 0xBE	; 190
    1db6:	97 e0       	ldi	r25, 0x07	; 7
    1db8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						Servo_Close();
    1dbc:	0e 94 83 13 	call	0x2706	; 0x2706 <Servo_Close>
    1dc0:	2f ef       	ldi	r18, 0xFF	; 255
    1dc2:	83 ec       	ldi	r24, 0xC3	; 195
    1dc4:	99 e0       	ldi	r25, 0x09	; 9
    1dc6:	21 50       	subi	r18, 0x01	; 1
    1dc8:	80 40       	sbci	r24, 0x00	; 0
    1dca:	90 40       	sbci	r25, 0x00	; 0
    1dcc:	e1 f7       	brne	.-8      	; 0x1dc6 <main+0x5d0>
    1dce:	00 c0       	rjmp	.+0      	; 0x1dd0 <main+0x5da>
    1dd0:	00 00       	nop
						_delay_ms(200);
						UART_TX_Str("Door Closed\r\n");
    1dd2:	82 eb       	ldi	r24, 0xB2	; 178
    1dd4:	94 e0       	ldi	r25, 0x04	; 4
    1dd6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						break;
    1dda:	3a cf       	rjmp	.-396    	; 0x1c50 <main+0x45a>
					}// End of case 2
					case  '3': //Room 1
					{
						UART_TX_Str("\r\n");
    1ddc:	8e eb       	ldi	r24, 0xBE	; 190
    1dde:	97 e0       	ldi	r25, 0x07	; 7
    1de0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str(" 1. Turn On Lamp\r\n");
    1de4:	80 ec       	ldi	r24, 0xC0	; 192
    1de6:	94 e0       	ldi	r25, 0x04	; 4
    1de8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1dec:	2f ef       	ldi	r18, 0xFF	; 255
    1dee:	83 ec       	ldi	r24, 0xC3	; 195
    1df0:	99 e0       	ldi	r25, 0x09	; 9
    1df2:	21 50       	subi	r18, 0x01	; 1
    1df4:	80 40       	sbci	r24, 0x00	; 0
    1df6:	90 40       	sbci	r25, 0x00	; 0
    1df8:	e1 f7       	brne	.-8      	; 0x1df2 <main+0x5fc>
    1dfa:	00 c0       	rjmp	.+0      	; 0x1dfc <main+0x606>
    1dfc:	00 00       	nop
						_delay_ms(200);
						UART_TX_Str(" 2. Turn Off Lamp\r\n");
    1dfe:	83 ed       	ldi	r24, 0xD3	; 211
    1e00:	94 e0       	ldi	r25, 0x04	; 4
    1e02:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						while (!Get_Bit(UCSRA,7));
    1e06:	5f 9b       	sbis	0x0b, 7	; 11
    1e08:	fe cf       	rjmp	.-4      	; 0x1e06 <main+0x610>
						switch (UDR)
    1e0a:	8c b1       	in	r24, 0x0c	; 12
    1e0c:	81 33       	cpi	r24, 0x31	; 49
    1e0e:	19 f0       	breq	.+6      	; 0x1e16 <main+0x620>
    1e10:	82 33       	cpi	r24, 0x32	; 50
    1e12:	e1 f0       	breq	.+56     	; 0x1e4c <main+0x656>
    1e14:	39 c0       	rjmp	.+114    	; 0x1e88 <main+0x692>
						{
							case '1':
							{
								if (Flag_Lamp==0)
    1e16:	80 91 17 08 	lds	r24, 0x0817	; 0x800817 <Flag_Lamp>
    1e1a:	81 11       	cpse	r24, r1
    1e1c:	12 c0       	rjmp	.+36     	; 0x1e42 <main+0x64c>
								{
									UART_TX_Str("\r\n");
    1e1e:	8e eb       	ldi	r24, 0xBE	; 190
    1e20:	97 e0       	ldi	r25, 0x07	; 7
    1e22:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									LED0_ON();
    1e26:	0e 94 80 0b 	call	0x1700	; 0x1700 <LED0_ON>
									Flag_Lamp=1;
    1e2a:	81 e0       	ldi	r24, 0x01	; 1
    1e2c:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <Flag_Lamp>
									UART_TX_Str("\r\n");
    1e30:	8e eb       	ldi	r24, 0xBE	; 190
    1e32:	97 e0       	ldi	r25, 0x07	; 7
    1e34:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str(" The Lamp Is Switched On\r\n");
    1e38:	87 ee       	ldi	r24, 0xE7	; 231
    1e3a:	94 e0       	ldi	r25, 0x04	; 4
    1e3c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1e40:	07 cf       	rjmp	.-498    	; 0x1c50 <main+0x45a>
								}
								else
								{
									UART_TX_Str(" The Lamp Is already On\r\n");
    1e42:	82 e0       	ldi	r24, 0x02	; 2
    1e44:	95 e0       	ldi	r25, 0x05	; 5
    1e46:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1e4a:	02 cf       	rjmp	.-508    	; 0x1c50 <main+0x45a>
								break;
								
							}// END Of Case 1
							case '2':
							{
								UART_TX_Str("\r\n");
    1e4c:	8e eb       	ldi	r24, 0xBE	; 190
    1e4e:	97 e0       	ldi	r25, 0x07	; 7
    1e50:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								if (Flag_Lamp==1)
    1e54:	80 91 17 08 	lds	r24, 0x0817	; 0x800817 <Flag_Lamp>
    1e58:	81 30       	cpi	r24, 0x01	; 1
    1e5a:	69 f4       	brne	.+26     	; 0x1e76 <main+0x680>
								{
									LED0_OFF();
    1e5c:	0e 94 86 0b 	call	0x170c	; 0x170c <LED0_OFF>
									UART_TX_Str("\r\n");
    1e60:	8e eb       	ldi	r24, 0xBE	; 190
    1e62:	97 e0       	ldi	r25, 0x07	; 7
    1e64:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str(" The Lamp Is Switched Off\r\n");
    1e68:	8c e1       	ldi	r24, 0x1C	; 28
    1e6a:	95 e0       	ldi	r25, 0x05	; 5
    1e6c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									Flag_Lamp=0;
    1e70:	10 92 17 08 	sts	0x0817, r1	; 0x800817 <Flag_Lamp>
    1e74:	ed ce       	rjmp	.-550    	; 0x1c50 <main+0x45a>
								}//End Of iF Condition
								else
								{
									UART_TX_Str("\r\n");
    1e76:	8e eb       	ldi	r24, 0xBE	; 190
    1e78:	97 e0       	ldi	r25, 0x07	; 7
    1e7a:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str(" The Lamp Is Already Off\r\n");
    1e7e:	88 e3       	ldi	r24, 0x38	; 56
    1e80:	95 e0       	ldi	r25, 0x05	; 5
    1e82:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1e86:	e4 ce       	rjmp	.-568    	; 0x1c50 <main+0x45a>
								}//End of else
								break;
							}//End Of case 2
							default:
							{
								UART_TX_Str("Wrong Input\r\n");
    1e88:	83 e5       	ldi	r24, 0x53	; 83
    1e8a:	95 e0       	ldi	r25, 0x05	; 5
    1e8c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1e90:	df ce       	rjmp	.-578    	; 0x1c50 <main+0x45a>
						
						break;
					}//End Of Case 3
					case '4' : //Room 2
					{
						UART_TX_Str("\r\n");
    1e92:	8e eb       	ldi	r24, 0xBE	; 190
    1e94:	97 e0       	ldi	r25, 0x07	; 7
    1e96:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str(" 1. Turn On Lamp\r\n");
    1e9a:	80 ec       	ldi	r24, 0xC0	; 192
    1e9c:	94 e0       	ldi	r25, 0x04	; 4
    1e9e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1ea2:	2f ef       	ldi	r18, 0xFF	; 255
    1ea4:	83 ec       	ldi	r24, 0xC3	; 195
    1ea6:	99 e0       	ldi	r25, 0x09	; 9
    1ea8:	21 50       	subi	r18, 0x01	; 1
    1eaa:	80 40       	sbci	r24, 0x00	; 0
    1eac:	90 40       	sbci	r25, 0x00	; 0
    1eae:	e1 f7       	brne	.-8      	; 0x1ea8 <main+0x6b2>
    1eb0:	00 c0       	rjmp	.+0      	; 0x1eb2 <main+0x6bc>
    1eb2:	00 00       	nop
						_delay_ms(200);
						UART_TX_Str(" 2. Turn off Lamp\r\n");
    1eb4:	81 e6       	ldi	r24, 0x61	; 97
    1eb6:	95 e0       	ldi	r25, 0x05	; 5
    1eb8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						while (!Get_Bit(UCSRA,7));
    1ebc:	5f 9b       	sbis	0x0b, 7	; 11
    1ebe:	fe cf       	rjmp	.-4      	; 0x1ebc <main+0x6c6>
						switch (UDR)
    1ec0:	8c b1       	in	r24, 0x0c	; 12
    1ec2:	81 33       	cpi	r24, 0x31	; 49
    1ec4:	19 f0       	breq	.+6      	; 0x1ecc <main+0x6d6>
    1ec6:	82 33       	cpi	r24, 0x32	; 50
    1ec8:	c1 f0       	breq	.+48     	; 0x1efa <main+0x704>
    1eca:	35 c0       	rjmp	.+106    	; 0x1f36 <main+0x740>
						{
							case '1':
							{
								if ( Flag_Lamp_2 ==0)
    1ecc:	80 91 16 08 	lds	r24, 0x0816	; 0x800816 <Flag_Lamp_2>
    1ed0:	81 11       	cpse	r24, r1
    1ed2:	0e c0       	rjmp	.+28     	; 0x1ef0 <main+0x6fa>
								{
									LED1_ON();
    1ed4:	0e 94 9c 0b 	call	0x1738	; 0x1738 <LED1_ON>
									Flag_Lamp_2=1;
    1ed8:	81 e0       	ldi	r24, 0x01	; 1
    1eda:	80 93 16 08 	sts	0x0816, r24	; 0x800816 <Flag_Lamp_2>
									UART_TX_Str("\r\n");
    1ede:	8e eb       	ldi	r24, 0xBE	; 190
    1ee0:	97 e0       	ldi	r25, 0x07	; 7
    1ee2:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str(" The Lamp Is Switched On\r\n");
    1ee6:	87 ee       	ldi	r24, 0xE7	; 231
    1ee8:	94 e0       	ldi	r25, 0x04	; 4
    1eea:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1eee:	b0 ce       	rjmp	.-672    	; 0x1c50 <main+0x45a>
								}
								else
								{
									UART_TX_Str(" The Lamp Is already On\r\n");
    1ef0:	82 e0       	ldi	r24, 0x02	; 2
    1ef2:	95 e0       	ldi	r25, 0x05	; 5
    1ef4:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1ef8:	ab ce       	rjmp	.-682    	; 0x1c50 <main+0x45a>
								}//End Of Else
								break;
							}// END Of Case 1
							case '2' :
							{
								UART_TX_Str("\r\n");
    1efa:	8e eb       	ldi	r24, 0xBE	; 190
    1efc:	97 e0       	ldi	r25, 0x07	; 7
    1efe:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								if (Flag_Lamp_2==1)
    1f02:	80 91 16 08 	lds	r24, 0x0816	; 0x800816 <Flag_Lamp_2>
    1f06:	81 30       	cpi	r24, 0x01	; 1
    1f08:	69 f4       	brne	.+26     	; 0x1f24 <main+0x72e>
								{
									LED0_OFF();
    1f0a:	0e 94 86 0b 	call	0x170c	; 0x170c <LED0_OFF>
									UART_TX_Str("\r\n");
    1f0e:	8e eb       	ldi	r24, 0xBE	; 190
    1f10:	97 e0       	ldi	r25, 0x07	; 7
    1f12:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str(" The Lamp Is Switched Off\r\n");
    1f16:	8c e1       	ldi	r24, 0x1C	; 28
    1f18:	95 e0       	ldi	r25, 0x05	; 5
    1f1a:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									Flag_Lamp_2=0;
    1f1e:	10 92 16 08 	sts	0x0816, r1	; 0x800816 <Flag_Lamp_2>
    1f22:	96 ce       	rjmp	.-724    	; 0x1c50 <main+0x45a>
								}//End Of iF Condition
								else
								{
									UART_TX_Str("\r\n");
    1f24:	8e eb       	ldi	r24, 0xBE	; 190
    1f26:	97 e0       	ldi	r25, 0x07	; 7
    1f28:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str(" The Lamp Is Already Off\r\n");
    1f2c:	88 e3       	ldi	r24, 0x38	; 56
    1f2e:	95 e0       	ldi	r25, 0x05	; 5
    1f30:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1f34:	8d ce       	rjmp	.-742    	; 0x1c50 <main+0x45a>
								}//End of else
								break;
							}//End Of case 2
							default:
							{
								UART_TX_Str("Wrong Input\r\n");
    1f36:	83 e5       	ldi	r24, 0x53	; 83
    1f38:	95 e0       	ldi	r25, 0x05	; 5
    1f3a:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								break;
    1f3e:	88 ce       	rjmp	.-752    	; 0x1c50 <main+0x45a>
						}//End OF Switch case
						break;
					}//End Of Case 4
					case '5': //Reception
					{
						UART_TX_Str("\r\n");
    1f40:	8e eb       	ldi	r24, 0xBE	; 190
    1f42:	97 e0       	ldi	r25, 0x07	; 7
    1f44:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str(" 1. Turn On Lamp\r\n");
    1f48:	80 ec       	ldi	r24, 0xC0	; 192
    1f4a:	94 e0       	ldi	r25, 0x04	; 4
    1f4c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1f50:	2f ef       	ldi	r18, 0xFF	; 255
    1f52:	83 ec       	ldi	r24, 0xC3	; 195
    1f54:	99 e0       	ldi	r25, 0x09	; 9
    1f56:	21 50       	subi	r18, 0x01	; 1
    1f58:	80 40       	sbci	r24, 0x00	; 0
    1f5a:	90 40       	sbci	r25, 0x00	; 0
    1f5c:	e1 f7       	brne	.-8      	; 0x1f56 <main+0x760>
    1f5e:	00 c0       	rjmp	.+0      	; 0x1f60 <main+0x76a>
    1f60:	00 00       	nop
						_delay_ms(200);
						UART_TX_Str(" 2. Turn off Lamp\r\n");
    1f62:	81 e6       	ldi	r24, 0x61	; 97
    1f64:	95 e0       	ldi	r25, 0x05	; 5
    1f66:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						while (!Get_Bit(UCSRA,7));
    1f6a:	5f 9b       	sbis	0x0b, 7	; 11
    1f6c:	fe cf       	rjmp	.-4      	; 0x1f6a <main+0x774>
						switch (UDR)
    1f6e:	8c b1       	in	r24, 0x0c	; 12
    1f70:	81 33       	cpi	r24, 0x31	; 49
    1f72:	19 f0       	breq	.+6      	; 0x1f7a <main+0x784>
    1f74:	82 33       	cpi	r24, 0x32	; 50
    1f76:	c1 f0       	breq	.+48     	; 0x1fa8 <main+0x7b2>
    1f78:	35 c0       	rjmp	.+106    	; 0x1fe4 <main+0x7ee>
						{
							case '1':
							{
								if (Flag_Lamp_3==0)
    1f7a:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <Flag_Lamp_3>
    1f7e:	81 11       	cpse	r24, r1
    1f80:	0e c0       	rjmp	.+28     	; 0x1f9e <main+0x7a8>
								{
									LED2_ON();
    1f82:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LED2_ON>
									Flag_Lamp_3=1;
    1f86:	81 e0       	ldi	r24, 0x01	; 1
    1f88:	80 93 15 08 	sts	0x0815, r24	; 0x800815 <Flag_Lamp_3>
									UART_TX_Str("\r\n");
    1f8c:	8e eb       	ldi	r24, 0xBE	; 190
    1f8e:	97 e0       	ldi	r25, 0x07	; 7
    1f90:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str(" The Lamp Is Switched On\r\n");
    1f94:	87 ee       	ldi	r24, 0xE7	; 231
    1f96:	94 e0       	ldi	r25, 0x04	; 4
    1f98:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1f9c:	59 ce       	rjmp	.-846    	; 0x1c50 <main+0x45a>
								}
								else
								{
									UART_TX_Str(" The Lamp Is already On\r\n");
    1f9e:	82 e0       	ldi	r24, 0x02	; 2
    1fa0:	95 e0       	ldi	r25, 0x05	; 5
    1fa2:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1fa6:	54 ce       	rjmp	.-856    	; 0x1c50 <main+0x45a>
								}//End Of Else
								break;
							}// END Of Case 1
							case '2' :
							{
								UART_TX_Str("\r\n");
    1fa8:	8e eb       	ldi	r24, 0xBE	; 190
    1faa:	97 e0       	ldi	r25, 0x07	; 7
    1fac:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								if (Flag_Lamp_3==1)
    1fb0:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <Flag_Lamp_3>
    1fb4:	81 30       	cpi	r24, 0x01	; 1
    1fb6:	69 f4       	brne	.+26     	; 0x1fd2 <main+0x7dc>
								{
									LED2_OFF();
    1fb8:	0e 94 be 0b 	call	0x177c	; 0x177c <LED2_OFF>
									UART_TX_Str("\r\n");
    1fbc:	8e eb       	ldi	r24, 0xBE	; 190
    1fbe:	97 e0       	ldi	r25, 0x07	; 7
    1fc0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str(" The Lamp Is Switched Off\r\n");
    1fc4:	8c e1       	ldi	r24, 0x1C	; 28
    1fc6:	95 e0       	ldi	r25, 0x05	; 5
    1fc8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									Flag_Lamp_3=0;
    1fcc:	10 92 15 08 	sts	0x0815, r1	; 0x800815 <Flag_Lamp_3>
    1fd0:	3f ce       	rjmp	.-898    	; 0x1c50 <main+0x45a>
								}//End Of iF Condition
								else
								{
									UART_TX_Str("\r\n");
    1fd2:	8e eb       	ldi	r24, 0xBE	; 190
    1fd4:	97 e0       	ldi	r25, 0x07	; 7
    1fd6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str(" The Lamp Is Already Off\r\n");
    1fda:	88 e3       	ldi	r24, 0x38	; 56
    1fdc:	95 e0       	ldi	r25, 0x05	; 5
    1fde:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1fe2:	36 ce       	rjmp	.-916    	; 0x1c50 <main+0x45a>
								}//End of else
								break;
							}//End Of case 2
							default:
							{
								UART_TX_Str("Wrong Input\r\n");
    1fe4:	83 e5       	ldi	r24, 0x53	; 83
    1fe6:	95 e0       	ldi	r25, 0x05	; 5
    1fe8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								break;
    1fec:	31 ce       	rjmp	.-926    	; 0x1c50 <main+0x45a>
						}//End OF Switch case
						break;
					}//End Of Case 5
					case '6': //Master Room
					{
						UART_TX_Str("\r\n");
    1fee:	8e eb       	ldi	r24, 0xBE	; 190
    1ff0:	97 e0       	ldi	r25, 0x07	; 7
    1ff2:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str(" 1. Turn On Lamp\r\n");
    1ff6:	80 ec       	ldi	r24, 0xC0	; 192
    1ff8:	94 e0       	ldi	r25, 0x04	; 4
    1ffa:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    1ffe:	2f ef       	ldi	r18, 0xFF	; 255
    2000:	83 ec       	ldi	r24, 0xC3	; 195
    2002:	99 e0       	ldi	r25, 0x09	; 9
    2004:	21 50       	subi	r18, 0x01	; 1
    2006:	80 40       	sbci	r24, 0x00	; 0
    2008:	90 40       	sbci	r25, 0x00	; 0
    200a:	e1 f7       	brne	.-8      	; 0x2004 <main+0x80e>
    200c:	00 c0       	rjmp	.+0      	; 0x200e <main+0x818>
    200e:	00 00       	nop
						_delay_ms(200);
						UART_TX_Str(" 2. Turn off Lamp\r\n");
    2010:	81 e6       	ldi	r24, 0x61	; 97
    2012:	95 e0       	ldi	r25, 0x05	; 5
    2014:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    2018:	2f ef       	ldi	r18, 0xFF	; 255
    201a:	83 ec       	ldi	r24, 0xC3	; 195
    201c:	99 e0       	ldi	r25, 0x09	; 9
    201e:	21 50       	subi	r18, 0x01	; 1
    2020:	80 40       	sbci	r24, 0x00	; 0
    2022:	90 40       	sbci	r25, 0x00	; 0
    2024:	e1 f7       	brne	.-8      	; 0x201e <main+0x828>
    2026:	00 c0       	rjmp	.+0      	; 0x2028 <main+0x832>
    2028:	00 00       	nop
						_delay_ms(200);
						UART_TX_Str(" 3. Dimmer Lamp\r\n");
    202a:	85 e7       	ldi	r24, 0x75	; 117
    202c:	95 e0       	ldi	r25, 0x05	; 5
    202e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						while (!Get_Bit(UCSRA,7));
    2032:	5f 9b       	sbis	0x0b, 7	; 11
    2034:	fe cf       	rjmp	.-4      	; 0x2032 <main+0x83c>
						switch (UDR)
    2036:	8c b1       	in	r24, 0x0c	; 12
    2038:	82 33       	cpi	r24, 0x32	; 50
    203a:	e1 f0       	breq	.+56     	; 0x2074 <main+0x87e>
    203c:	83 33       	cpi	r24, 0x33	; 51
    203e:	c1 f1       	breq	.+112    	; 0x20b0 <main+0x8ba>
    2040:	81 33       	cpi	r24, 0x31	; 49
    2042:	09 f0       	breq	.+2      	; 0x2046 <main+0x850>
    2044:	05 ce       	rjmp	.-1014   	; 0x1c50 <main+0x45a>
						{
							case '1':
							{
								if (Flag_Lamp_4==0)
    2046:	80 91 14 08 	lds	r24, 0x0814	; 0x800814 <Flag_Lamp_4>
    204a:	81 11       	cpse	r24, r1
    204c:	0e c0       	rjmp	.+28     	; 0x206a <main+0x874>
								{
									LED3_ON();
    204e:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <LED3_ON>
									Flag_Lamp_4=1;
    2052:	81 e0       	ldi	r24, 0x01	; 1
    2054:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <Flag_Lamp_4>
									UART_TX_Str("\r\n");
    2058:	8e eb       	ldi	r24, 0xBE	; 190
    205a:	97 e0       	ldi	r25, 0x07	; 7
    205c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str(" The Lamp Is Switched On\r\n");
    2060:	87 ee       	ldi	r24, 0xE7	; 231
    2062:	94 e0       	ldi	r25, 0x04	; 4
    2064:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    2068:	f3 cd       	rjmp	.-1050   	; 0x1c50 <main+0x45a>
								}
								else
								{
									UART_TX_Str(" The Lamp Is already On\r\n");
    206a:	82 e0       	ldi	r24, 0x02	; 2
    206c:	95 e0       	ldi	r25, 0x05	; 5
    206e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    2072:	ee cd       	rjmp	.-1060   	; 0x1c50 <main+0x45a>
								}//End Of else
								break;
							}// END Of Case 1
							case '2' :
							{
								UART_TX_Str("\r\n");
    2074:	8e eb       	ldi	r24, 0xBE	; 190
    2076:	97 e0       	ldi	r25, 0x07	; 7
    2078:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								if (Flag_Lamp_4==1)
    207c:	80 91 14 08 	lds	r24, 0x0814	; 0x800814 <Flag_Lamp_4>
    2080:	81 30       	cpi	r24, 0x01	; 1
    2082:	69 f4       	brne	.+26     	; 0x209e <main+0x8a8>
								{
									LED3_OFF();
    2084:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <LED3_OFF>
									UART_TX_Str("\r\n");
    2088:	8e eb       	ldi	r24, 0xBE	; 190
    208a:	97 e0       	ldi	r25, 0x07	; 7
    208c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str(" The Lamp Is Switched Off\r\n");
    2090:	8c e1       	ldi	r24, 0x1C	; 28
    2092:	95 e0       	ldi	r25, 0x05	; 5
    2094:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									Flag_Lamp_4=0;
    2098:	10 92 14 08 	sts	0x0814, r1	; 0x800814 <Flag_Lamp_4>
    209c:	d9 cd       	rjmp	.-1102   	; 0x1c50 <main+0x45a>
								}//End Of iF Condition
								else
								{
									UART_TX_Str("\r\n");
    209e:	8e eb       	ldi	r24, 0xBE	; 190
    20a0:	97 e0       	ldi	r25, 0x07	; 7
    20a2:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
									UART_TX_Str(" The Lamp Is Already Off\r\n");
    20a6:	88 e3       	ldi	r24, 0x38	; 56
    20a8:	95 e0       	ldi	r25, 0x05	; 5
    20aa:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    20ae:	d0 cd       	rjmp	.-1120   	; 0x1c50 <main+0x45a>
							}//End Of case 2
							case '3':
							{
								Uint8 Check=0;
								
								Timer0_Init();
    20b0:	0e 94 8a 13 	call	0x2714	; 0x2714 <Timer0_Init>
								UART_TX_Str("Dimmer lamp\r\n");
    20b4:	87 e8       	ldi	r24, 0x87	; 135
    20b6:	95 e0       	ldi	r25, 0x05	; 5
    20b8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								UART_TX_Str("Choose the suitable intensity\r\n");
    20bc:	85 e9       	ldi	r24, 0x95	; 149
    20be:	95 e0       	ldi	r25, 0x05	; 5
    20c0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								UART_TX_Str("1- Very Low\r\n");
    20c4:	85 eb       	ldi	r24, 0xB5	; 181
    20c6:	95 e0       	ldi	r25, 0x05	; 5
    20c8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								UART_TX_Str("2- Low\r\n");
    20cc:	83 ec       	ldi	r24, 0xC3	; 195
    20ce:	95 e0       	ldi	r25, 0x05	; 5
    20d0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								UART_TX_Str("3- Medium\r\n");
    20d4:	8c ec       	ldi	r24, 0xCC	; 204
    20d6:	95 e0       	ldi	r25, 0x05	; 5
    20d8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								UART_TX_Str("4- High\r\n");
    20dc:	88 ed       	ldi	r24, 0xD8	; 216
    20de:	95 e0       	ldi	r25, 0x05	; 5
    20e0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								UART_TX_Str("5- Very High\r\n");
    20e4:	82 ee       	ldi	r24, 0xE2	; 226
    20e6:	95 e0       	ldi	r25, 0x05	; 5
    20e8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								UART_TX_Str("6- turn off\r\n");
    20ec:	81 ef       	ldi	r24, 0xF1	; 241
    20ee:	95 e0       	ldi	r25, 0x05	; 5
    20f0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								
								while (!Get_Bit(UCSRA,7));
    20f4:	5f 9b       	sbis	0x0b, 7	; 11
    20f6:	fe cf       	rjmp	.-4      	; 0x20f4 <main+0x8fe>
    20f8:	10 e0       	ldi	r17, 0x00	; 0
    20fa:	5b c0       	rjmp	.+182    	; 0x21b2 <main+0x9bc>
								
								while (!Check)
								{
									
									Check=1;
									switch(UDR)
    20fc:	8c b1       	in	r24, 0x0c	; 12
    20fe:	83 33       	cpi	r24, 0x33	; 51
    2100:	11 f1       	breq	.+68     	; 0x2146 <main+0x950>
    2102:	28 f4       	brcc	.+10     	; 0x210e <main+0x918>
    2104:	81 33       	cpi	r24, 0x31	; 49
    2106:	49 f0       	breq	.+18     	; 0x211a <main+0x924>
    2108:	82 33       	cpi	r24, 0x32	; 50
    210a:	91 f0       	breq	.+36     	; 0x2130 <main+0x93a>
    210c:	4e c0       	rjmp	.+156    	; 0x21aa <main+0x9b4>
    210e:	85 33       	cpi	r24, 0x35	; 53
    2110:	81 f1       	breq	.+96     	; 0x2172 <main+0x97c>
    2112:	20 f1       	brcs	.+72     	; 0x215c <main+0x966>
    2114:	86 33       	cpi	r24, 0x36	; 54
    2116:	c1 f1       	breq	.+112    	; 0x2188 <main+0x992>
    2118:	48 c0       	rjmp	.+144    	; 0x21aa <main+0x9b4>
									{
										
										case '1':
										{
											Flag_Dimmer=1;
    211a:	81 e0       	ldi	r24, 0x01	; 1
    211c:	80 93 10 08 	sts	0x0810, r24	; 0x800810 <Flag_Dimmer>
											PWM0_Gen(20);
    2120:	60 e0       	ldi	r22, 0x00	; 0
    2122:	70 e0       	ldi	r23, 0x00	; 0
    2124:	80 ea       	ldi	r24, 0xA0	; 160
    2126:	91 e4       	ldi	r25, 0x41	; 65
    2128:	0e 94 a0 13 	call	0x2740	; 0x2740 <PWM0_Gen>
								while (!Get_Bit(UCSRA,7));
								
								while (!Check)
								{
									
									Check=1;
    212c:	11 e0       	ldi	r17, 0x01	; 1
										
										case '1':
										{
											Flag_Dimmer=1;
											PWM0_Gen(20);
											break;
    212e:	41 c0       	rjmp	.+130    	; 0x21b2 <main+0x9bc>
										}//End Of case 1
										case '2':
										{
											Flag_Dimmer=1;
    2130:	81 e0       	ldi	r24, 0x01	; 1
    2132:	80 93 10 08 	sts	0x0810, r24	; 0x800810 <Flag_Dimmer>
											PWM0_Gen(40);
    2136:	60 e0       	ldi	r22, 0x00	; 0
    2138:	70 e0       	ldi	r23, 0x00	; 0
    213a:	80 e2       	ldi	r24, 0x20	; 32
    213c:	92 e4       	ldi	r25, 0x42	; 66
    213e:	0e 94 a0 13 	call	0x2740	; 0x2740 <PWM0_Gen>
								while (!Get_Bit(UCSRA,7));
								
								while (!Check)
								{
									
									Check=1;
    2142:	11 e0       	ldi	r17, 0x01	; 1
										}//End Of case 1
										case '2':
										{
											Flag_Dimmer=1;
											PWM0_Gen(40);
											break;
    2144:	36 c0       	rjmp	.+108    	; 0x21b2 <main+0x9bc>
										}//End Of case 2
										case '3':
										{
											Flag_Dimmer=1;
    2146:	81 e0       	ldi	r24, 0x01	; 1
    2148:	80 93 10 08 	sts	0x0810, r24	; 0x800810 <Flag_Dimmer>
											PWM0_Gen(60);
    214c:	60 e0       	ldi	r22, 0x00	; 0
    214e:	70 e0       	ldi	r23, 0x00	; 0
    2150:	80 e7       	ldi	r24, 0x70	; 112
    2152:	92 e4       	ldi	r25, 0x42	; 66
    2154:	0e 94 a0 13 	call	0x2740	; 0x2740 <PWM0_Gen>
								while (!Get_Bit(UCSRA,7));
								
								while (!Check)
								{
									
									Check=1;
    2158:	11 e0       	ldi	r17, 0x01	; 1
										}//End Of case 2
										case '3':
										{
											Flag_Dimmer=1;
											PWM0_Gen(60);
											break;
    215a:	2b c0       	rjmp	.+86     	; 0x21b2 <main+0x9bc>
										}//End Of case 3
										case '4':
										{
											Flag_Dimmer=1;
    215c:	81 e0       	ldi	r24, 0x01	; 1
    215e:	80 93 10 08 	sts	0x0810, r24	; 0x800810 <Flag_Dimmer>
											PWM0_Gen(80);
    2162:	60 e0       	ldi	r22, 0x00	; 0
    2164:	70 e0       	ldi	r23, 0x00	; 0
    2166:	80 ea       	ldi	r24, 0xA0	; 160
    2168:	92 e4       	ldi	r25, 0x42	; 66
    216a:	0e 94 a0 13 	call	0x2740	; 0x2740 <PWM0_Gen>
								while (!Get_Bit(UCSRA,7));
								
								while (!Check)
								{
									
									Check=1;
    216e:	11 e0       	ldi	r17, 0x01	; 1
										}//End Of case 3
										case '4':
										{
											Flag_Dimmer=1;
											PWM0_Gen(80);
											break;
    2170:	20 c0       	rjmp	.+64     	; 0x21b2 <main+0x9bc>
										}//End Of case 4
										case '5':
										{
											Flag_Dimmer=1;
    2172:	81 e0       	ldi	r24, 0x01	; 1
    2174:	80 93 10 08 	sts	0x0810, r24	; 0x800810 <Flag_Dimmer>
											PWM0_Gen(100);
    2178:	60 e0       	ldi	r22, 0x00	; 0
    217a:	70 e0       	ldi	r23, 0x00	; 0
    217c:	88 ec       	ldi	r24, 0xC8	; 200
    217e:	92 e4       	ldi	r25, 0x42	; 66
    2180:	0e 94 a0 13 	call	0x2740	; 0x2740 <PWM0_Gen>
								while (!Get_Bit(UCSRA,7));
								
								while (!Check)
								{
									
									Check=1;
    2184:	11 e0       	ldi	r17, 0x01	; 1
										}//End Of case 4
										case '5':
										{
											Flag_Dimmer=1;
											PWM0_Gen(100);
											break;
    2186:	15 c0       	rjmp	.+42     	; 0x21b2 <main+0x9bc>
										}//End Of case 5
										case '6':
										{
											if (Flag_Dimmer==0)
    2188:	80 91 10 08 	lds	r24, 0x0810	; 0x800810 <Flag_Dimmer>
    218c:	81 11       	cpse	r24, r1
    218e:	06 c0       	rjmp	.+12     	; 0x219c <main+0x9a6>
											{
												UART_TX_Str("Dimmer lamp is off\r\n");
    2190:	8f ef       	ldi	r24, 0xFF	; 255
    2192:	95 e0       	ldi	r25, 0x05	; 5
    2194:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								while (!Get_Bit(UCSRA,7));
								
								while (!Check)
								{
									
									Check=1;
    2198:	11 e0       	ldi	r17, 0x01	; 1
    219a:	0b c0       	rjmp	.+22     	; 0x21b2 <main+0x9bc>
											{
												UART_TX_Str("Dimmer lamp is off\r\n");
											}
											else
											{
												PWM0_Gen(0);
    219c:	60 e0       	ldi	r22, 0x00	; 0
    219e:	70 e0       	ldi	r23, 0x00	; 0
    21a0:	cb 01       	movw	r24, r22
    21a2:	0e 94 a0 13 	call	0x2740	; 0x2740 <PWM0_Gen>
								while (!Get_Bit(UCSRA,7));
								
								while (!Check)
								{
									
									Check=1;
    21a6:	11 e0       	ldi	r17, 0x01	; 1
    21a8:	04 c0       	rjmp	.+8      	; 0x21b2 <main+0x9bc>
											break;
										}//End Of case 6
										default:
										{
											Check=0;
											UART_TX_Str("Wrong Input\r\n");
    21aa:	83 e5       	ldi	r24, 0x53	; 83
    21ac:	95 e0       	ldi	r25, 0x05	; 5
    21ae:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								UART_TX_Str("5- Very High\r\n");
								UART_TX_Str("6- turn off\r\n");
								
								while (!Get_Bit(UCSRA,7));
								
								while (!Check)
    21b2:	11 23       	and	r17, r17
    21b4:	09 f4       	brne	.+2      	; 0x21b8 <main+0x9c2>
    21b6:	a2 cf       	rjmp	.-188    	; 0x20fc <main+0x906>
    21b8:	4b cd       	rjmp	.-1386   	; 0x1c50 <main+0x45a>
							
						break;
					}//End Of Case 6
					default:
					{
						UART_TX_Str("Wrong Input\r\n");
    21ba:	83 e5       	ldi	r24, 0x53	; 83
    21bc:	95 e0       	ldi	r25, 0x05	; 5
    21be:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						break;
    21c2:	46 cd       	rjmp	.-1396   	; 0x1c50 <main+0x45a>
			break;}
			
			/*Function Control System  */
			case '2': // Check For System
			{
				UART_TX_Str("\r\n");
    21c4:	8e eb       	ldi	r24, 0xBE	; 190
    21c6:	97 e0       	ldi	r25, 0x07	; 7
    21c8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
				UART_TX_Str("1. Room 1\r\n");
    21cc:	84 e1       	ldi	r24, 0x14	; 20
    21ce:	96 e0       	ldi	r25, 0x06	; 6
    21d0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    21d4:	2f ef       	ldi	r18, 0xFF	; 255
    21d6:	81 ee       	ldi	r24, 0xE1	; 225
    21d8:	94 e0       	ldi	r25, 0x04	; 4
    21da:	21 50       	subi	r18, 0x01	; 1
    21dc:	80 40       	sbci	r24, 0x00	; 0
    21de:	90 40       	sbci	r25, 0x00	; 0
    21e0:	e1 f7       	brne	.-8      	; 0x21da <main+0x9e4>
    21e2:	00 c0       	rjmp	.+0      	; 0x21e4 <main+0x9ee>
    21e4:	00 00       	nop
				_delay_ms(100);
				UART_TX_Str("2. Room 2\r\n");
    21e6:	80 e2       	ldi	r24, 0x20	; 32
    21e8:	96 e0       	ldi	r25, 0x06	; 6
    21ea:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    21ee:	2f ef       	ldi	r18, 0xFF	; 255
    21f0:	81 ee       	ldi	r24, 0xE1	; 225
    21f2:	94 e0       	ldi	r25, 0x04	; 4
    21f4:	21 50       	subi	r18, 0x01	; 1
    21f6:	80 40       	sbci	r24, 0x00	; 0
    21f8:	90 40       	sbci	r25, 0x00	; 0
    21fa:	e1 f7       	brne	.-8      	; 0x21f4 <main+0x9fe>
    21fc:	00 c0       	rjmp	.+0      	; 0x21fe <main+0xa08>
    21fe:	00 00       	nop
				_delay_ms(100);
				UART_TX_Str("3. Reception\r\n");
    2200:	8c e2       	ldi	r24, 0x2C	; 44
    2202:	96 e0       	ldi	r25, 0x06	; 6
    2204:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    2208:	2f ef       	ldi	r18, 0xFF	; 255
    220a:	81 ee       	ldi	r24, 0xE1	; 225
    220c:	94 e0       	ldi	r25, 0x04	; 4
    220e:	21 50       	subi	r18, 0x01	; 1
    2210:	80 40       	sbci	r24, 0x00	; 0
    2212:	90 40       	sbci	r25, 0x00	; 0
    2214:	e1 f7       	brne	.-8      	; 0x220e <main+0xa18>
    2216:	00 c0       	rjmp	.+0      	; 0x2218 <main+0xa22>
    2218:	00 00       	nop
				_delay_ms(100);
				UART_TX_Str("4. Master Room\r\n");
    221a:	8b e3       	ldi	r24, 0x3B	; 59
    221c:	96 e0       	ldi	r25, 0x06	; 6
    221e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    2222:	2f ef       	ldi	r18, 0xFF	; 255
    2224:	81 ee       	ldi	r24, 0xE1	; 225
    2226:	94 e0       	ldi	r25, 0x04	; 4
    2228:	21 50       	subi	r18, 0x01	; 1
    222a:	80 40       	sbci	r24, 0x00	; 0
    222c:	90 40       	sbci	r25, 0x00	; 0
    222e:	e1 f7       	brne	.-8      	; 0x2228 <main+0xa32>
    2230:	00 c0       	rjmp	.+0      	; 0x2232 <main+0xa3c>
    2232:	00 00       	nop
				_delay_ms(100);
				UART_TX_Str("5. Check The Temperature\r\n");
    2234:	8c e4       	ldi	r24, 0x4C	; 76
    2236:	96 e0       	ldi	r25, 0x06	; 6
    2238:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
				UART_TX_Str("Enter Your Command Number\r\n");
    223c:	8c e2       	ldi	r24, 0x2C	; 44
    223e:	94 e0       	ldi	r25, 0x04	; 4
    2240:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
				while (!Get_Bit(UCSRA,7));
    2244:	5f 9b       	sbis	0x0b, 7	; 11
    2246:	fe cf       	rjmp	.-4      	; 0x2244 <main+0xa4e>
				switch (UDR)
    2248:	8c b1       	in	r24, 0x0c	; 12
    224a:	82 33       	cpi	r24, 0x32	; 50
    224c:	01 f1       	breq	.+64     	; 0x228e <main+0xa98>
    224e:	18 f4       	brcc	.+6      	; 0x2256 <main+0xa60>
    2250:	81 33       	cpi	r24, 0x31	; 49
    2252:	39 f0       	breq	.+14     	; 0x2262 <main+0xa6c>
    2254:	5e c0       	rjmp	.+188    	; 0x2312 <main+0xb1c>
    2256:	83 33       	cpi	r24, 0x33	; 51
    2258:	81 f1       	breq	.+96     	; 0x22ba <main+0xac4>
    225a:	84 33       	cpi	r24, 0x34	; 52
    225c:	09 f4       	brne	.+2      	; 0x2260 <main+0xa6a>
    225e:	43 c0       	rjmp	.+134    	; 0x22e6 <main+0xaf0>
    2260:	58 c0       	rjmp	.+176    	; 0x2312 <main+0xb1c>
				{
					case '1': //Room 1
					{
						if (Flag_Lamp ==1)
    2262:	80 91 17 08 	lds	r24, 0x0817	; 0x800817 <Flag_Lamp>
    2266:	81 30       	cpi	r24, 0x01	; 1
    2268:	49 f4       	brne	.+18     	; 0x227c <main+0xa86>
						{
							UART_TX_Str("\r\n");
    226a:	8e eb       	ldi	r24, 0xBE	; 190
    226c:	97 e0       	ldi	r25, 0x07	; 7
    226e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							UART_TX_Str("The Lamp Is On In Room 1\r\n");
    2272:	87 e6       	ldi	r24, 0x67	; 103
    2274:	96 e0       	ldi	r25, 0x06	; 6
    2276:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    227a:	ea cc       	rjmp	.-1580   	; 0x1c50 <main+0x45a>
						}//End Of If Condition
						else
						{
							UART_TX_Str("\r\n");
    227c:	8e eb       	ldi	r24, 0xBE	; 190
    227e:	97 e0       	ldi	r25, 0x07	; 7
    2280:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							UART_TX_Str("The Lamp Is off In Room 1\r\n");
    2284:	82 e8       	ldi	r24, 0x82	; 130
    2286:	96 e0       	ldi	r25, 0x06	; 6
    2288:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    228c:	e1 cc       	rjmp	.-1598   	; 0x1c50 <main+0x45a>
						}//End Of else Condition
						break;
					}//End OF case 1
					case '2': //Room 2
					{
						if (Flag_Lamp_2 ==1)
    228e:	80 91 16 08 	lds	r24, 0x0816	; 0x800816 <Flag_Lamp_2>
    2292:	81 30       	cpi	r24, 0x01	; 1
    2294:	49 f4       	brne	.+18     	; 0x22a8 <main+0xab2>
						{
							UART_TX_Str("\r\n");
    2296:	8e eb       	ldi	r24, 0xBE	; 190
    2298:	97 e0       	ldi	r25, 0x07	; 7
    229a:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							UART_TX_Str("The Lamp Is On In Room 2\r\n");
    229e:	8e e9       	ldi	r24, 0x9E	; 158
    22a0:	96 e0       	ldi	r25, 0x06	; 6
    22a2:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    22a6:	d4 cc       	rjmp	.-1624   	; 0x1c50 <main+0x45a>
						}//End Of If Condition
						else
						{
							UART_TX_Str("\r\n");
    22a8:	8e eb       	ldi	r24, 0xBE	; 190
    22aa:	97 e0       	ldi	r25, 0x07	; 7
    22ac:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							UART_TX_Str("The Lamp Is off In Room 2\r\n");
    22b0:	89 eb       	ldi	r24, 0xB9	; 185
    22b2:	96 e0       	ldi	r25, 0x06	; 6
    22b4:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    22b8:	cb cc       	rjmp	.-1642   	; 0x1c50 <main+0x45a>
						}//End Of else Condition
						break;
					}//End Of case 2
					case '3': //Reception
					{
						if (Flag_Lamp_3 ==1)
    22ba:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <Flag_Lamp_3>
    22be:	81 30       	cpi	r24, 0x01	; 1
    22c0:	49 f4       	brne	.+18     	; 0x22d4 <main+0xade>
						{
							UART_TX_Str("\r\n");
    22c2:	8e eb       	ldi	r24, 0xBE	; 190
    22c4:	97 e0       	ldi	r25, 0x07	; 7
    22c6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							UART_TX_Str("The Lamp Is On In The Reception\r\n");
    22ca:	85 ed       	ldi	r24, 0xD5	; 213
    22cc:	96 e0       	ldi	r25, 0x06	; 6
    22ce:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    22d2:	be cc       	rjmp	.-1668   	; 0x1c50 <main+0x45a>
						}//End Of If Condition
						else
						{
							UART_TX_Str("\r\n");
    22d4:	8e eb       	ldi	r24, 0xBE	; 190
    22d6:	97 e0       	ldi	r25, 0x07	; 7
    22d8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							UART_TX_Str("The Lamp Is off In Reception\r\n");
    22dc:	87 ef       	ldi	r24, 0xF7	; 247
    22de:	96 e0       	ldi	r25, 0x06	; 6
    22e0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    22e4:	b5 cc       	rjmp	.-1686   	; 0x1c50 <main+0x45a>
						}//End Of else Condition
						break;
					}//End Of Case 3
					case'4': //Master Room
					{
						if (Flag_Lamp_4 ==1)
    22e6:	80 91 14 08 	lds	r24, 0x0814	; 0x800814 <Flag_Lamp_4>
    22ea:	81 30       	cpi	r24, 0x01	; 1
    22ec:	49 f4       	brne	.+18     	; 0x2300 <main+0xb0a>
						{
							UART_TX_Str("\r\n");
    22ee:	8e eb       	ldi	r24, 0xBE	; 190
    22f0:	97 e0       	ldi	r25, 0x07	; 7
    22f2:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							UART_TX_Str("The Lamp Is On In Master Room \r\n");
    22f6:	86 e1       	ldi	r24, 0x16	; 22
    22f8:	97 e0       	ldi	r25, 0x07	; 7
    22fa:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    22fe:	a8 cc       	rjmp	.-1712   	; 0x1c50 <main+0x45a>
						}//End Of If Condition
						else
						{
							UART_TX_Str("\r\n");
    2300:	8e eb       	ldi	r24, 0xBE	; 190
    2302:	97 e0       	ldi	r25, 0x07	; 7
    2304:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
							UART_TX_Str("The Lamp Is off In Master Room \r\n");
    2308:	87 e3       	ldi	r24, 0x37	; 55
    230a:	97 e0       	ldi	r25, 0x07	; 7
    230c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    2310:	9f cc       	rjmp	.-1730   	; 0x1c50 <main+0x45a>
						}//End Of else Condition
						break;
					}//End of case 4
					default:
					{
						UART_TX_Str("Wrong Input\r\n");
    2312:	83 e5       	ldi	r24, 0x53	; 83
    2314:	95 e0       	ldi	r25, 0x05	; 5
    2316:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						break;
    231a:	9a cc       	rjmp	.-1740   	; 0x1c50 <main+0x45a>
			/*-----------------------------------------------------------------------------------------------*/
			
			/*------------------------------------------>ADD USER<------------------------------------------*/
			case '3': //Add User
			{
				UART_TX_Str("\r\n");
    231c:	8e eb       	ldi	r24, 0xBE	; 190
    231e:	97 e0       	ldi	r25, 0x07	; 7
    2320:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
				UART_TX_Str("1. Keypad\r\n"); // USER for LCD Mode (Can login only from Keypad)
    2324:	89 e5       	ldi	r24, 0x59	; 89
    2326:	97 e0       	ldi	r25, 0x07	; 7
    2328:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
				UART_TX_Str("2. PC\r\n"); // USER for UART Mode (Can login only from UART)
    232c:	85 e6       	ldi	r24, 0x65	; 101
    232e:	97 e0       	ldi	r25, 0x07	; 7
    2330:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
				UART_RX_Char();
    2334:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
				while (!Get_Bit(UCSRA,7));
    2338:	5f 9b       	sbis	0x0b, 7	; 11
    233a:	fe cf       	rjmp	.-4      	; 0x2338 <main+0xb42>
				Uint8 Var_1=UDR;
    233c:	8c b1       	in	r24, 0x0c	; 12
				switch (Var_1)
    233e:	81 33       	cpi	r24, 0x31	; 49
    2340:	21 f0       	breq	.+8      	; 0x234a <main+0xb54>
    2342:	82 33       	cpi	r24, 0x32	; 50
    2344:	09 f4       	brne	.+2      	; 0x2348 <main+0xb52>
    2346:	57 c0       	rjmp	.+174    	; 0x23f6 <main+0xc00>
    2348:	83 cc       	rjmp	.-1786   	; 0x1c50 <main+0x45a>
				{
					case '1':
					UART_TX_Str("\r\n");
    234a:	8e eb       	ldi	r24, 0xBE	; 190
    234c:	97 e0       	ldi	r25, 0x07	; 7
    234e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
					UART_TX_Str("Enter Username \r\n");
    2352:	8d e6       	ldi	r24, 0x6D	; 109
    2354:	97 e0       	ldi	r25, 0x07	; 7
    2356:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
					for(Uint8 i=0 ;i<4;i++)//for LOOP itriate 4 times to get four digits
    235a:	10 e0       	ldi	r17, 0x00	; 0
    235c:	10 c0       	rjmp	.+32     	; 0x237e <main+0xb88>
					{
						while (!Get_Bit(UCSRA,7)); // waiting for an input from user 
    235e:	5f 9b       	sbis	0x0b, 7	; 11
    2360:	fe cf       	rjmp	.-4      	; 0x235e <main+0xb68>
						User_Name[i]=UART_RX_Char();
    2362:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
						EEPROM_WriteByte(Page_User_Name_KeyPad,Counter_User_Name_Keypad,User_Name[i]); //save every element of the array to EEPROM
    2366:	48 2f       	mov	r20, r24
    2368:	60 91 19 08 	lds	r22, 0x0819	; 0x800819 <Counter_User_Name_Keypad>
    236c:	82 e0       	ldi	r24, 0x02	; 2
    236e:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
						Counter_User_Name_Keypad++; // Increment the counter
    2372:	80 91 19 08 	lds	r24, 0x0819	; 0x800819 <Counter_User_Name_Keypad>
    2376:	8f 5f       	subi	r24, 0xFF	; 255
    2378:	80 93 19 08 	sts	0x0819, r24	; 0x800819 <Counter_User_Name_Keypad>
				switch (Var_1)
				{
					case '1':
					UART_TX_Str("\r\n");
					UART_TX_Str("Enter Username \r\n");
					for(Uint8 i=0 ;i<4;i++)//for LOOP itriate 4 times to get four digits
    237c:	1f 5f       	subi	r17, 0xFF	; 255
    237e:	14 30       	cpi	r17, 0x04	; 4
    2380:	70 f3       	brcs	.-36     	; 0x235e <main+0xb68>
						while (!Get_Bit(UCSRA,7)); // waiting for an input from user 
						User_Name[i]=UART_RX_Char();
						EEPROM_WriteByte(Page_User_Name_KeyPad,Counter_User_Name_Keypad,User_Name[i]); //save every element of the array to EEPROM
						Counter_User_Name_Keypad++; // Increment the counter
					}
					EEPROM_WriteByte(5,0,Counter_User_Name_Keypad); // save the new value of the counter in EEPROM
    2382:	40 91 19 08 	lds	r20, 0x0819	; 0x800819 <Counter_User_Name_Keypad>
    2386:	60 e0       	ldi	r22, 0x00	; 0
    2388:	85 e0       	ldi	r24, 0x05	; 5
    238a:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
					UART_TX_Str("\r\n"); 
    238e:	8e eb       	ldi	r24, 0xBE	; 190
    2390:	97 e0       	ldi	r25, 0x07	; 7
    2392:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
					
					UART_TX_Str("Enter The Password :\r\n");
    2396:	8f e7       	ldi	r24, 0x7F	; 127
    2398:	97 e0       	ldi	r25, 0x07	; 7
    239a:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
					for(Uint8 i=0 ;i<4;i++) //for LOOP itriate 4 times to get four digits
    239e:	10 e0       	ldi	r17, 0x00	; 0
    23a0:	10 c0       	rjmp	.+32     	; 0x23c2 <main+0xbcc>
					{
						while (!Get_Bit(UCSRA,7)); // waiting for an input from user 
    23a2:	5f 9b       	sbis	0x0b, 7	; 11
    23a4:	fe cf       	rjmp	.-4      	; 0x23a2 <main+0xbac>
						Password[i]=UART_RX_Char();
    23a6:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
						EEPROM_WriteByte(Page_Password_KeyPad,Counter_Password_Keypad,Password[i]);//save every element of the array to EEPROM
    23aa:	48 2f       	mov	r20, r24
    23ac:	60 91 18 08 	lds	r22, 0x0818	; 0x800818 <Counter_Password_Keypad>
    23b0:	83 e0       	ldi	r24, 0x03	; 3
    23b2:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
						Counter_Password_Keypad++;// Increment the counter
    23b6:	80 91 18 08 	lds	r24, 0x0818	; 0x800818 <Counter_Password_Keypad>
    23ba:	8f 5f       	subi	r24, 0xFF	; 255
    23bc:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <Counter_Password_Keypad>
					}
					EEPROM_WriteByte(5,0,Counter_User_Name_Keypad); // save the new value of the counter in EEPROM
					UART_TX_Str("\r\n"); 
					
					UART_TX_Str("Enter The Password :\r\n");
					for(Uint8 i=0 ;i<4;i++) //for LOOP itriate 4 times to get four digits
    23c0:	1f 5f       	subi	r17, 0xFF	; 255
    23c2:	14 30       	cpi	r17, 0x04	; 4
    23c4:	70 f3       	brcs	.-36     	; 0x23a2 <main+0xbac>
						EEPROM_WriteByte(Page_Password_KeyPad,Counter_Password_Keypad,Password[i]);//save every element of the array to EEPROM
						Counter_Password_Keypad++;// Increment the counter
						
						
					}
					EEPROM_WriteByte(5,1,Counter_Password_Keypad);// save the new value of the counter in EEPROM
    23c6:	40 91 18 08 	lds	r20, 0x0818	; 0x800818 <Counter_Password_Keypad>
    23ca:	61 e0       	ldi	r22, 0x01	; 1
    23cc:	85 e0       	ldi	r24, 0x05	; 5
    23ce:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
					
					UART_TX_Str("\r\n");
    23d2:	8e eb       	ldi	r24, 0xBE	; 190
    23d4:	97 e0       	ldi	r25, 0x07	; 7
    23d6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
					UART_TX_Str("Successfully Added\r\n"); // display a message
    23da:	86 e9       	ldi	r24, 0x96	; 150
    23dc:	97 e0       	ldi	r25, 0x07	; 7
    23de:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    23e2:	2f ef       	ldi	r18, 0xFF	; 255
    23e4:	89 e6       	ldi	r24, 0x69	; 105
    23e6:	98 e1       	ldi	r25, 0x18	; 24
    23e8:	21 50       	subi	r18, 0x01	; 1
    23ea:	80 40       	sbci	r24, 0x00	; 0
    23ec:	90 40       	sbci	r25, 0x00	; 0
    23ee:	e1 f7       	brne	.-8      	; 0x23e8 <main+0xbf2>
    23f0:	00 c0       	rjmp	.+0      	; 0x23f2 <main+0xbfc>
    23f2:	00 00       	nop
    23f4:	2d cc       	rjmp	.-1958   	; 0x1c50 <main+0x45a>
					_delay_ms(500);
					break;
					case '2':
					UART_TX_Str("\r\n");
    23f6:	8e eb       	ldi	r24, 0xBE	; 190
    23f8:	97 e0       	ldi	r25, 0x07	; 7
    23fa:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
					UART_TX_Str("Enter Username \r\n");
    23fe:	8d e6       	ldi	r24, 0x6D	; 109
    2400:	97 e0       	ldi	r25, 0x07	; 7
    2402:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
					for(Uint8 i=0 ;i<4;i++)//for LOOP itriate 4 times to get four digits
    2406:	10 e0       	ldi	r17, 0x00	; 0
    2408:	10 c0       	rjmp	.+32     	; 0x242a <main+0xc34>
					{
						while (!Get_Bit(UCSRA,7));// waiting for an input from user 
    240a:	5f 9b       	sbis	0x0b, 7	; 11
    240c:	fe cf       	rjmp	.-4      	; 0x240a <main+0xc14>
						User_Name_PC[i]=UART_RX_Char();
    240e:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
						EEPROM_WriteByte(Page_User_Name,Counter_User_Name,User_Name_PC[i]);//save every element of the array to EEPROM
    2412:	48 2f       	mov	r20, r24
    2414:	60 91 1b 08 	lds	r22, 0x081B	; 0x80081b <Counter_User_Name>
    2418:	80 e0       	ldi	r24, 0x00	; 0
    241a:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
						Counter_User_Name++;// Increment the counter
    241e:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <Counter_User_Name>
    2422:	8f 5f       	subi	r24, 0xFF	; 255
    2424:	80 93 1b 08 	sts	0x081B, r24	; 0x80081b <Counter_User_Name>
					_delay_ms(500);
					break;
					case '2':
					UART_TX_Str("\r\n");
					UART_TX_Str("Enter Username \r\n");
					for(Uint8 i=0 ;i<4;i++)//for LOOP itriate 4 times to get four digits
    2428:	1f 5f       	subi	r17, 0xFF	; 255
    242a:	14 30       	cpi	r17, 0x04	; 4
    242c:	70 f3       	brcs	.-36     	; 0x240a <main+0xc14>
						User_Name_PC[i]=UART_RX_Char();
						EEPROM_WriteByte(Page_User_Name,Counter_User_Name,User_Name_PC[i]);//save every element of the array to EEPROM
						Counter_User_Name++;// Increment the counter
						
					}
					EEPROM_WriteByte(7,0,Counter_User_Name);// save the new value of the counter in EEPROM
    242e:	40 91 1b 08 	lds	r20, 0x081B	; 0x80081b <Counter_User_Name>
    2432:	60 e0       	ldi	r22, 0x00	; 0
    2434:	87 e0       	ldi	r24, 0x07	; 7
    2436:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
					UART_TX_Str("\r\n");
    243a:	8e eb       	ldi	r24, 0xBE	; 190
    243c:	97 e0       	ldi	r25, 0x07	; 7
    243e:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
					
					UART_TX_Str("Enter The Password \r\n");
    2442:	8b ea       	ldi	r24, 0xAB	; 171
    2444:	97 e0       	ldi	r25, 0x07	; 7
    2446:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
					for(Uint8 i=0 ;i<4;i++)
    244a:	10 e0       	ldi	r17, 0x00	; 0
    244c:	10 c0       	rjmp	.+32     	; 0x246e <main+0xc78>
					{
						while (!Get_Bit(UCSRA,7));// waiting for an input from user 
    244e:	5f 9b       	sbis	0x0b, 7	; 11
    2450:	fe cf       	rjmp	.-4      	; 0x244e <main+0xc58>
						Password_PC[i]=UART_RX_Char();
    2452:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
						EEPROM_WriteByte(Page_Password,Counter_Password,Password_PC[i]);//save every element of the array to EEPROM
    2456:	48 2f       	mov	r20, r24
    2458:	60 91 1a 08 	lds	r22, 0x081A	; 0x80081a <Counter_Password>
    245c:	81 e0       	ldi	r24, 0x01	; 1
    245e:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
						Counter_Password++;// Increment the counter
    2462:	80 91 1a 08 	lds	r24, 0x081A	; 0x80081a <Counter_Password>
    2466:	8f 5f       	subi	r24, 0xFF	; 255
    2468:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <Counter_Password>
					}
					EEPROM_WriteByte(7,0,Counter_User_Name);// save the new value of the counter in EEPROM
					UART_TX_Str("\r\n");
					
					UART_TX_Str("Enter The Password \r\n");
					for(Uint8 i=0 ;i<4;i++)
    246c:	1f 5f       	subi	r17, 0xFF	; 255
    246e:	14 30       	cpi	r17, 0x04	; 4
    2470:	70 f3       	brcs	.-36     	; 0x244e <main+0xc58>
						EEPROM_WriteByte(Page_Password,Counter_Password,Password_PC[i]);//save every element of the array to EEPROM
						Counter_Password++;// Increment the counter
						
						
					}
					EEPROM_WriteByte(7,1,Counter_Password);
    2472:	40 91 1a 08 	lds	r20, 0x081A	; 0x80081a <Counter_Password>
    2476:	61 e0       	ldi	r22, 0x01	; 1
    2478:	87 e0       	ldi	r24, 0x07	; 7
    247a:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
					UART_TX_Str("\r\n");
    247e:	8e eb       	ldi	r24, 0xBE	; 190
    2480:	97 e0       	ldi	r25, 0x07	; 7
    2482:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
					UART_TX_Str("Successfully Added\r\n");// save the new value of the counter in EEPROM
    2486:	86 e9       	ldi	r24, 0x96	; 150
    2488:	97 e0       	ldi	r25, 0x07	; 7
    248a:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
    248e:	2f ef       	ldi	r18, 0xFF	; 255
    2490:	89 e6       	ldi	r24, 0x69	; 105
    2492:	98 e1       	ldi	r25, 0x18	; 24
    2494:	21 50       	subi	r18, 0x01	; 1
    2496:	80 40       	sbci	r24, 0x00	; 0
    2498:	90 40       	sbci	r25, 0x00	; 0
    249a:	e1 f7       	brne	.-8      	; 0x2494 <main+0xc9e>
    249c:	00 c0       	rjmp	.+0      	; 0x249e <main+0xca8>
    249e:	00 00       	nop
    24a0:	d7 cb       	rjmp	.-2130   	; 0x1c50 <main+0x45a>
			
			/*------------------------------------------>DELETE USER<------------------------------------------*/
			
			case '4': //Delete User
			{
				UART_TX_Str("\r\n");
    24a2:	8e eb       	ldi	r24, 0xBE	; 190
    24a4:	97 e0       	ldi	r25, 0x07	; 7
    24a6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
				UART_TX_Str("1. Keypad\r\n");// Delete User that can login from keypad
    24aa:	89 e5       	ldi	r24, 0x59	; 89
    24ac:	97 e0       	ldi	r25, 0x07	; 7
    24ae:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
				UART_TX_Str("2. PC\r\n");// Delete User that can login from UART
    24b2:	85 e6       	ldi	r24, 0x65	; 101
    24b4:	97 e0       	ldi	r25, 0x07	; 7
    24b6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
				UART_RX_Char();
    24ba:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
				while (!Get_Bit(UCSRA,7));// Waiting for an input
    24be:	5f 9b       	sbis	0x0b, 7	; 11
    24c0:	fe cf       	rjmp	.-4      	; 0x24be <main+0xcc8>
				Uint8 Var_1=UDR;
    24c2:	8c b1       	in	r24, 0x0c	; 12
				Uint8 USER_NAME[4]={0}; // Array will hold the usename that will be deleted
    24c4:	19 86       	std	Y+9, r1	; 0x09
    24c6:	1a 86       	std	Y+10, r1	; 0x0a
    24c8:	1b 86       	std	Y+11, r1	; 0x0b
    24ca:	1c 86       	std	Y+12, r1	; 0x0c
				
				switch(Var_1)
    24cc:	81 33       	cpi	r24, 0x31	; 49
    24ce:	21 f0       	breq	.+8      	; 0x24d8 <main+0xce2>
    24d0:	82 33       	cpi	r24, 0x32	; 50
    24d2:	09 f4       	brne	.+2      	; 0x24d6 <main+0xce0>
    24d4:	7a c0       	rjmp	.+244    	; 0x25ca <main+0xdd4>
    24d6:	bc cb       	rjmp	.-2184   	; 0x1c50 <main+0x45a>
				{
					
					
					case '1':
					{
						UART_TX_Str("\r\n");
    24d8:	8e eb       	ldi	r24, 0xBE	; 190
    24da:	97 e0       	ldi	r25, 0x07	; 7
    24dc:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str("Enter Username :\r\n");
    24e0:	81 ec       	ldi	r24, 0xC1	; 193
    24e2:	97 e0       	ldi	r25, 0x07	; 7
    24e4:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						for(Uint8 i=0 ;i<4;i++)
    24e8:	10 e0       	ldi	r17, 0x00	; 0
    24ea:	0e c0       	rjmp	.+28     	; 0x2508 <main+0xd12>
						{
							while (!Get_Bit(UCSRA,7)); //Waiting for username
    24ec:	5f 9b       	sbis	0x0b, 7	; 11
    24ee:	fe cf       	rjmp	.-4      	; 0x24ec <main+0xcf6>
							USER_NAME[i]=UART_RX_Char();
    24f0:	e1 2e       	mov	r14, r17
    24f2:	f1 2c       	mov	r15, r1
    24f4:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
    24f8:	e9 e0       	ldi	r30, 0x09	; 9
    24fa:	f0 e0       	ldi	r31, 0x00	; 0
    24fc:	ec 0f       	add	r30, r28
    24fe:	fd 1f       	adc	r31, r29
    2500:	ee 0d       	add	r30, r14
    2502:	ff 1d       	adc	r31, r15
    2504:	80 83       	st	Z, r24
					
					case '1':
					{
						UART_TX_Str("\r\n");
						UART_TX_Str("Enter Username :\r\n");
						for(Uint8 i=0 ;i<4;i++)
    2506:	1f 5f       	subi	r17, 0xFF	; 255
    2508:	14 30       	cpi	r17, 0x04	; 4
    250a:	80 f3       	brcs	.-32     	; 0x24ec <main+0xcf6>
						}
						/* search for user name in the EEPROM
						* if it was found it reset the 4 bytes of the username 
						* if was not found it display user is not exists
						*/
						for (Uint8 z=0;z<Counter_User_Name_Keypad;z++)
    250c:	80 91 19 08 	lds	r24, 0x0819	; 0x800819 <Counter_User_Name_Keypad>
    2510:	88 23       	and	r24, r24
    2512:	09 f4       	brne	.+2      	; 0x2516 <main+0xd20>
    2514:	9d cb       	rjmp	.-2246   	; 0x1c50 <main+0x45a>
						{
							if((EEPROM_ReadByte(Page_User_Name_KeyPad,z))== USER_NAME[0]   && (EEPROM_ReadByte(Page_User_Name_KeyPad,z+1))== USER_NAME[1]  && (EEPROM_ReadByte(Page_User_Name_KeyPad,z+2))== USER_NAME[2]  && (EEPROM_ReadByte(Page_User_Name_KeyPad,z+3))== USER_NAME[3])// searching for username
    2516:	60 e0       	ldi	r22, 0x00	; 0
    2518:	82 e0       	ldi	r24, 0x02	; 2
    251a:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    251e:	99 85       	ldd	r25, Y+9	; 0x09
    2520:	89 13       	cpse	r24, r25
    2522:	4a c0       	rjmp	.+148    	; 0x25b8 <main+0xdc2>
    2524:	61 e0       	ldi	r22, 0x01	; 1
    2526:	82 e0       	ldi	r24, 0x02	; 2
    2528:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    252c:	9a 85       	ldd	r25, Y+10	; 0x0a
    252e:	89 13       	cpse	r24, r25
    2530:	43 c0       	rjmp	.+134    	; 0x25b8 <main+0xdc2>
    2532:	62 e0       	ldi	r22, 0x02	; 2
    2534:	82 e0       	ldi	r24, 0x02	; 2
    2536:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    253a:	9b 85       	ldd	r25, Y+11	; 0x0b
    253c:	89 13       	cpse	r24, r25
    253e:	3c c0       	rjmp	.+120    	; 0x25b8 <main+0xdc2>
    2540:	63 e0       	ldi	r22, 0x03	; 3
    2542:	82 e0       	ldi	r24, 0x02	; 2
    2544:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    2548:	9c 85       	ldd	r25, Y+12	; 0x0c
    254a:	89 13       	cpse	r24, r25
    254c:	35 c0       	rjmp	.+106    	; 0x25b8 <main+0xdc2>
							{
								/*since counter of user = counter password
								 * I can reset the bytes of username and password using only 1 counter 
								*/
								UART_TX_Str("\r\n");
    254e:	8e eb       	ldi	r24, 0xBE	; 190
    2550:	97 e0       	ldi	r25, 0x07	; 7
    2552:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								UART_TX_Str("Found\r\n"); // a message ensure that it found the username in EEPROM
    2556:	84 ed       	ldi	r24, 0xD4	; 212
    2558:	97 e0       	ldi	r25, 0x07	; 7
    255a:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								/* Reseting the bytes of username and password*/
								EEPROM_WriteByte(Page_User_Name_KeyPad,z,255); // reset the first byte of username
    255e:	4f ef       	ldi	r20, 0xFF	; 255
    2560:	60 e0       	ldi	r22, 0x00	; 0
    2562:	82 e0       	ldi	r24, 0x02	; 2
    2564:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_User_Name_KeyPad,z+1,255);// reset the next one byte
    2568:	4f ef       	ldi	r20, 0xFF	; 255
    256a:	61 e0       	ldi	r22, 0x01	; 1
    256c:	82 e0       	ldi	r24, 0x02	; 2
    256e:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_User_Name_KeyPad,z+2,255);// reset the next one byte
    2572:	4f ef       	ldi	r20, 0xFF	; 255
    2574:	62 e0       	ldi	r22, 0x02	; 2
    2576:	82 e0       	ldi	r24, 0x02	; 2
    2578:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_User_Name_KeyPad,z+3,255);// reset the next one byte
    257c:	4f ef       	ldi	r20, 0xFF	; 255
    257e:	63 e0       	ldi	r22, 0x03	; 3
    2580:	82 e0       	ldi	r24, 0x02	; 2
    2582:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_Password_KeyPad,z,255);  // reset the first byte of password
    2586:	4f ef       	ldi	r20, 0xFF	; 255
    2588:	60 e0       	ldi	r22, 0x00	; 0
    258a:	83 e0       	ldi	r24, 0x03	; 3
    258c:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_Password_KeyPad,z+1,255);// reset the next one byte
    2590:	4f ef       	ldi	r20, 0xFF	; 255
    2592:	61 e0       	ldi	r22, 0x01	; 1
    2594:	83 e0       	ldi	r24, 0x03	; 3
    2596:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_Password_KeyPad,z+2,255);// reset the next one byte
    259a:	4f ef       	ldi	r20, 0xFF	; 255
    259c:	62 e0       	ldi	r22, 0x02	; 2
    259e:	83 e0       	ldi	r24, 0x03	; 3
    25a0:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_Password_KeyPad,z+3,255);// reset the next one byte
    25a4:	4f ef       	ldi	r20, 0xFF	; 255
    25a6:	63 e0       	ldi	r22, 0x03	; 3
    25a8:	83 e0       	ldi	r24, 0x03	; 3
    25aa:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								UART_TX_Str("Deleted\r\n");// a message ensure that it delete the username from EEPROM
    25ae:	8c ed       	ldi	r24, 0xDC	; 220
    25b0:	97 e0       	ldi	r25, 0x07	; 7
    25b2:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								break;
    25b6:	4c cb       	rjmp	.-2408   	; 0x1c50 <main+0x45a>
							}
							else
							{
								UART_TX_Str("\r\n");
    25b8:	8e eb       	ldi	r24, 0xBE	; 190
    25ba:	97 e0       	ldi	r25, 0x07	; 7
    25bc:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								UART_TX_Str("User is not exist\r\n");// a message ensure that username is not exist in EEPROM
    25c0:	86 ee       	ldi	r24, 0xE6	; 230
    25c2:	97 e0       	ldi	r25, 0x07	; 7
    25c4:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								break;
    25c8:	43 cb       	rjmp	.-2426   	; 0x1c50 <main+0x45a>
						}
						break;
					}
					case'2':
					{
						UART_TX_Str("\r\n");
    25ca:	8e eb       	ldi	r24, 0xBE	; 190
    25cc:	97 e0       	ldi	r25, 0x07	; 7
    25ce:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						UART_TX_Str("Enter Username :\r\n");
    25d2:	81 ec       	ldi	r24, 0xC1	; 193
    25d4:	97 e0       	ldi	r25, 0x07	; 7
    25d6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
						for(Uint8 i=0 ;i<4;i++)
    25da:	10 e0       	ldi	r17, 0x00	; 0
    25dc:	0e c0       	rjmp	.+28     	; 0x25fa <main+0xe04>
						{
							while (!Get_Bit(UCSRA,7));// Waiting for an input
    25de:	5f 9b       	sbis	0x0b, 7	; 11
    25e0:	fe cf       	rjmp	.-4      	; 0x25de <main+0xde8>
							USER_NAME[i]=UART_RX_Char();
    25e2:	e1 2e       	mov	r14, r17
    25e4:	f1 2c       	mov	r15, r1
    25e6:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <UART_RX_Char>
    25ea:	e9 e0       	ldi	r30, 0x09	; 9
    25ec:	f0 e0       	ldi	r31, 0x00	; 0
    25ee:	ec 0f       	add	r30, r28
    25f0:	fd 1f       	adc	r31, r29
    25f2:	ee 0d       	add	r30, r14
    25f4:	ff 1d       	adc	r31, r15
    25f6:	80 83       	st	Z, r24
					}
					case'2':
					{
						UART_TX_Str("\r\n");
						UART_TX_Str("Enter Username :\r\n");
						for(Uint8 i=0 ;i<4;i++)
    25f8:	1f 5f       	subi	r17, 0xFF	; 255
    25fa:	14 30       	cpi	r17, 0x04	; 4
    25fc:	80 f3       	brcs	.-32     	; 0x25de <main+0xde8>
						}
						/* search for user name in the EEPROM
						* if it was found it reset the 4 bytes of the username 
						* if was not found it display user is not exists
						*/
						for (Uint8 z=0;z<Counter_User_Name;z++)
    25fe:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <Counter_User_Name>
    2602:	88 23       	and	r24, r24
    2604:	09 f4       	brne	.+2      	; 0x2608 <main+0xe12>
    2606:	24 cb       	rjmp	.-2488   	; 0x1c50 <main+0x45a>
						{
							if((EEPROM_ReadByte(Page_User_Name,z))== USER_NAME[0]   && (EEPROM_ReadByte(Page_User_Name,z+1))== USER_NAME[1]  && (EEPROM_ReadByte(Page_User_Name,z+2))== USER_NAME[2]  && (EEPROM_ReadByte(Page_User_Name,z+3))== USER_NAME[3])//Searching for Username
    2608:	60 e0       	ldi	r22, 0x00	; 0
    260a:	80 e0       	ldi	r24, 0x00	; 0
    260c:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    2610:	99 85       	ldd	r25, Y+9	; 0x09
    2612:	89 13       	cpse	r24, r25
    2614:	4a c0       	rjmp	.+148    	; 0x26aa <main+0xeb4>
    2616:	61 e0       	ldi	r22, 0x01	; 1
    2618:	80 e0       	ldi	r24, 0x00	; 0
    261a:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    261e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2620:	89 13       	cpse	r24, r25
    2622:	43 c0       	rjmp	.+134    	; 0x26aa <main+0xeb4>
    2624:	62 e0       	ldi	r22, 0x02	; 2
    2626:	80 e0       	ldi	r24, 0x00	; 0
    2628:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    262c:	9b 85       	ldd	r25, Y+11	; 0x0b
    262e:	89 13       	cpse	r24, r25
    2630:	3c c0       	rjmp	.+120    	; 0x26aa <main+0xeb4>
    2632:	63 e0       	ldi	r22, 0x03	; 3
    2634:	80 e0       	ldi	r24, 0x00	; 0
    2636:	0e 94 09 03 	call	0x612	; 0x612 <EEPROM_ReadByte>
    263a:	9c 85       	ldd	r25, Y+12	; 0x0c
    263c:	89 13       	cpse	r24, r25
    263e:	35 c0       	rjmp	.+106    	; 0x26aa <main+0xeb4>
							{
								/*since counter of user = counter password
								 * I can reset the bytes of username and password using only 1 counter 
								*/
								UART_TX_Str("\r\n");
    2640:	8e eb       	ldi	r24, 0xBE	; 190
    2642:	97 e0       	ldi	r25, 0x07	; 7
    2644:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								UART_TX_Str("Found\r\n");// a message ensure that it found the username in EEPROM
    2648:	84 ed       	ldi	r24, 0xD4	; 212
    264a:	97 e0       	ldi	r25, 0x07	; 7
    264c:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								/* Reseting the bytes of username and password*/
								EEPROM_WriteByte(Page_User_Name,z,255);// reset the first byte of username
    2650:	4f ef       	ldi	r20, 0xFF	; 255
    2652:	60 e0       	ldi	r22, 0x00	; 0
    2654:	80 e0       	ldi	r24, 0x00	; 0
    2656:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_User_Name,z+1,255);// reset the next one byte
    265a:	4f ef       	ldi	r20, 0xFF	; 255
    265c:	61 e0       	ldi	r22, 0x01	; 1
    265e:	80 e0       	ldi	r24, 0x00	; 0
    2660:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_User_Name,z+2,255);// reset the next one byte
    2664:	4f ef       	ldi	r20, 0xFF	; 255
    2666:	62 e0       	ldi	r22, 0x02	; 2
    2668:	80 e0       	ldi	r24, 0x00	; 0
    266a:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_User_Name,z+3,255);// reset the next one byte
    266e:	4f ef       	ldi	r20, 0xFF	; 255
    2670:	63 e0       	ldi	r22, 0x03	; 3
    2672:	80 e0       	ldi	r24, 0x00	; 0
    2674:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_Password,z,255);// reset the first byte of password
    2678:	4f ef       	ldi	r20, 0xFF	; 255
    267a:	60 e0       	ldi	r22, 0x00	; 0
    267c:	81 e0       	ldi	r24, 0x01	; 1
    267e:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_Password,z+1,255);// reset the next one byte
    2682:	4f ef       	ldi	r20, 0xFF	; 255
    2684:	61 e0       	ldi	r22, 0x01	; 1
    2686:	81 e0       	ldi	r24, 0x01	; 1
    2688:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_Password,z+2,255);// reset the next one byte
    268c:	4f ef       	ldi	r20, 0xFF	; 255
    268e:	62 e0       	ldi	r22, 0x02	; 2
    2690:	81 e0       	ldi	r24, 0x01	; 1
    2692:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								EEPROM_WriteByte(Page_Password,z+3,255);// reset the next one byte
    2696:	4f ef       	ldi	r20, 0xFF	; 255
    2698:	63 e0       	ldi	r22, 0x03	; 3
    269a:	81 e0       	ldi	r24, 0x01	; 1
    269c:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EEPROM_WriteByte>
								UART_TX_Str("Deleted\r\n");// a message ensure that it delete the username from EEPROM
    26a0:	8c ed       	ldi	r24, 0xDC	; 220
    26a2:	97 e0       	ldi	r25, 0x07	; 7
    26a4:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								/*---------------------------------------------------------*/
								break;
    26a8:	d3 ca       	rjmp	.-2650   	; 0x1c50 <main+0x45a>
							}
							else
							{
								UART_TX_Str("\r\n");
    26aa:	8e eb       	ldi	r24, 0xBE	; 190
    26ac:	97 e0       	ldi	r25, 0x07	; 7
    26ae:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								UART_TX_Str("User is not exist\r\n");// a message ensure that username is not exist in EEPROM
    26b2:	86 ee       	ldi	r24, 0xE6	; 230
    26b4:	97 e0       	ldi	r25, 0x07	; 7
    26b6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
								break;
    26ba:	ca ca       	rjmp	.-2668   	; 0x1c50 <main+0x45a>
				}
				break;
			}
			default:
			{
				UART_TX_Str("Wrong input\r\n");
    26bc:	8a ef       	ldi	r24, 0xFA	; 250
    26be:	97 e0       	ldi	r25, 0x07	; 7
    26c0:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
			}
			break;
    26c4:	c5 ca       	rjmp	.-2678   	; 0x1c50 <main+0x45a>

000026c6 <Servoo_Motor>:
 *  Author: User
 */ 
#include "servoo.h"

void Servoo_Motor(Uint32 duty_Cycle){
	TCNT1=0;
    26c6:	1d bc       	out	0x2d, r1	; 45
    26c8:	1c bc       	out	0x2c, r1	; 44
	ICR1=4999;  //fPWM=50Hz (Period = 20ms Standard).
    26ca:	27 e8       	ldi	r18, 0x87	; 135
    26cc:	33 e1       	ldi	r19, 0x13	; 19
    26ce:	37 bd       	out	0x27, r19	; 39
    26d0:	26 bd       	out	0x26, r18	; 38
	OCR1A=duty_Cycle; /* set the compare value*/
    26d2:	7b bd       	out	0x2b, r23	; 43
    26d4:	6a bd       	out	0x2a, r22	; 42
     * 1. Clear OC1A on compare match (non inverting mode) COM1A1=1 COM1A0=0
     * 2. Disconnect OC1B  COM1B0=0 COM1B1=0
     * 3. FOC1A=0 FOC1B=0 because these bits are only active in case non-pwm mode
     * 4. Fast Pwm Mode with the TOP in ICR1 WGM10=0 WGM11=1 (Mode Number 14)
	 */
	TCCR1A|=(1<<COM1A1)|(1<<COM1B1)|(1<<WGM11);        //NON Inverted PWM
    26d6:	8f b5       	in	r24, 0x2f	; 47
    26d8:	82 6a       	ori	r24, 0xA2	; 162
    26da:	8f bd       	out	0x2f, r24	; 47
	TCCR1B|=(1<<WGM13)|(1<<WGM12)|(1<<CS11)|(1<<CS10); //PRESCALER=64 MODE 14(FAST PWM)
    26dc:	8e b5       	in	r24, 0x2e	; 46
    26de:	8b 61       	ori	r24, 0x1B	; 27
    26e0:	8e bd       	out	0x2e, r24	; 46
    26e2:	08 95       	ret

000026e4 <Servo_INIT>:

	
}
void Servo_INIT(void)
{
	DDRD|=(1<<PD4)|(1<<PD5);// servo pin
    26e4:	81 b3       	in	r24, 0x11	; 17
    26e6:	80 63       	ori	r24, 0x30	; 48
    26e8:	81 bb       	out	0x11, r24	; 17
	Servoo_Motor(97);
    26ea:	61 e6       	ldi	r22, 0x61	; 97
    26ec:	70 e0       	ldi	r23, 0x00	; 0
    26ee:	80 e0       	ldi	r24, 0x00	; 0
    26f0:	90 e0       	ldi	r25, 0x00	; 0
    26f2:	0e 94 63 13 	call	0x26c6	; 0x26c6 <Servoo_Motor>
    26f6:	08 95       	ret

000026f8 <Servo_Open>:
}
void Servo_Open(void)
{
	Servoo_Motor(316);
    26f8:	6c e3       	ldi	r22, 0x3C	; 60
    26fa:	71 e0       	ldi	r23, 0x01	; 1
    26fc:	80 e0       	ldi	r24, 0x00	; 0
    26fe:	90 e0       	ldi	r25, 0x00	; 0
    2700:	0e 94 63 13 	call	0x26c6	; 0x26c6 <Servoo_Motor>
    2704:	08 95       	ret

00002706 <Servo_Close>:
}
void Servo_Close(void)
{
	Servoo_Motor(97);
    2706:	61 e6       	ldi	r22, 0x61	; 97
    2708:	70 e0       	ldi	r23, 0x00	; 0
    270a:	80 e0       	ldi	r24, 0x00	; 0
    270c:	90 e0       	ldi	r25, 0x00	; 0
    270e:	0e 94 63 13 	call	0x26c6	; 0x26c6 <Servoo_Motor>
    2712:	08 95       	ret

00002714 <Timer0_Init>:
{
	TCCR2 &= 0XF8;
}

void PWM2_Gen(f32 Duty_Cycle)
{
    2714:	8f b7       	in	r24, 0x3f	; 63
    2716:	80 68       	ori	r24, 0x80	; 128
    2718:	8f bf       	out	0x3f, r24	; 63
    271a:	83 b7       	in	r24, 0x33	; 51
    271c:	87 7f       	andi	r24, 0xF7	; 247
    271e:	83 bf       	out	0x33, r24	; 51
    2720:	83 b7       	in	r24, 0x33	; 51
    2722:	80 64       	ori	r24, 0x40	; 64
    2724:	83 bf       	out	0x33, r24	; 51
    2726:	83 b7       	in	r24, 0x33	; 51
    2728:	8f 7c       	andi	r24, 0xCF	; 207
    272a:	80 62       	ori	r24, 0x20	; 32
    272c:	83 bf       	out	0x33, r24	; 51
    272e:	89 b7       	in	r24, 0x39	; 57
    2730:	81 60       	ori	r24, 0x01	; 1
    2732:	89 bf       	out	0x39, r24	; 57
    2734:	41 e0       	ldi	r20, 0x01	; 1
    2736:	63 e0       	ldi	r22, 0x03	; 3
    2738:	81 e0       	ldi	r24, 0x01	; 1
    273a:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
    273e:	08 95       	ret

00002740 <PWM0_Gen>:
    2740:	cf 92       	push	r12
    2742:	df 92       	push	r13
    2744:	ef 92       	push	r14
    2746:	ff 92       	push	r15
    2748:	6b 01       	movw	r12, r22
    274a:	7c 01       	movw	r14, r24
    274c:	20 e0       	ldi	r18, 0x00	; 0
    274e:	30 e0       	ldi	r19, 0x00	; 0
    2750:	a9 01       	movw	r20, r18
    2752:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <__cmpsf2>
    2756:	88 23       	and	r24, r24
    2758:	5c f0       	brlt	.+22     	; 0x2770 <PWM0_Gen+0x30>
    275a:	20 e0       	ldi	r18, 0x00	; 0
    275c:	30 e0       	ldi	r19, 0x00	; 0
    275e:	48 ec       	ldi	r20, 0xC8	; 200
    2760:	52 e4       	ldi	r21, 0x42	; 66
    2762:	c7 01       	movw	r24, r14
    2764:	b6 01       	movw	r22, r12
    2766:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <__gesf2>
    276a:	18 16       	cp	r1, r24
    276c:	2c f0       	brlt	.+10     	; 0x2778 <PWM0_Gen+0x38>
    276e:	0c c0       	rjmp	.+24     	; 0x2788 <PWM0_Gen+0x48>
    2770:	c1 2c       	mov	r12, r1
    2772:	d1 2c       	mov	r13, r1
    2774:	76 01       	movw	r14, r12
    2776:	08 c0       	rjmp	.+16     	; 0x2788 <PWM0_Gen+0x48>
    2778:	0f 2e       	mov	r0, r31
    277a:	c1 2c       	mov	r12, r1
    277c:	d1 2c       	mov	r13, r1
    277e:	f8 ec       	ldi	r31, 0xC8	; 200
    2780:	ef 2e       	mov	r14, r31
    2782:	f2 e4       	ldi	r31, 0x42	; 66
    2784:	ff 2e       	mov	r15, r31
    2786:	f0 2d       	mov	r31, r0
    2788:	20 e0       	ldi	r18, 0x00	; 0
    278a:	30 e0       	ldi	r19, 0x00	; 0
    278c:	4f e7       	ldi	r20, 0x7F	; 127
    278e:	53 e4       	ldi	r21, 0x43	; 67
    2790:	c7 01       	movw	r24, r14
    2792:	b6 01       	movw	r22, r12
    2794:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <__mulsf3>
    2798:	20 e0       	ldi	r18, 0x00	; 0
    279a:	30 e0       	ldi	r19, 0x00	; 0
    279c:	48 ec       	ldi	r20, 0xC8	; 200
    279e:	52 e4       	ldi	r21, 0x42	; 66
    27a0:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <__divsf3>
    27a4:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <__fixunssfsi>
    27a8:	6c bf       	out	0x3c, r22	; 60
    27aa:	ff 90       	pop	r15
    27ac:	ef 90       	pop	r14
    27ae:	df 90       	pop	r13
    27b0:	cf 90       	pop	r12
    27b2:	08 95       	ret

000027b4 <Timer0_Start>:
    27b4:	83 b7       	in	r24, 0x33	; 51
    27b6:	88 7f       	andi	r24, 0xF8	; 248
    27b8:	85 60       	ori	r24, 0x05	; 5
    27ba:	83 bf       	out	0x33, r24	; 51
    27bc:	08 95       	ret

000027be <Timer0_Stop>:
    27be:	83 b7       	in	r24, 0x33	; 51
    27c0:	88 7f       	andi	r24, 0xF8	; 248
    27c2:	83 bf       	out	0x33, r24	; 51
    27c4:	08 95       	ret

000027c6 <__vector_11>:
    27c6:	1f 92       	push	r1
    27c8:	0f 92       	push	r0
    27ca:	0f b6       	in	r0, 0x3f	; 63
    27cc:	0f 92       	push	r0
    27ce:	11 24       	eor	r1, r1
    27d0:	2f 93       	push	r18
    27d2:	3f 93       	push	r19
    27d4:	4f 93       	push	r20
    27d6:	5f 93       	push	r21
    27d8:	6f 93       	push	r22
    27da:	7f 93       	push	r23
    27dc:	8f 93       	push	r24
    27de:	9f 93       	push	r25
    27e0:	af 93       	push	r26
    27e2:	bf 93       	push	r27
    27e4:	ef 93       	push	r30
    27e6:	ff 93       	push	r31
    27e8:	80 91 28 08 	lds	r24, 0x0828	; 0x800828 <Count.1708>
    27ec:	90 91 29 08 	lds	r25, 0x0829	; 0x800829 <Count.1708+0x1>
    27f0:	a0 91 2a 08 	lds	r26, 0x082A	; 0x80082a <Count.1708+0x2>
    27f4:	b0 91 2b 08 	lds	r27, 0x082B	; 0x80082b <Count.1708+0x3>
    27f8:	01 96       	adiw	r24, 0x01	; 1
    27fa:	a1 1d       	adc	r26, r1
    27fc:	b1 1d       	adc	r27, r1
    27fe:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <Count.1708>
    2802:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <Count.1708+0x1>
    2806:	a0 93 2a 08 	sts	0x082A, r26	; 0x80082a <Count.1708+0x2>
    280a:	b0 93 2b 08 	sts	0x082B, r27	; 0x80082b <Count.1708+0x3>
    280e:	40 91 30 08 	lds	r20, 0x0830	; 0x800830 <Timer0_Num_OVF>
    2812:	50 91 31 08 	lds	r21, 0x0831	; 0x800831 <Timer0_Num_OVF+0x1>
    2816:	60 e0       	ldi	r22, 0x00	; 0
    2818:	70 e0       	ldi	r23, 0x00	; 0
    281a:	84 17       	cp	r24, r20
    281c:	95 07       	cpc	r25, r21
    281e:	a6 07       	cpc	r26, r22
    2820:	b7 07       	cpc	r27, r23
    2822:	69 f4       	brne	.+26     	; 0x283e <__vector_11+0x78>
    2824:	0e 94 df 13 	call	0x27be	; 0x27be <Timer0_Stop>
    2828:	10 92 28 08 	sts	0x0828, r1	; 0x800828 <Count.1708>
    282c:	10 92 29 08 	sts	0x0829, r1	; 0x800829 <Count.1708+0x1>
    2830:	10 92 2a 08 	sts	0x082A, r1	; 0x80082a <Count.1708+0x2>
    2834:	10 92 2b 08 	sts	0x082B, r1	; 0x80082b <Count.1708+0x3>
    2838:	80 91 2f 08 	lds	r24, 0x082F	; 0x80082f <Timer0_Init_Value>
    283c:	82 bf       	out	0x32, r24	; 50
    283e:	ff 91       	pop	r31
    2840:	ef 91       	pop	r30
    2842:	bf 91       	pop	r27
    2844:	af 91       	pop	r26
    2846:	9f 91       	pop	r25
    2848:	8f 91       	pop	r24
    284a:	7f 91       	pop	r23
    284c:	6f 91       	pop	r22
    284e:	5f 91       	pop	r21
    2850:	4f 91       	pop	r20
    2852:	3f 91       	pop	r19
    2854:	2f 91       	pop	r18
    2856:	0f 90       	pop	r0
    2858:	0f be       	out	0x3f, r0	; 63
    285a:	0f 90       	pop	r0
    285c:	1f 90       	pop	r1
    285e:	18 95       	reti

00002860 <__vector_10>:
    2860:	1f 92       	push	r1
    2862:	0f 92       	push	r0
    2864:	0f b6       	in	r0, 0x3f	; 63
    2866:	0f 92       	push	r0
    2868:	11 24       	eor	r1, r1
    286a:	4f 93       	push	r20
    286c:	5f 93       	push	r21
    286e:	6f 93       	push	r22
    2870:	7f 93       	push	r23
    2872:	8f 93       	push	r24
    2874:	9f 93       	push	r25
    2876:	af 93       	push	r26
    2878:	bf 93       	push	r27
    287a:	80 91 24 08 	lds	r24, 0x0824	; 0x800824 <Count.1714>
    287e:	90 91 25 08 	lds	r25, 0x0825	; 0x800825 <Count.1714+0x1>
    2882:	a0 91 26 08 	lds	r26, 0x0826	; 0x800826 <Count.1714+0x2>
    2886:	b0 91 27 08 	lds	r27, 0x0827	; 0x800827 <Count.1714+0x3>
    288a:	01 96       	adiw	r24, 0x01	; 1
    288c:	a1 1d       	adc	r26, r1
    288e:	b1 1d       	adc	r27, r1
    2890:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <Count.1714>
    2894:	90 93 25 08 	sts	0x0825, r25	; 0x800825 <Count.1714+0x1>
    2898:	a0 93 26 08 	sts	0x0826, r26	; 0x800826 <Count.1714+0x2>
    289c:	b0 93 27 08 	sts	0x0827, r27	; 0x800827 <Count.1714+0x3>
    28a0:	81 30       	cpi	r24, 0x01	; 1
    28a2:	91 05       	cpc	r25, r1
    28a4:	a1 05       	cpc	r26, r1
    28a6:	b1 05       	cpc	r27, r1
    28a8:	b9 f4       	brne	.+46     	; 0x28d8 <__vector_10+0x78>
    28aa:	40 91 30 08 	lds	r20, 0x0830	; 0x800830 <Timer0_Num_OVF>
    28ae:	50 91 31 08 	lds	r21, 0x0831	; 0x800831 <Timer0_Num_OVF+0x1>
    28b2:	60 e0       	ldi	r22, 0x00	; 0
    28b4:	70 e0       	ldi	r23, 0x00	; 0
    28b6:	84 17       	cp	r24, r20
    28b8:	95 07       	cpc	r25, r21
    28ba:	a6 07       	cpc	r26, r22
    28bc:	b7 07       	cpc	r27, r23
    28be:	61 f4       	brne	.+24     	; 0x28d8 <__vector_10+0x78>
    28c0:	10 92 24 08 	sts	0x0824, r1	; 0x800824 <Count.1714>
    28c4:	10 92 25 08 	sts	0x0825, r1	; 0x800825 <Count.1714+0x1>
    28c8:	10 92 26 08 	sts	0x0826, r1	; 0x800826 <Count.1714+0x2>
    28cc:	10 92 27 08 	sts	0x0827, r1	; 0x800827 <Count.1714+0x3>
    28d0:	80 91 2f 08 	lds	r24, 0x082F	; 0x80082f <Timer0_Init_Value>
    28d4:	8c bf       	out	0x3c, r24	; 60
    28d6:	1e c0       	rjmp	.+60     	; 0x2914 <__vector_10+0xb4>
    28d8:	81 30       	cpi	r24, 0x01	; 1
    28da:	91 05       	cpc	r25, r1
    28dc:	a1 05       	cpc	r26, r1
    28de:	b1 05       	cpc	r27, r1
    28e0:	19 f4       	brne	.+6      	; 0x28e8 <__vector_10+0x88>
    28e2:	8f ef       	ldi	r24, 0xFF	; 255
    28e4:	8c bf       	out	0x3c, r24	; 60
    28e6:	16 c0       	rjmp	.+44     	; 0x2914 <__vector_10+0xb4>
    28e8:	40 91 30 08 	lds	r20, 0x0830	; 0x800830 <Timer0_Num_OVF>
    28ec:	50 91 31 08 	lds	r21, 0x0831	; 0x800831 <Timer0_Num_OVF+0x1>
    28f0:	60 e0       	ldi	r22, 0x00	; 0
    28f2:	70 e0       	ldi	r23, 0x00	; 0
    28f4:	84 17       	cp	r24, r20
    28f6:	95 07       	cpc	r25, r21
    28f8:	a6 07       	cpc	r26, r22
    28fa:	b7 07       	cpc	r27, r23
    28fc:	59 f4       	brne	.+22     	; 0x2914 <__vector_10+0xb4>
    28fe:	10 92 24 08 	sts	0x0824, r1	; 0x800824 <Count.1714>
    2902:	10 92 25 08 	sts	0x0825, r1	; 0x800825 <Count.1714+0x1>
    2906:	10 92 26 08 	sts	0x0826, r1	; 0x800826 <Count.1714+0x2>
    290a:	10 92 27 08 	sts	0x0827, r1	; 0x800827 <Count.1714+0x3>
    290e:	80 91 2f 08 	lds	r24, 0x082F	; 0x80082f <Timer0_Init_Value>
    2912:	8c bf       	out	0x3c, r24	; 60
    2914:	bf 91       	pop	r27
    2916:	af 91       	pop	r26
    2918:	9f 91       	pop	r25
    291a:	8f 91       	pop	r24
    291c:	7f 91       	pop	r23
    291e:	6f 91       	pop	r22
    2920:	5f 91       	pop	r21
    2922:	4f 91       	pop	r20
    2924:	0f 90       	pop	r0
    2926:	0f be       	out	0x3f, r0	; 63
    2928:	0f 90       	pop	r0
    292a:	1f 90       	pop	r1
    292c:	18 95       	reti

0000292e <Timer2_Init>:
    292e:	8f b7       	in	r24, 0x3f	; 63
    2930:	80 68       	ori	r24, 0x80	; 128
    2932:	8f bf       	out	0x3f, r24	; 63
    2934:	85 b5       	in	r24, 0x25	; 37
    2936:	88 60       	ori	r24, 0x08	; 8
    2938:	85 bd       	out	0x25, r24	; 37
    293a:	85 b5       	in	r24, 0x25	; 37
    293c:	8f 7b       	andi	r24, 0xBF	; 191
    293e:	85 bd       	out	0x25, r24	; 37
    2940:	89 b7       	in	r24, 0x39	; 57
    2942:	80 68       	ori	r24, 0x80	; 128
    2944:	89 bf       	out	0x39, r24	; 57
    2946:	08 95       	ret

00002948 <Timer2_SetDelay>:
    2948:	0f 93       	push	r16
    294a:	1f 93       	push	r17
    294c:	9b 01       	movw	r18, r22
    294e:	ac 01       	movw	r20, r24
    2950:	a8 ee       	ldi	r26, 0xE8	; 232
    2952:	b3 e0       	ldi	r27, 0x03	; 3
    2954:	0e 94 07 18 	call	0x300e	; 0x300e <__muluhisi3>
    2958:	8b 01       	movw	r16, r22
    295a:	9c 01       	movw	r18, r24
    295c:	68 94       	set
    295e:	15 f8       	bld	r1, 5
    2960:	36 95       	lsr	r19
    2962:	27 95       	ror	r18
    2964:	17 95       	ror	r17
    2966:	07 95       	ror	r16
    2968:	16 94       	lsr	r1
    296a:	d1 f7       	brne	.-12     	; 0x2960 <Timer2_SetDelay+0x18>
    296c:	01 30       	cpi	r16, 0x01	; 1
    296e:	41 e0       	ldi	r20, 0x01	; 1
    2970:	14 07       	cpc	r17, r20
    2972:	21 05       	cpc	r18, r1
    2974:	31 05       	cpc	r19, r1
    2976:	60 f4       	brcc	.+24     	; 0x2990 <Timer2_SetDelay+0x48>
    2978:	8f ef       	ldi	r24, 0xFF	; 255
    297a:	80 0f       	add	r24, r16
    297c:	80 93 2c 08 	sts	0x082C, r24	; 0x80082c <Timer2_Init_Value>
    2980:	83 bd       	out	0x23, r24	; 35
    2982:	81 e0       	ldi	r24, 0x01	; 1
    2984:	90 e0       	ldi	r25, 0x00	; 0
    2986:	90 93 2e 08 	sts	0x082E, r25	; 0x80082e <Timer2_Num_OVF+0x1>
    298a:	80 93 2d 08 	sts	0x082D, r24	; 0x80082d <Timer2_Num_OVF>
    298e:	24 c0       	rjmp	.+72     	; 0x29d8 <Timer2_SetDelay+0x90>
    2990:	01 11       	cpse	r16, r1
    2992:	0c c0       	rjmp	.+24     	; 0x29ac <Timer2_SetDelay+0x64>
    2994:	ab 01       	movw	r20, r22
    2996:	bc 01       	movw	r22, r24
    2998:	03 2e       	mov	r0, r19
    299a:	3e e0       	ldi	r19, 0x0E	; 14
    299c:	76 95       	lsr	r23
    299e:	67 95       	ror	r22
    29a0:	57 95       	ror	r21
    29a2:	47 95       	ror	r20
    29a4:	3a 95       	dec	r19
    29a6:	d1 f7       	brne	.-12     	; 0x299c <Timer2_SetDelay+0x54>
    29a8:	30 2d       	mov	r19, r0
    29aa:	0d c0       	rjmp	.+26     	; 0x29c6 <Timer2_SetDelay+0x7e>
    29ac:	ab 01       	movw	r20, r22
    29ae:	bc 01       	movw	r22, r24
    29b0:	03 2e       	mov	r0, r19
    29b2:	3e e0       	ldi	r19, 0x0E	; 14
    29b4:	76 95       	lsr	r23
    29b6:	67 95       	ror	r22
    29b8:	57 95       	ror	r21
    29ba:	47 95       	ror	r20
    29bc:	3a 95       	dec	r19
    29be:	d1 f7       	brne	.-12     	; 0x29b4 <Timer2_SetDelay+0x6c>
    29c0:	30 2d       	mov	r19, r0
    29c2:	4f 5f       	subi	r20, 0xFF	; 255
    29c4:	5f 4f       	sbci	r21, 0xFF	; 255
    29c6:	50 93 2e 08 	sts	0x082E, r21	; 0x80082e <Timer2_Num_OVF+0x1>
    29ca:	40 93 2d 08 	sts	0x082D, r20	; 0x80082d <Timer2_Num_OVF>
    29ce:	8f ef       	ldi	r24, 0xFF	; 255
    29d0:	80 0f       	add	r24, r16
    29d2:	80 93 2c 08 	sts	0x082C, r24	; 0x80082c <Timer2_Init_Value>
    29d6:	83 bd       	out	0x23, r24	; 35
    29d8:	1f 91       	pop	r17
    29da:	0f 91       	pop	r16
    29dc:	08 95       	ret

000029de <Timer2_Start>:
    29de:	85 b5       	in	r24, 0x25	; 37
    29e0:	87 60       	ori	r24, 0x07	; 7
    29e2:	85 bd       	out	0x25, r24	; 37
    29e4:	08 95       	ret

000029e6 <__vector_5>:
		#endif
	#endif
}

ISR(TIMER2_OVF_vect)
{
    29e6:	1f 92       	push	r1
    29e8:	0f 92       	push	r0
    29ea:	0f b6       	in	r0, 0x3f	; 63
    29ec:	0f 92       	push	r0
    29ee:	11 24       	eor	r1, r1
    29f0:	4f 93       	push	r20
    29f2:	5f 93       	push	r21
    29f4:	6f 93       	push	r22
    29f6:	7f 93       	push	r23
    29f8:	8f 93       	push	r24
    29fa:	9f 93       	push	r25
    29fc:	af 93       	push	r26
    29fe:	bf 93       	push	r27
	static Uint32 Count = 0;
	Count++;
    2a00:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <Count.1758>
    2a04:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <Count.1758+0x1>
    2a08:	a0 91 22 08 	lds	r26, 0x0822	; 0x800822 <Count.1758+0x2>
    2a0c:	b0 91 23 08 	lds	r27, 0x0823	; 0x800823 <Count.1758+0x3>
    2a10:	01 96       	adiw	r24, 0x01	; 1
    2a12:	a1 1d       	adc	r26, r1
    2a14:	b1 1d       	adc	r27, r1
    2a16:	80 93 20 08 	sts	0x0820, r24	; 0x800820 <Count.1758>
    2a1a:	90 93 21 08 	sts	0x0821, r25	; 0x800821 <Count.1758+0x1>
    2a1e:	a0 93 22 08 	sts	0x0822, r26	; 0x800822 <Count.1758+0x2>
    2a22:	b0 93 23 08 	sts	0x0823, r27	; 0x800823 <Count.1758+0x3>
	if(Timer2_Num_OVF == Count)
    2a26:	40 91 2d 08 	lds	r20, 0x082D	; 0x80082d <Timer2_Num_OVF>
    2a2a:	50 91 2e 08 	lds	r21, 0x082E	; 0x80082e <Timer2_Num_OVF+0x1>
    2a2e:	60 e0       	ldi	r22, 0x00	; 0
    2a30:	70 e0       	ldi	r23, 0x00	; 0
    2a32:	84 17       	cp	r24, r20
    2a34:	95 07       	cpc	r25, r21
    2a36:	a6 07       	cpc	r26, r22
    2a38:	b7 07       	cpc	r27, r23
    2a3a:	59 f4       	brne	.+22     	; 0x2a52 <__vector_5+0x6c>
	{
		// Write OVF of Timer_2 handler here
		
		
		Count = 0;
    2a3c:	10 92 20 08 	sts	0x0820, r1	; 0x800820 <Count.1758>
    2a40:	10 92 21 08 	sts	0x0821, r1	; 0x800821 <Count.1758+0x1>
    2a44:	10 92 22 08 	sts	0x0822, r1	; 0x800822 <Count.1758+0x2>
    2a48:	10 92 23 08 	sts	0x0823, r1	; 0x800823 <Count.1758+0x3>
		TCNT2 = Timer2_Init_Value;
    2a4c:	80 91 2c 08 	lds	r24, 0x082C	; 0x80082c <Timer2_Init_Value>
    2a50:	84 bd       	out	0x24, r24	; 36
	}
	
}
    2a52:	bf 91       	pop	r27
    2a54:	af 91       	pop	r26
    2a56:	9f 91       	pop	r25
    2a58:	8f 91       	pop	r24
    2a5a:	7f 91       	pop	r23
    2a5c:	6f 91       	pop	r22
    2a5e:	5f 91       	pop	r21
    2a60:	4f 91       	pop	r20
    2a62:	0f 90       	pop	r0
    2a64:	0f be       	out	0x3f, r0	; 63
    2a66:	0f 90       	pop	r0
    2a68:	1f 90       	pop	r1
    2a6a:	18 95       	reti

00002a6c <__vector_4>:

ISR(TIMER2_COMP_vect)
{
    2a6c:	1f 92       	push	r1
    2a6e:	0f 92       	push	r0
    2a70:	0f b6       	in	r0, 0x3f	; 63
    2a72:	0f 92       	push	r0
    2a74:	11 24       	eor	r1, r1
    2a76:	4f 93       	push	r20
    2a78:	5f 93       	push	r21
    2a7a:	6f 93       	push	r22
    2a7c:	7f 93       	push	r23
    2a7e:	8f 93       	push	r24
    2a80:	9f 93       	push	r25
    2a82:	af 93       	push	r26
    2a84:	bf 93       	push	r27
	static Uint32 Count = 0;
	Count++;
    2a86:	80 91 1c 08 	lds	r24, 0x081C	; 0x80081c <Count.1764>
    2a8a:	90 91 1d 08 	lds	r25, 0x081D	; 0x80081d <Count.1764+0x1>
    2a8e:	a0 91 1e 08 	lds	r26, 0x081E	; 0x80081e <Count.1764+0x2>
    2a92:	b0 91 1f 08 	lds	r27, 0x081F	; 0x80081f <Count.1764+0x3>
    2a96:	01 96       	adiw	r24, 0x01	; 1
    2a98:	a1 1d       	adc	r26, r1
    2a9a:	b1 1d       	adc	r27, r1
    2a9c:	80 93 1c 08 	sts	0x081C, r24	; 0x80081c <Count.1764>
    2aa0:	90 93 1d 08 	sts	0x081D, r25	; 0x80081d <Count.1764+0x1>
    2aa4:	a0 93 1e 08 	sts	0x081E, r26	; 0x80081e <Count.1764+0x2>
    2aa8:	b0 93 1f 08 	sts	0x081F, r27	; 0x80081f <Count.1764+0x3>
	if(Count == 1 && Timer2_Num_OVF == Count)
    2aac:	81 30       	cpi	r24, 0x01	; 1
    2aae:	91 05       	cpc	r25, r1
    2ab0:	a1 05       	cpc	r26, r1
    2ab2:	b1 05       	cpc	r27, r1
    2ab4:	b9 f4       	brne	.+46     	; 0x2ae4 <__vector_4+0x78>
    2ab6:	40 91 2d 08 	lds	r20, 0x082D	; 0x80082d <Timer2_Num_OVF>
    2aba:	50 91 2e 08 	lds	r21, 0x082E	; 0x80082e <Timer2_Num_OVF+0x1>
    2abe:	60 e0       	ldi	r22, 0x00	; 0
    2ac0:	70 e0       	ldi	r23, 0x00	; 0
    2ac2:	84 17       	cp	r24, r20
    2ac4:	95 07       	cpc	r25, r21
    2ac6:	a6 07       	cpc	r26, r22
    2ac8:	b7 07       	cpc	r27, r23
    2aca:	61 f4       	brne	.+24     	; 0x2ae4 <__vector_4+0x78>
	{
		// Write CMP of Timer_2 handler here
		
				
		Count = 0;
    2acc:	10 92 1c 08 	sts	0x081C, r1	; 0x80081c <Count.1764>
    2ad0:	10 92 1d 08 	sts	0x081D, r1	; 0x80081d <Count.1764+0x1>
    2ad4:	10 92 1e 08 	sts	0x081E, r1	; 0x80081e <Count.1764+0x2>
    2ad8:	10 92 1f 08 	sts	0x081F, r1	; 0x80081f <Count.1764+0x3>
		OCR2 = Timer2_Init_Value;
    2adc:	80 91 2c 08 	lds	r24, 0x082C	; 0x80082c <Timer2_Init_Value>
    2ae0:	83 bd       	out	0x23, r24	; 35
    2ae2:	1e c0       	rjmp	.+60     	; 0x2b20 <__vector_4+0xb4>
	}
	else if(Count == 1)
    2ae4:	81 30       	cpi	r24, 0x01	; 1
    2ae6:	91 05       	cpc	r25, r1
    2ae8:	a1 05       	cpc	r26, r1
    2aea:	b1 05       	cpc	r27, r1
    2aec:	19 f4       	brne	.+6      	; 0x2af4 <__vector_4+0x88>
	OCR2 = 255;
    2aee:	8f ef       	ldi	r24, 0xFF	; 255
    2af0:	83 bd       	out	0x23, r24	; 35
    2af2:	16 c0       	rjmp	.+44     	; 0x2b20 <__vector_4+0xb4>
	else if(Timer2_Num_OVF == Count)
    2af4:	40 91 2d 08 	lds	r20, 0x082D	; 0x80082d <Timer2_Num_OVF>
    2af8:	50 91 2e 08 	lds	r21, 0x082E	; 0x80082e <Timer2_Num_OVF+0x1>
    2afc:	60 e0       	ldi	r22, 0x00	; 0
    2afe:	70 e0       	ldi	r23, 0x00	; 0
    2b00:	84 17       	cp	r24, r20
    2b02:	95 07       	cpc	r25, r21
    2b04:	a6 07       	cpc	r26, r22
    2b06:	b7 07       	cpc	r27, r23
    2b08:	59 f4       	brne	.+22     	; 0x2b20 <__vector_4+0xb4>
	{
		// Write CMP of Timer_2 handler here
		
		
		Count = 0;
    2b0a:	10 92 1c 08 	sts	0x081C, r1	; 0x80081c <Count.1764>
    2b0e:	10 92 1d 08 	sts	0x081D, r1	; 0x80081d <Count.1764+0x1>
    2b12:	10 92 1e 08 	sts	0x081E, r1	; 0x80081e <Count.1764+0x2>
    2b16:	10 92 1f 08 	sts	0x081F, r1	; 0x80081f <Count.1764+0x3>
		OCR2 = Timer2_Init_Value;
    2b1a:	80 91 2c 08 	lds	r24, 0x082C	; 0x80082c <Timer2_Init_Value>
    2b1e:	83 bd       	out	0x23, r24	; 35
	}
}
    2b20:	bf 91       	pop	r27
    2b22:	af 91       	pop	r26
    2b24:	9f 91       	pop	r25
    2b26:	8f 91       	pop	r24
    2b28:	7f 91       	pop	r23
    2b2a:	6f 91       	pop	r22
    2b2c:	5f 91       	pop	r21
    2b2e:	4f 91       	pop	r20
    2b30:	0f 90       	pop	r0
    2b32:	0f be       	out	0x3f, r0	; 63
    2b34:	0f 90       	pop	r0
    2b36:	1f 90       	pop	r1
    2b38:	18 95       	reti

00002b3a <UART_Init>:
#include <avr/interrupt.h>
Uint8 Var=0;
void UART_Init(void)
{
	// Global Interrupt
	SREG |= Global_INT << 7;
    2b3a:	8f b7       	in	r24, 0x3f	; 63
    2b3c:	80 68       	ori	r24, 0x80	; 128
    2b3e:	8f bf       	out	0x3f, r24	; 63
	
	// Peripheral Interrupt
	UCSRB = (UART_TX_INT << 6) | (UART_RX_INT << 7) | (UCSRB & 0X3F);
    2b40:	8a b1       	in	r24, 0x0a	; 10
    2b42:	80 6c       	ori	r24, 0xC0	; 192
    2b44:	8a b9       	out	0x0a, r24	; 10
	
	// TX Pin Direction
	DIO_SetPin_Dir(DIO_PORTD, PIN_1, PIN_OUT);
    2b46:	41 e0       	ldi	r20, 0x01	; 1
    2b48:	61 e0       	ldi	r22, 0x01	; 1
    2b4a:	83 e0       	ldi	r24, 0x03	; 3
    2b4c:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
	
	// RX Pin Direction
	DIO_SetPin_Dir(DIO_PORTD, PIN_0, PIN_IN);
    2b50:	40 e0       	ldi	r20, 0x00	; 0
    2b52:	60 e0       	ldi	r22, 0x00	; 0
    2b54:	83 e0       	ldi	r24, 0x03	; 3
    2b56:	0e 94 6d 01 	call	0x2da	; 0x2da <DIO_SetPin_Dir>
	
	// UART Receiver/ Transmitter Enable
	UCSRB = (1 << 3) | (1 << 4) | (UCSRB & 0X3F);
    2b5a:	8a b1       	in	r24, 0x0a	; 10
    2b5c:	87 72       	andi	r24, 0x27	; 39
    2b5e:	88 61       	ori	r24, 0x18	; 24
    2b60:	8a b9       	out	0x0a, r24	; 10
	
	// UART Doubled Speed Mode
	UCSRA = (UART_Doubled_Speed << 1) | (UCSRA & 0XFD);
    2b62:	8b b1       	in	r24, 0x0b	; 11
    2b64:	82 60       	ori	r24, 0x02	; 2
    2b66:	8b b9       	out	0x0b, r24	; 11
	
	// Parity Bit Mode
	// Data Bits Mode
	// Stop Bit  Mode
	UCSRC = (1 << 7) | (UART_Data_Bits << 1) | (UART_Stop_Bits << 3) | (UART_Parity_Mode << 4) | (UCSRC & 0X41);
    2b68:	80 b5       	in	r24, 0x20	; 32
    2b6a:	81 74       	andi	r24, 0x41	; 65
    2b6c:	86 6a       	ori	r24, 0xA6	; 166
    2b6e:	80 bd       	out	0x20, r24	; 32
	
	// UART Baud Rate
	UBRRL = (Uint8)UART_Baud_Rate;
    2b70:	8f ec       	ldi	r24, 0xCF	; 207
    2b72:	89 b9       	out	0x09, r24	; 9
	UBRRH = (UART_Baud_Rate >> 8);
    2b74:	10 bc       	out	0x20, r1	; 32
    2b76:	08 95       	ret

00002b78 <UART_TX_Char>:
}

void UART_TX_Char(Uint8 data)
{
	// Sending Data
	UDR = data;
    2b78:	8c b9       	out	0x0c, r24	; 12
	
	// Checking the data is sent
	while(!Get_Bit(UCSRA, 5));
    2b7a:	5d 9b       	sbis	0x0b, 5	; 11
    2b7c:	fe cf       	rjmp	.-4      	; 0x2b7a <UART_TX_Char+0x2>
}
    2b7e:	08 95       	ret

00002b80 <UART_TX_Str>:

void UART_TX_Str(Uint8 *str)
{
    2b80:	0f 93       	push	r16
    2b82:	1f 93       	push	r17
    2b84:	cf 93       	push	r28
    2b86:	8c 01       	movw	r16, r24
	for(Uint8 i = 0; str[i] != '\n'; i++)
    2b88:	c0 e0       	ldi	r28, 0x00	; 0
    2b8a:	03 c0       	rjmp	.+6      	; 0x2b92 <UART_TX_Str+0x12>
	{
		UART_TX_Char(str[i]);
    2b8c:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <UART_TX_Char>
	while(!Get_Bit(UCSRA, 5));
}

void UART_TX_Str(Uint8 *str)
{
	for(Uint8 i = 0; str[i] != '\n'; i++)
    2b90:	cf 5f       	subi	r28, 0xFF	; 255
    2b92:	f8 01       	movw	r30, r16
    2b94:	ec 0f       	add	r30, r28
    2b96:	f1 1d       	adc	r31, r1
    2b98:	80 81       	ld	r24, Z
    2b9a:	8a 30       	cpi	r24, 0x0A	; 10
    2b9c:	b9 f7       	brne	.-18     	; 0x2b8c <UART_TX_Str+0xc>
	{
		UART_TX_Char(str[i]);
	}
}
    2b9e:	cf 91       	pop	r28
    2ba0:	1f 91       	pop	r17
    2ba2:	0f 91       	pop	r16
    2ba4:	08 95       	ret

00002ba6 <UART_RX_Char>:

Uint8 UART_RX_Char(void)
{
	Uint8 Value = 0;
	while(!Get_Bit(UCSRA, 5));
    2ba6:	5d 9b       	sbis	0x0b, 5	; 11
    2ba8:	fe cf       	rjmp	.-4      	; 0x2ba6 <UART_RX_Char>
	Value = UDR;
    2baa:	8c b1       	in	r24, 0x0c	; 12
	return Value;
}
    2bac:	08 95       	ret

00002bae <__vector_13>:
}
*/


ISR(USART_RXC_vect)
{		
    2bae:	1f 92       	push	r1
    2bb0:	0f 92       	push	r0
    2bb2:	0f b6       	in	r0, 0x3f	; 63
    2bb4:	0f 92       	push	r0
    2bb6:	11 24       	eor	r1, r1
    2bb8:	2f 93       	push	r18
    2bba:	3f 93       	push	r19
    2bbc:	4f 93       	push	r20
    2bbe:	5f 93       	push	r21
    2bc0:	6f 93       	push	r22
    2bc2:	7f 93       	push	r23
    2bc4:	8f 93       	push	r24
    2bc6:	9f 93       	push	r25
    2bc8:	af 93       	push	r26
    2bca:	bf 93       	push	r27
    2bcc:	ef 93       	push	r30
    2bce:	ff 93       	push	r31
	UART_TX_Str("test1");
    2bd0:	88 e0       	ldi	r24, 0x08	; 8
    2bd2:	98 e0       	ldi	r25, 0x08	; 8
    2bd4:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <UART_TX_Str>
}
    2bd8:	ff 91       	pop	r31
    2bda:	ef 91       	pop	r30
    2bdc:	bf 91       	pop	r27
    2bde:	af 91       	pop	r26
    2be0:	9f 91       	pop	r25
    2be2:	8f 91       	pop	r24
    2be4:	7f 91       	pop	r23
    2be6:	6f 91       	pop	r22
    2be8:	5f 91       	pop	r21
    2bea:	4f 91       	pop	r20
    2bec:	3f 91       	pop	r19
    2bee:	2f 91       	pop	r18
    2bf0:	0f 90       	pop	r0
    2bf2:	0f be       	out	0x3f, r0	; 63
    2bf4:	0f 90       	pop	r0
    2bf6:	1f 90       	pop	r1
    2bf8:	18 95       	reti

00002bfa <__vector_15>:

ISR(USART_TXC_vect)
{
    2bfa:	1f 92       	push	r1
    2bfc:	0f 92       	push	r0
    2bfe:	0f b6       	in	r0, 0x3f	; 63
    2c00:	0f 92       	push	r0
    2c02:	11 24       	eor	r1, r1
	// Write UART transmit handler here
	
    2c04:	0f 90       	pop	r0
    2c06:	0f be       	out	0x3f, r0	; 63
    2c08:	0f 90       	pop	r0
    2c0a:	1f 90       	pop	r1
    2c0c:	18 95       	reti

00002c0e <__cmpsf2>:
    2c0e:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <__fp_cmp>
    2c12:	08 f4       	brcc	.+2      	; 0x2c16 <__cmpsf2+0x8>
    2c14:	81 e0       	ldi	r24, 0x01	; 1
    2c16:	08 95       	ret

00002c18 <__divsf3>:
    2c18:	0e 94 20 16 	call	0x2c40	; 0x2c40 <__divsf3x>
    2c1c:	0c 94 25 17 	jmp	0x2e4a	; 0x2e4a <__fp_round>
    2c20:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <__fp_pscB>
    2c24:	58 f0       	brcs	.+22     	; 0x2c3c <__divsf3+0x24>
    2c26:	0e 94 17 17 	call	0x2e2e	; 0x2e2e <__fp_pscA>
    2c2a:	40 f0       	brcs	.+16     	; 0x2c3c <__divsf3+0x24>
    2c2c:	29 f4       	brne	.+10     	; 0x2c38 <__divsf3+0x20>
    2c2e:	5f 3f       	cpi	r21, 0xFF	; 255
    2c30:	29 f0       	breq	.+10     	; 0x2c3c <__divsf3+0x24>
    2c32:	0c 94 0e 17 	jmp	0x2e1c	; 0x2e1c <__fp_inf>
    2c36:	51 11       	cpse	r21, r1
    2c38:	0c 94 59 17 	jmp	0x2eb2	; 0x2eb2 <__fp_szero>
    2c3c:	0c 94 14 17 	jmp	0x2e28	; 0x2e28 <__fp_nan>

00002c40 <__divsf3x>:
    2c40:	0e 94 36 17 	call	0x2e6c	; 0x2e6c <__fp_split3>
    2c44:	68 f3       	brcs	.-38     	; 0x2c20 <__divsf3+0x8>

00002c46 <__divsf3_pse>:
    2c46:	99 23       	and	r25, r25
    2c48:	b1 f3       	breq	.-20     	; 0x2c36 <__divsf3+0x1e>
    2c4a:	55 23       	and	r21, r21
    2c4c:	91 f3       	breq	.-28     	; 0x2c32 <__divsf3+0x1a>
    2c4e:	95 1b       	sub	r25, r21
    2c50:	55 0b       	sbc	r21, r21
    2c52:	bb 27       	eor	r27, r27
    2c54:	aa 27       	eor	r26, r26
    2c56:	62 17       	cp	r22, r18
    2c58:	73 07       	cpc	r23, r19
    2c5a:	84 07       	cpc	r24, r20
    2c5c:	38 f0       	brcs	.+14     	; 0x2c6c <__divsf3_pse+0x26>
    2c5e:	9f 5f       	subi	r25, 0xFF	; 255
    2c60:	5f 4f       	sbci	r21, 0xFF	; 255
    2c62:	22 0f       	add	r18, r18
    2c64:	33 1f       	adc	r19, r19
    2c66:	44 1f       	adc	r20, r20
    2c68:	aa 1f       	adc	r26, r26
    2c6a:	a9 f3       	breq	.-22     	; 0x2c56 <__divsf3_pse+0x10>
    2c6c:	35 d0       	rcall	.+106    	; 0x2cd8 <__divsf3_pse+0x92>
    2c6e:	0e 2e       	mov	r0, r30
    2c70:	3a f0       	brmi	.+14     	; 0x2c80 <__divsf3_pse+0x3a>
    2c72:	e0 e8       	ldi	r30, 0x80	; 128
    2c74:	32 d0       	rcall	.+100    	; 0x2cda <__divsf3_pse+0x94>
    2c76:	91 50       	subi	r25, 0x01	; 1
    2c78:	50 40       	sbci	r21, 0x00	; 0
    2c7a:	e6 95       	lsr	r30
    2c7c:	00 1c       	adc	r0, r0
    2c7e:	ca f7       	brpl	.-14     	; 0x2c72 <__divsf3_pse+0x2c>
    2c80:	2b d0       	rcall	.+86     	; 0x2cd8 <__divsf3_pse+0x92>
    2c82:	fe 2f       	mov	r31, r30
    2c84:	29 d0       	rcall	.+82     	; 0x2cd8 <__divsf3_pse+0x92>
    2c86:	66 0f       	add	r22, r22
    2c88:	77 1f       	adc	r23, r23
    2c8a:	88 1f       	adc	r24, r24
    2c8c:	bb 1f       	adc	r27, r27
    2c8e:	26 17       	cp	r18, r22
    2c90:	37 07       	cpc	r19, r23
    2c92:	48 07       	cpc	r20, r24
    2c94:	ab 07       	cpc	r26, r27
    2c96:	b0 e8       	ldi	r27, 0x80	; 128
    2c98:	09 f0       	breq	.+2      	; 0x2c9c <__divsf3_pse+0x56>
    2c9a:	bb 0b       	sbc	r27, r27
    2c9c:	80 2d       	mov	r24, r0
    2c9e:	bf 01       	movw	r22, r30
    2ca0:	ff 27       	eor	r31, r31
    2ca2:	93 58       	subi	r25, 0x83	; 131
    2ca4:	5f 4f       	sbci	r21, 0xFF	; 255
    2ca6:	3a f0       	brmi	.+14     	; 0x2cb6 <__divsf3_pse+0x70>
    2ca8:	9e 3f       	cpi	r25, 0xFE	; 254
    2caa:	51 05       	cpc	r21, r1
    2cac:	78 f0       	brcs	.+30     	; 0x2ccc <__divsf3_pse+0x86>
    2cae:	0c 94 0e 17 	jmp	0x2e1c	; 0x2e1c <__fp_inf>
    2cb2:	0c 94 59 17 	jmp	0x2eb2	; 0x2eb2 <__fp_szero>
    2cb6:	5f 3f       	cpi	r21, 0xFF	; 255
    2cb8:	e4 f3       	brlt	.-8      	; 0x2cb2 <__divsf3_pse+0x6c>
    2cba:	98 3e       	cpi	r25, 0xE8	; 232
    2cbc:	d4 f3       	brlt	.-12     	; 0x2cb2 <__divsf3_pse+0x6c>
    2cbe:	86 95       	lsr	r24
    2cc0:	77 95       	ror	r23
    2cc2:	67 95       	ror	r22
    2cc4:	b7 95       	ror	r27
    2cc6:	f7 95       	ror	r31
    2cc8:	9f 5f       	subi	r25, 0xFF	; 255
    2cca:	c9 f7       	brne	.-14     	; 0x2cbe <__divsf3_pse+0x78>
    2ccc:	88 0f       	add	r24, r24
    2cce:	91 1d       	adc	r25, r1
    2cd0:	96 95       	lsr	r25
    2cd2:	87 95       	ror	r24
    2cd4:	97 f9       	bld	r25, 7
    2cd6:	08 95       	ret
    2cd8:	e1 e0       	ldi	r30, 0x01	; 1
    2cda:	66 0f       	add	r22, r22
    2cdc:	77 1f       	adc	r23, r23
    2cde:	88 1f       	adc	r24, r24
    2ce0:	bb 1f       	adc	r27, r27
    2ce2:	62 17       	cp	r22, r18
    2ce4:	73 07       	cpc	r23, r19
    2ce6:	84 07       	cpc	r24, r20
    2ce8:	ba 07       	cpc	r27, r26
    2cea:	20 f0       	brcs	.+8      	; 0x2cf4 <__divsf3_pse+0xae>
    2cec:	62 1b       	sub	r22, r18
    2cee:	73 0b       	sbc	r23, r19
    2cf0:	84 0b       	sbc	r24, r20
    2cf2:	ba 0b       	sbc	r27, r26
    2cf4:	ee 1f       	adc	r30, r30
    2cf6:	88 f7       	brcc	.-30     	; 0x2cda <__divsf3_pse+0x94>
    2cf8:	e0 95       	com	r30
    2cfa:	08 95       	ret

00002cfc <__fixunssfsi>:
    2cfc:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <__fp_splitA>
    2d00:	88 f0       	brcs	.+34     	; 0x2d24 <__fixunssfsi+0x28>
    2d02:	9f 57       	subi	r25, 0x7F	; 127
    2d04:	98 f0       	brcs	.+38     	; 0x2d2c <__fixunssfsi+0x30>
    2d06:	b9 2f       	mov	r27, r25
    2d08:	99 27       	eor	r25, r25
    2d0a:	b7 51       	subi	r27, 0x17	; 23
    2d0c:	b0 f0       	brcs	.+44     	; 0x2d3a <__fixunssfsi+0x3e>
    2d0e:	e1 f0       	breq	.+56     	; 0x2d48 <__fixunssfsi+0x4c>
    2d10:	66 0f       	add	r22, r22
    2d12:	77 1f       	adc	r23, r23
    2d14:	88 1f       	adc	r24, r24
    2d16:	99 1f       	adc	r25, r25
    2d18:	1a f0       	brmi	.+6      	; 0x2d20 <__fixunssfsi+0x24>
    2d1a:	ba 95       	dec	r27
    2d1c:	c9 f7       	brne	.-14     	; 0x2d10 <__fixunssfsi+0x14>
    2d1e:	14 c0       	rjmp	.+40     	; 0x2d48 <__fixunssfsi+0x4c>
    2d20:	b1 30       	cpi	r27, 0x01	; 1
    2d22:	91 f0       	breq	.+36     	; 0x2d48 <__fixunssfsi+0x4c>
    2d24:	0e 94 58 17 	call	0x2eb0	; 0x2eb0 <__fp_zero>
    2d28:	b1 e0       	ldi	r27, 0x01	; 1
    2d2a:	08 95       	ret
    2d2c:	0c 94 58 17 	jmp	0x2eb0	; 0x2eb0 <__fp_zero>
    2d30:	67 2f       	mov	r22, r23
    2d32:	78 2f       	mov	r23, r24
    2d34:	88 27       	eor	r24, r24
    2d36:	b8 5f       	subi	r27, 0xF8	; 248
    2d38:	39 f0       	breq	.+14     	; 0x2d48 <__fixunssfsi+0x4c>
    2d3a:	b9 3f       	cpi	r27, 0xF9	; 249
    2d3c:	cc f3       	brlt	.-14     	; 0x2d30 <__fixunssfsi+0x34>
    2d3e:	86 95       	lsr	r24
    2d40:	77 95       	ror	r23
    2d42:	67 95       	ror	r22
    2d44:	b3 95       	inc	r27
    2d46:	d9 f7       	brne	.-10     	; 0x2d3e <__fixunssfsi+0x42>
    2d48:	3e f4       	brtc	.+14     	; 0x2d58 <__fixunssfsi+0x5c>
    2d4a:	90 95       	com	r25
    2d4c:	80 95       	com	r24
    2d4e:	70 95       	com	r23
    2d50:	61 95       	neg	r22
    2d52:	7f 4f       	sbci	r23, 0xFF	; 255
    2d54:	8f 4f       	sbci	r24, 0xFF	; 255
    2d56:	9f 4f       	sbci	r25, 0xFF	; 255
    2d58:	08 95       	ret

00002d5a <__floatunsisf>:
    2d5a:	e8 94       	clt
    2d5c:	09 c0       	rjmp	.+18     	; 0x2d70 <__floatsisf+0x12>

00002d5e <__floatsisf>:
    2d5e:	97 fb       	bst	r25, 7
    2d60:	3e f4       	brtc	.+14     	; 0x2d70 <__floatsisf+0x12>
    2d62:	90 95       	com	r25
    2d64:	80 95       	com	r24
    2d66:	70 95       	com	r23
    2d68:	61 95       	neg	r22
    2d6a:	7f 4f       	sbci	r23, 0xFF	; 255
    2d6c:	8f 4f       	sbci	r24, 0xFF	; 255
    2d6e:	9f 4f       	sbci	r25, 0xFF	; 255
    2d70:	99 23       	and	r25, r25
    2d72:	a9 f0       	breq	.+42     	; 0x2d9e <__floatsisf+0x40>
    2d74:	f9 2f       	mov	r31, r25
    2d76:	96 e9       	ldi	r25, 0x96	; 150
    2d78:	bb 27       	eor	r27, r27
    2d7a:	93 95       	inc	r25
    2d7c:	f6 95       	lsr	r31
    2d7e:	87 95       	ror	r24
    2d80:	77 95       	ror	r23
    2d82:	67 95       	ror	r22
    2d84:	b7 95       	ror	r27
    2d86:	f1 11       	cpse	r31, r1
    2d88:	f8 cf       	rjmp	.-16     	; 0x2d7a <__floatsisf+0x1c>
    2d8a:	fa f4       	brpl	.+62     	; 0x2dca <__floatsisf+0x6c>
    2d8c:	bb 0f       	add	r27, r27
    2d8e:	11 f4       	brne	.+4      	; 0x2d94 <__floatsisf+0x36>
    2d90:	60 ff       	sbrs	r22, 0
    2d92:	1b c0       	rjmp	.+54     	; 0x2dca <__floatsisf+0x6c>
    2d94:	6f 5f       	subi	r22, 0xFF	; 255
    2d96:	7f 4f       	sbci	r23, 0xFF	; 255
    2d98:	8f 4f       	sbci	r24, 0xFF	; 255
    2d9a:	9f 4f       	sbci	r25, 0xFF	; 255
    2d9c:	16 c0       	rjmp	.+44     	; 0x2dca <__floatsisf+0x6c>
    2d9e:	88 23       	and	r24, r24
    2da0:	11 f0       	breq	.+4      	; 0x2da6 <__floatsisf+0x48>
    2da2:	96 e9       	ldi	r25, 0x96	; 150
    2da4:	11 c0       	rjmp	.+34     	; 0x2dc8 <__floatsisf+0x6a>
    2da6:	77 23       	and	r23, r23
    2da8:	21 f0       	breq	.+8      	; 0x2db2 <__floatsisf+0x54>
    2daa:	9e e8       	ldi	r25, 0x8E	; 142
    2dac:	87 2f       	mov	r24, r23
    2dae:	76 2f       	mov	r23, r22
    2db0:	05 c0       	rjmp	.+10     	; 0x2dbc <__floatsisf+0x5e>
    2db2:	66 23       	and	r22, r22
    2db4:	71 f0       	breq	.+28     	; 0x2dd2 <__floatsisf+0x74>
    2db6:	96 e8       	ldi	r25, 0x86	; 134
    2db8:	86 2f       	mov	r24, r22
    2dba:	70 e0       	ldi	r23, 0x00	; 0
    2dbc:	60 e0       	ldi	r22, 0x00	; 0
    2dbe:	2a f0       	brmi	.+10     	; 0x2dca <__floatsisf+0x6c>
    2dc0:	9a 95       	dec	r25
    2dc2:	66 0f       	add	r22, r22
    2dc4:	77 1f       	adc	r23, r23
    2dc6:	88 1f       	adc	r24, r24
    2dc8:	da f7       	brpl	.-10     	; 0x2dc0 <__floatsisf+0x62>
    2dca:	88 0f       	add	r24, r24
    2dcc:	96 95       	lsr	r25
    2dce:	87 95       	ror	r24
    2dd0:	97 f9       	bld	r25, 7
    2dd2:	08 95       	ret

00002dd4 <__fp_cmp>:
    2dd4:	99 0f       	add	r25, r25
    2dd6:	00 08       	sbc	r0, r0
    2dd8:	55 0f       	add	r21, r21
    2dda:	aa 0b       	sbc	r26, r26
    2ddc:	e0 e8       	ldi	r30, 0x80	; 128
    2dde:	fe ef       	ldi	r31, 0xFE	; 254
    2de0:	16 16       	cp	r1, r22
    2de2:	17 06       	cpc	r1, r23
    2de4:	e8 07       	cpc	r30, r24
    2de6:	f9 07       	cpc	r31, r25
    2de8:	c0 f0       	brcs	.+48     	; 0x2e1a <__fp_cmp+0x46>
    2dea:	12 16       	cp	r1, r18
    2dec:	13 06       	cpc	r1, r19
    2dee:	e4 07       	cpc	r30, r20
    2df0:	f5 07       	cpc	r31, r21
    2df2:	98 f0       	brcs	.+38     	; 0x2e1a <__fp_cmp+0x46>
    2df4:	62 1b       	sub	r22, r18
    2df6:	73 0b       	sbc	r23, r19
    2df8:	84 0b       	sbc	r24, r20
    2dfa:	95 0b       	sbc	r25, r21
    2dfc:	39 f4       	brne	.+14     	; 0x2e0c <__fp_cmp+0x38>
    2dfe:	0a 26       	eor	r0, r26
    2e00:	61 f0       	breq	.+24     	; 0x2e1a <__fp_cmp+0x46>
    2e02:	23 2b       	or	r18, r19
    2e04:	24 2b       	or	r18, r20
    2e06:	25 2b       	or	r18, r21
    2e08:	21 f4       	brne	.+8      	; 0x2e12 <__fp_cmp+0x3e>
    2e0a:	08 95       	ret
    2e0c:	0a 26       	eor	r0, r26
    2e0e:	09 f4       	brne	.+2      	; 0x2e12 <__fp_cmp+0x3e>
    2e10:	a1 40       	sbci	r26, 0x01	; 1
    2e12:	a6 95       	lsr	r26
    2e14:	8f ef       	ldi	r24, 0xFF	; 255
    2e16:	81 1d       	adc	r24, r1
    2e18:	81 1d       	adc	r24, r1
    2e1a:	08 95       	ret

00002e1c <__fp_inf>:
    2e1c:	97 f9       	bld	r25, 7
    2e1e:	9f 67       	ori	r25, 0x7F	; 127
    2e20:	80 e8       	ldi	r24, 0x80	; 128
    2e22:	70 e0       	ldi	r23, 0x00	; 0
    2e24:	60 e0       	ldi	r22, 0x00	; 0
    2e26:	08 95       	ret

00002e28 <__fp_nan>:
    2e28:	9f ef       	ldi	r25, 0xFF	; 255
    2e2a:	80 ec       	ldi	r24, 0xC0	; 192
    2e2c:	08 95       	ret

00002e2e <__fp_pscA>:
    2e2e:	00 24       	eor	r0, r0
    2e30:	0a 94       	dec	r0
    2e32:	16 16       	cp	r1, r22
    2e34:	17 06       	cpc	r1, r23
    2e36:	18 06       	cpc	r1, r24
    2e38:	09 06       	cpc	r0, r25
    2e3a:	08 95       	ret

00002e3c <__fp_pscB>:
    2e3c:	00 24       	eor	r0, r0
    2e3e:	0a 94       	dec	r0
    2e40:	12 16       	cp	r1, r18
    2e42:	13 06       	cpc	r1, r19
    2e44:	14 06       	cpc	r1, r20
    2e46:	05 06       	cpc	r0, r21
    2e48:	08 95       	ret

00002e4a <__fp_round>:
    2e4a:	09 2e       	mov	r0, r25
    2e4c:	03 94       	inc	r0
    2e4e:	00 0c       	add	r0, r0
    2e50:	11 f4       	brne	.+4      	; 0x2e56 <__fp_round+0xc>
    2e52:	88 23       	and	r24, r24
    2e54:	52 f0       	brmi	.+20     	; 0x2e6a <__fp_round+0x20>
    2e56:	bb 0f       	add	r27, r27
    2e58:	40 f4       	brcc	.+16     	; 0x2e6a <__fp_round+0x20>
    2e5a:	bf 2b       	or	r27, r31
    2e5c:	11 f4       	brne	.+4      	; 0x2e62 <__fp_round+0x18>
    2e5e:	60 ff       	sbrs	r22, 0
    2e60:	04 c0       	rjmp	.+8      	; 0x2e6a <__fp_round+0x20>
    2e62:	6f 5f       	subi	r22, 0xFF	; 255
    2e64:	7f 4f       	sbci	r23, 0xFF	; 255
    2e66:	8f 4f       	sbci	r24, 0xFF	; 255
    2e68:	9f 4f       	sbci	r25, 0xFF	; 255
    2e6a:	08 95       	ret

00002e6c <__fp_split3>:
    2e6c:	57 fd       	sbrc	r21, 7
    2e6e:	90 58       	subi	r25, 0x80	; 128
    2e70:	44 0f       	add	r20, r20
    2e72:	55 1f       	adc	r21, r21
    2e74:	59 f0       	breq	.+22     	; 0x2e8c <__fp_splitA+0x10>
    2e76:	5f 3f       	cpi	r21, 0xFF	; 255
    2e78:	71 f0       	breq	.+28     	; 0x2e96 <__fp_splitA+0x1a>
    2e7a:	47 95       	ror	r20

00002e7c <__fp_splitA>:
    2e7c:	88 0f       	add	r24, r24
    2e7e:	97 fb       	bst	r25, 7
    2e80:	99 1f       	adc	r25, r25
    2e82:	61 f0       	breq	.+24     	; 0x2e9c <__fp_splitA+0x20>
    2e84:	9f 3f       	cpi	r25, 0xFF	; 255
    2e86:	79 f0       	breq	.+30     	; 0x2ea6 <__fp_splitA+0x2a>
    2e88:	87 95       	ror	r24
    2e8a:	08 95       	ret
    2e8c:	12 16       	cp	r1, r18
    2e8e:	13 06       	cpc	r1, r19
    2e90:	14 06       	cpc	r1, r20
    2e92:	55 1f       	adc	r21, r21
    2e94:	f2 cf       	rjmp	.-28     	; 0x2e7a <__fp_split3+0xe>
    2e96:	46 95       	lsr	r20
    2e98:	f1 df       	rcall	.-30     	; 0x2e7c <__fp_splitA>
    2e9a:	08 c0       	rjmp	.+16     	; 0x2eac <__fp_splitA+0x30>
    2e9c:	16 16       	cp	r1, r22
    2e9e:	17 06       	cpc	r1, r23
    2ea0:	18 06       	cpc	r1, r24
    2ea2:	99 1f       	adc	r25, r25
    2ea4:	f1 cf       	rjmp	.-30     	; 0x2e88 <__fp_splitA+0xc>
    2ea6:	86 95       	lsr	r24
    2ea8:	71 05       	cpc	r23, r1
    2eaa:	61 05       	cpc	r22, r1
    2eac:	08 94       	sec
    2eae:	08 95       	ret

00002eb0 <__fp_zero>:
    2eb0:	e8 94       	clt

00002eb2 <__fp_szero>:
    2eb2:	bb 27       	eor	r27, r27
    2eb4:	66 27       	eor	r22, r22
    2eb6:	77 27       	eor	r23, r23
    2eb8:	cb 01       	movw	r24, r22
    2eba:	97 f9       	bld	r25, 7
    2ebc:	08 95       	ret

00002ebe <__gesf2>:
    2ebe:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <__fp_cmp>
    2ec2:	08 f4       	brcc	.+2      	; 0x2ec6 <__gesf2+0x8>
    2ec4:	8f ef       	ldi	r24, 0xFF	; 255
    2ec6:	08 95       	ret

00002ec8 <__mulsf3>:
    2ec8:	0e 94 77 17 	call	0x2eee	; 0x2eee <__mulsf3x>
    2ecc:	0c 94 25 17 	jmp	0x2e4a	; 0x2e4a <__fp_round>
    2ed0:	0e 94 17 17 	call	0x2e2e	; 0x2e2e <__fp_pscA>
    2ed4:	38 f0       	brcs	.+14     	; 0x2ee4 <__mulsf3+0x1c>
    2ed6:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <__fp_pscB>
    2eda:	20 f0       	brcs	.+8      	; 0x2ee4 <__mulsf3+0x1c>
    2edc:	95 23       	and	r25, r21
    2ede:	11 f0       	breq	.+4      	; 0x2ee4 <__mulsf3+0x1c>
    2ee0:	0c 94 0e 17 	jmp	0x2e1c	; 0x2e1c <__fp_inf>
    2ee4:	0c 94 14 17 	jmp	0x2e28	; 0x2e28 <__fp_nan>
    2ee8:	11 24       	eor	r1, r1
    2eea:	0c 94 59 17 	jmp	0x2eb2	; 0x2eb2 <__fp_szero>

00002eee <__mulsf3x>:
    2eee:	0e 94 36 17 	call	0x2e6c	; 0x2e6c <__fp_split3>
    2ef2:	70 f3       	brcs	.-36     	; 0x2ed0 <__mulsf3+0x8>

00002ef4 <__mulsf3_pse>:
    2ef4:	95 9f       	mul	r25, r21
    2ef6:	c1 f3       	breq	.-16     	; 0x2ee8 <__mulsf3+0x20>
    2ef8:	95 0f       	add	r25, r21
    2efa:	50 e0       	ldi	r21, 0x00	; 0
    2efc:	55 1f       	adc	r21, r21
    2efe:	62 9f       	mul	r22, r18
    2f00:	f0 01       	movw	r30, r0
    2f02:	72 9f       	mul	r23, r18
    2f04:	bb 27       	eor	r27, r27
    2f06:	f0 0d       	add	r31, r0
    2f08:	b1 1d       	adc	r27, r1
    2f0a:	63 9f       	mul	r22, r19
    2f0c:	aa 27       	eor	r26, r26
    2f0e:	f0 0d       	add	r31, r0
    2f10:	b1 1d       	adc	r27, r1
    2f12:	aa 1f       	adc	r26, r26
    2f14:	64 9f       	mul	r22, r20
    2f16:	66 27       	eor	r22, r22
    2f18:	b0 0d       	add	r27, r0
    2f1a:	a1 1d       	adc	r26, r1
    2f1c:	66 1f       	adc	r22, r22
    2f1e:	82 9f       	mul	r24, r18
    2f20:	22 27       	eor	r18, r18
    2f22:	b0 0d       	add	r27, r0
    2f24:	a1 1d       	adc	r26, r1
    2f26:	62 1f       	adc	r22, r18
    2f28:	73 9f       	mul	r23, r19
    2f2a:	b0 0d       	add	r27, r0
    2f2c:	a1 1d       	adc	r26, r1
    2f2e:	62 1f       	adc	r22, r18
    2f30:	83 9f       	mul	r24, r19
    2f32:	a0 0d       	add	r26, r0
    2f34:	61 1d       	adc	r22, r1
    2f36:	22 1f       	adc	r18, r18
    2f38:	74 9f       	mul	r23, r20
    2f3a:	33 27       	eor	r19, r19
    2f3c:	a0 0d       	add	r26, r0
    2f3e:	61 1d       	adc	r22, r1
    2f40:	23 1f       	adc	r18, r19
    2f42:	84 9f       	mul	r24, r20
    2f44:	60 0d       	add	r22, r0
    2f46:	21 1d       	adc	r18, r1
    2f48:	82 2f       	mov	r24, r18
    2f4a:	76 2f       	mov	r23, r22
    2f4c:	6a 2f       	mov	r22, r26
    2f4e:	11 24       	eor	r1, r1
    2f50:	9f 57       	subi	r25, 0x7F	; 127
    2f52:	50 40       	sbci	r21, 0x00	; 0
    2f54:	9a f0       	brmi	.+38     	; 0x2f7c <__mulsf3_pse+0x88>
    2f56:	f1 f0       	breq	.+60     	; 0x2f94 <__mulsf3_pse+0xa0>
    2f58:	88 23       	and	r24, r24
    2f5a:	4a f0       	brmi	.+18     	; 0x2f6e <__mulsf3_pse+0x7a>
    2f5c:	ee 0f       	add	r30, r30
    2f5e:	ff 1f       	adc	r31, r31
    2f60:	bb 1f       	adc	r27, r27
    2f62:	66 1f       	adc	r22, r22
    2f64:	77 1f       	adc	r23, r23
    2f66:	88 1f       	adc	r24, r24
    2f68:	91 50       	subi	r25, 0x01	; 1
    2f6a:	50 40       	sbci	r21, 0x00	; 0
    2f6c:	a9 f7       	brne	.-22     	; 0x2f58 <__mulsf3_pse+0x64>
    2f6e:	9e 3f       	cpi	r25, 0xFE	; 254
    2f70:	51 05       	cpc	r21, r1
    2f72:	80 f0       	brcs	.+32     	; 0x2f94 <__mulsf3_pse+0xa0>
    2f74:	0c 94 0e 17 	jmp	0x2e1c	; 0x2e1c <__fp_inf>
    2f78:	0c 94 59 17 	jmp	0x2eb2	; 0x2eb2 <__fp_szero>
    2f7c:	5f 3f       	cpi	r21, 0xFF	; 255
    2f7e:	e4 f3       	brlt	.-8      	; 0x2f78 <__mulsf3_pse+0x84>
    2f80:	98 3e       	cpi	r25, 0xE8	; 232
    2f82:	d4 f3       	brlt	.-12     	; 0x2f78 <__mulsf3_pse+0x84>
    2f84:	86 95       	lsr	r24
    2f86:	77 95       	ror	r23
    2f88:	67 95       	ror	r22
    2f8a:	b7 95       	ror	r27
    2f8c:	f7 95       	ror	r31
    2f8e:	e7 95       	ror	r30
    2f90:	9f 5f       	subi	r25, 0xFF	; 255
    2f92:	c1 f7       	brne	.-16     	; 0x2f84 <__mulsf3_pse+0x90>
    2f94:	fe 2b       	or	r31, r30
    2f96:	88 0f       	add	r24, r24
    2f98:	91 1d       	adc	r25, r1
    2f9a:	96 95       	lsr	r25
    2f9c:	87 95       	ror	r24
    2f9e:	97 f9       	bld	r25, 7
    2fa0:	08 95       	ret

00002fa2 <__divmodhi4>:
    2fa2:	97 fb       	bst	r25, 7
    2fa4:	07 2e       	mov	r0, r23
    2fa6:	16 f4       	brtc	.+4      	; 0x2fac <__divmodhi4+0xa>
    2fa8:	00 94       	com	r0
    2faa:	07 d0       	rcall	.+14     	; 0x2fba <__divmodhi4_neg1>
    2fac:	77 fd       	sbrc	r23, 7
    2fae:	09 d0       	rcall	.+18     	; 0x2fc2 <__divmodhi4_neg2>
    2fb0:	0e 94 12 18 	call	0x3024	; 0x3024 <__udivmodhi4>
    2fb4:	07 fc       	sbrc	r0, 7
    2fb6:	05 d0       	rcall	.+10     	; 0x2fc2 <__divmodhi4_neg2>
    2fb8:	3e f4       	brtc	.+14     	; 0x2fc8 <__divmodhi4_exit>

00002fba <__divmodhi4_neg1>:
    2fba:	90 95       	com	r25
    2fbc:	81 95       	neg	r24
    2fbe:	9f 4f       	sbci	r25, 0xFF	; 255
    2fc0:	08 95       	ret

00002fc2 <__divmodhi4_neg2>:
    2fc2:	70 95       	com	r23
    2fc4:	61 95       	neg	r22
    2fc6:	7f 4f       	sbci	r23, 0xFF	; 255

00002fc8 <__divmodhi4_exit>:
    2fc8:	08 95       	ret

00002fca <__udivmodsi4>:
    2fca:	a1 e2       	ldi	r26, 0x21	; 33
    2fcc:	1a 2e       	mov	r1, r26
    2fce:	aa 1b       	sub	r26, r26
    2fd0:	bb 1b       	sub	r27, r27
    2fd2:	fd 01       	movw	r30, r26
    2fd4:	0d c0       	rjmp	.+26     	; 0x2ff0 <__udivmodsi4_ep>

00002fd6 <__udivmodsi4_loop>:
    2fd6:	aa 1f       	adc	r26, r26
    2fd8:	bb 1f       	adc	r27, r27
    2fda:	ee 1f       	adc	r30, r30
    2fdc:	ff 1f       	adc	r31, r31
    2fde:	a2 17       	cp	r26, r18
    2fe0:	b3 07       	cpc	r27, r19
    2fe2:	e4 07       	cpc	r30, r20
    2fe4:	f5 07       	cpc	r31, r21
    2fe6:	20 f0       	brcs	.+8      	; 0x2ff0 <__udivmodsi4_ep>
    2fe8:	a2 1b       	sub	r26, r18
    2fea:	b3 0b       	sbc	r27, r19
    2fec:	e4 0b       	sbc	r30, r20
    2fee:	f5 0b       	sbc	r31, r21

00002ff0 <__udivmodsi4_ep>:
    2ff0:	66 1f       	adc	r22, r22
    2ff2:	77 1f       	adc	r23, r23
    2ff4:	88 1f       	adc	r24, r24
    2ff6:	99 1f       	adc	r25, r25
    2ff8:	1a 94       	dec	r1
    2ffa:	69 f7       	brne	.-38     	; 0x2fd6 <__udivmodsi4_loop>
    2ffc:	60 95       	com	r22
    2ffe:	70 95       	com	r23
    3000:	80 95       	com	r24
    3002:	90 95       	com	r25
    3004:	9b 01       	movw	r18, r22
    3006:	ac 01       	movw	r20, r24
    3008:	bd 01       	movw	r22, r26
    300a:	cf 01       	movw	r24, r30
    300c:	08 95       	ret

0000300e <__muluhisi3>:
    300e:	0e 94 26 18 	call	0x304c	; 0x304c <__umulhisi3>
    3012:	a5 9f       	mul	r26, r21
    3014:	90 0d       	add	r25, r0
    3016:	b4 9f       	mul	r27, r20
    3018:	90 0d       	add	r25, r0
    301a:	a4 9f       	mul	r26, r20
    301c:	80 0d       	add	r24, r0
    301e:	91 1d       	adc	r25, r1
    3020:	11 24       	eor	r1, r1
    3022:	08 95       	ret

00003024 <__udivmodhi4>:
    3024:	aa 1b       	sub	r26, r26
    3026:	bb 1b       	sub	r27, r27
    3028:	51 e1       	ldi	r21, 0x11	; 17
    302a:	07 c0       	rjmp	.+14     	; 0x303a <__udivmodhi4_ep>

0000302c <__udivmodhi4_loop>:
    302c:	aa 1f       	adc	r26, r26
    302e:	bb 1f       	adc	r27, r27
    3030:	a6 17       	cp	r26, r22
    3032:	b7 07       	cpc	r27, r23
    3034:	10 f0       	brcs	.+4      	; 0x303a <__udivmodhi4_ep>
    3036:	a6 1b       	sub	r26, r22
    3038:	b7 0b       	sbc	r27, r23

0000303a <__udivmodhi4_ep>:
    303a:	88 1f       	adc	r24, r24
    303c:	99 1f       	adc	r25, r25
    303e:	5a 95       	dec	r21
    3040:	a9 f7       	brne	.-22     	; 0x302c <__udivmodhi4_loop>
    3042:	80 95       	com	r24
    3044:	90 95       	com	r25
    3046:	bc 01       	movw	r22, r24
    3048:	cd 01       	movw	r24, r26
    304a:	08 95       	ret

0000304c <__umulhisi3>:
    304c:	a2 9f       	mul	r26, r18
    304e:	b0 01       	movw	r22, r0
    3050:	b3 9f       	mul	r27, r19
    3052:	c0 01       	movw	r24, r0
    3054:	a3 9f       	mul	r26, r19
    3056:	70 0d       	add	r23, r0
    3058:	81 1d       	adc	r24, r1
    305a:	11 24       	eor	r1, r1
    305c:	91 1d       	adc	r25, r1
    305e:	b2 9f       	mul	r27, r18
    3060:	70 0d       	add	r23, r0
    3062:	81 1d       	adc	r24, r1
    3064:	11 24       	eor	r1, r1
    3066:	91 1d       	adc	r25, r1
    3068:	08 95       	ret

0000306a <_exit>:
    306a:	f8 94       	cli

0000306c <__stop_program>:
    306c:	ff cf       	rjmp	.-2      	; 0x306c <__stop_program>
